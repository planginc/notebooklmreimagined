{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":"Explore the frontend directory in /Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend to understand:\n1. How the frontend currently fetches data (API routes, Supabase client calls)\n2. What operations are available (notebooks, sources, chat, etc.)\n3. Any existing API abstraction layer in lib/\n4. The data flow patterns being used\n\nFocus on lib/, app/api/, and any service/hook files."},"uuid":"c9454b9a-b22e-430b-bcce-9439ec7309b3","timestamp":"2025-12-29T11:50:31.630Z"}
{"parentUuid":"c9454b9a-b22e-430b-bcce-9439ec7309b3","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Jt4orTE5yQ3NNGYNs4UHYp","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the frontend directory to understand the data fetching patterns, API integration, and existing abstraction layers."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":26961,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":26961,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CWavoyd9Tj9twMvtsfLDA","type":"assistant","uuid":"5f35bb74-9757-4d3b-9c31-0ad28a1e9ce9","timestamp":"2025-12-29T11:50:33.921Z"}
{"parentUuid":"5f35bb74-9757-4d3b-9c31-0ad28a1e9ce9","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Jt4orTE5yQ3NNGYNs4UHYp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SDh7ZBxqh9x1ALMv9DCpqp","name":"Bash","input":{"command":"find /Users/marwankashef/Desktop/YouTube/NotebookLM\\ Re-Mastered/frontend -type f -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.json\" | head -50","description":"Find all TypeScript and JavaScript files in frontend"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":26961,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":26961,"ephemeral_1h_input_tokens":0},"output_tokens":164,"service_tier":"standard"}},"requestId":"req_011CWavoyd9Tj9twMvtsfLDA","type":"assistant","uuid":"cb19cebd-66cd-4123-8db4-02c3ebe1d645","timestamp":"2025-12-29T11:50:34.439Z"}
{"parentUuid":"31aa8ca0-201b-4440-aef5-2bafc91e4e51","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SDh7ZBxqh9x1ALMv9DCpqp","type":"tool_result","content":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/posix.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/constants.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/parse.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/picomatch.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/utils.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/scan.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/fdir/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/tapable.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/HookMap.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncWaterfallHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesLoopHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/Hook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncLoopHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/util-browser.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/HookCodeFactory.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncParallelBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncParallelHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/MultiHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/transformRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/createRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/types.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/useRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/transformRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/types.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/mergeRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/mergeRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/createRef.js","is_error":false}]},"uuid":"8d725ba3-b7e5-46a1-bc4a-25bbf9a8f379","timestamp":"2025-12-29T11:50:34.633Z","toolUseResult":{"stdout":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/queue-microtask/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/is-plain-obj/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/posix.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/constants.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/parse.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/picomatch.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/utils.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/picomatch/lib/scan.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/node_modules/fdir/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tinyglobby/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/callsites/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/@alloc/quick-lru/index.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/tapable.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/package.json\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/HookMap.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncWaterfallHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesWaterfallHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesLoopHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/Hook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncLoopHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/util-browser.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/HookCodeFactory.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncParallelBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/SyncHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncParallelHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/MultiHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/tapable/lib/AsyncSeriesBailHook.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/transformRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/createRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/types.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/useRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/transformRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/types.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/mergeRef.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/mergeRef.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/index.js\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/node_modules/use-callback-ref/dist/es5/createRef.js","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"ee213798-d9ad-4294-a8d5-12840d2c0635","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S6TmNGwWm7twKDzsyiSMjq","type":"message","role":"assistant","content":[{"type":"text","text":"Let me narrow down to the actual app source files:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2402,"cache_read_input_tokens":26961,"cache_creation":{"ephemeral_5m_input_tokens":2402,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWavpD7G7PXRdcKxy4snD","type":"assistant","uuid":"2b44f395-eb3c-4903-a492-c97b635529c1","timestamp":"2025-12-29T11:50:36.977Z"}
{"parentUuid":"2b44f395-eb3c-4903-a492-c97b635529c1","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01S6TmNGwWm7twKDzsyiSMjq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SnBNsiCx62huuerNY2qeDH","name":"Bash","input":{"command":"find /Users/marwankashef/Desktop/YouTube/NotebookLM\\ Re-Mastered/frontend -path \"*/node_modules\" -prune -o -type f \\( -name \"*.ts\" -o -name \"*.tsx\" \\) -print","description":"Find all TypeScript files excluding node_modules"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":2402,"cache_read_input_tokens":26961,"cache_creation":{"ephemeral_5m_input_tokens":2402,"ephemeral_1h_input_tokens":0},"output_tokens":151,"service_tier":"standard"}},"requestId":"req_011CWavpD7G7PXRdcKxy4snD","type":"assistant","uuid":"35a508a8-87b7-4128-a283-b364610ea681","timestamp":"2025-12-29T11:50:37.510Z"}
{"parentUuid":"f819dec9-7073-4776-a00c-e68a1802441a","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SnBNsiCx62huuerNY2qeDH","type":"tool_result","content":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/types/routes.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/types/validator.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/cache-life.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/routes.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/validator.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/next-env.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/next.config.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/auth/register/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/auth/login/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/layout.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/sources/[id]/view/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/research/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/studio/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/video/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/study/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/sessions/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/sessions/[sessionId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/audio/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/notes/[noteId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/notes/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/[sourceId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/notebooks/[id]/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/providers.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/tabs.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/card.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/slider.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/popover.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/progress.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/sheet.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/scroll-area.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/label.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/sonner.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/tooltip.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/radio-group.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/avatar.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/dialog.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/badge.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/separator.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/button.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/checkbox.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/dropdown-menu.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/select.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/textarea.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/input.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/context-menu.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/studio-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/audio-player.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/video-player.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/research-report.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/generation-config-dialog.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/quiz-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/study-guide-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/flashcard-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/mind-map-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/faq-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/chat/chat-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/panels/three-panel-layout.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/tabs.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/header.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/notebook-card.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/featured-carousel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/sources/sources-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase-server.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/utils.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/api.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/gemini.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase.ts","is_error":false}]},"uuid":"58778c9b-1498-4514-9cc2-b4e60d39ed9b","timestamp":"2025-12-29T11:50:37.663Z","toolUseResult":{"stdout":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/types/routes.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/types/validator.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/cache-life.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/routes.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/.next/dev/types/validator.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/next-env.d.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/next.config.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/auth/register/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/auth/login/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/layout.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/sources/[id]/view/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/research/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/studio/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/video/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/study/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/sessions/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/sessions/[sessionId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/audio/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/notes/[noteId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/notes/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/[sourceId]/route.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/notebooks/[id]/page.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/providers.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/tabs.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/card.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/slider.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/popover.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/progress.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/sheet.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/scroll-area.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/label.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/sonner.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/tooltip.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/radio-group.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/avatar.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/dialog.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/badge.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/separator.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/button.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/checkbox.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/dropdown-menu.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/select.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/textarea.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/input.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/ui/context-menu.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/studio-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/audio-player.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/video-player.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/research-report.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/studio/generation-config-dialog.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/quiz-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/study-guide-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/flashcard-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/mind-map-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/study/faq-viewer.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/chat/chat-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/panels/three-panel-layout.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/tabs.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/header.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/notebook-card.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/dashboard/featured-carousel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/sources/sources-panel.tsx\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase-server.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/utils.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/api.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/gemini.ts\n/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase.ts","stderr":"","interrupted":false,"isImage":false}}
{"parentUuid":"39747de9-e744-467c-9fdf-812a48c8557e","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FxpHf2XCuoq5srwMAgjUwn","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me explore the key files to understand the architecture. Let me start with the lib directory and api.ts:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2870,"cache_read_input_tokens":29363,"cache_creation":{"ephemeral_5m_input_tokens":2870,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavpRVQ4J7jxmoBu8Aim","type":"assistant","uuid":"f8cc4d79-ffce-4f2a-8ef3-8bd169712846","timestamp":"2025-12-29T11:50:40.004Z"}
{"parentUuid":"f8cc4d79-ffce-4f2a-8ef3-8bd169712846","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FxpHf2XCuoq5srwMAgjUwn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Pkz7zoLtgFQbJKRAXm63Mc","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/api.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2870,"cache_read_input_tokens":29363,"cache_creation":{"ephemeral_5m_input_tokens":2870,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavpRVQ4J7jxmoBu8Aim","type":"assistant","uuid":"d1502f9f-bfe1-4ed2-aa31-3e5d301489c0","timestamp":"2025-12-29T11:50:40.402Z"}
{"parentUuid":"d1502f9f-bfe1-4ed2-aa31-3e5d301489c0","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FxpHf2XCuoq5srwMAgjUwn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BjsbgESBnferC8hEgTRQ1N","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2870,"cache_read_input_tokens":29363,"cache_creation":{"ephemeral_5m_input_tokens":2870,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavpRVQ4J7jxmoBu8Aim","type":"assistant","uuid":"35807001-7e7d-49b5-85c6-10f79ed12720","timestamp":"2025-12-29T11:50:40.582Z"}
{"parentUuid":"35807001-7e7d-49b5-85c6-10f79ed12720","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FxpHf2XCuoq5srwMAgjUwn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uf5FDtY1KMhggCF58L6CTz","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase-server.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":2870,"cache_read_input_tokens":29363,"cache_creation":{"ephemeral_5m_input_tokens":2870,"ephemeral_1h_input_tokens":0},"output_tokens":254,"service_tier":"standard"}},"requestId":"req_011CWavpRVQ4J7jxmoBu8Aim","type":"assistant","uuid":"99794625-6633-4f3b-b6dd-9877300faba3","timestamp":"2025-12-29T11:50:40.873Z"}
{"parentUuid":"99794625-6633-4f3b-b6dd-9877300faba3","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Pkz7zoLtgFQbJKRAXm63Mc","type":"tool_result","content":"     1→// API client for Open NotebookLM\n     2→\n     3→const API_BASE = process.env.NEXT_PUBLIC_API_URL || ''\n     4→\n     5→export interface ApiResponse<T = unknown> {\n     6→  data: T\n     7→  usage?: {\n     8→    input_tokens: number\n     9→    output_tokens: number\n    10→    cost_usd: number\n    11→    model_used: string\n    12→  }\n    13→}\n    14→\n    15→export interface ChatRequest {\n    16→  message: string\n    17→  source_ids?: string[]\n    18→  session_id?: string\n    19→  model?: string\n    20→}\n    21→\n    22→export interface ChatResponse {\n    23→  message_id: string\n    24→  session_id: string\n    25→  content: string\n    26→  citations: Citation[]\n    27→  suggested_questions: string[]\n    28→}\n    29→\n    30→export interface Citation {\n    31→  number: number\n    32→  source_id: string\n    33→  source_name: string\n    34→  text: string\n    35→  confidence: number\n    36→}\n    37→\n    38→export interface Flashcard {\n    39→  question: string\n    40→  answer: string\n    41→}\n    42→\n    43→export interface QuizQuestion {\n    44→  question: string\n    45→  options: string[]\n    46→  correct_index: number\n    47→  explanation: string\n    48→}\n    49→\n    50→export interface StudyGuide {\n    51→  title: string\n    52→  summary: string\n    53→  key_concepts: { term: string; definition: string; importance: string }[]\n    54→  glossary: { term: string; definition: string }[]\n    55→  review_questions: string[]\n    56→}\n    57→\n    58→export interface FAQ {\n    59→  question: string\n    60→  answer: string\n    61→}\n    62→\n    63→export interface AudioOverview {\n    64→  id: string\n    65→  notebook_id: string\n    66→  format: string\n    67→  status: 'pending' | 'processing' | 'completed' | 'failed'\n    68→  progress_percent: number\n    69→  script?: string\n    70→  audio_file_path?: string\n    71→  duration_seconds?: number\n    72→  cost_usd?: number\n    73→  error_message?: string\n    74→  created_at: string\n    75→  completed_at?: string\n    76→}\n    77→\n    78→export interface Note {\n    79→  id: string\n    80→  notebook_id: string\n    81→  type: 'written' | 'saved_response'\n    82→  title?: string\n    83→  content?: string\n    84→  tags?: string[]\n    85→  is_pinned: boolean\n    86→  original_message_id?: string\n    87→  created_at: string\n    88→  updated_at: string\n    89→}\n    90→\n    91→// Helper to get auth token\n    92→async function getAuthToken(): Promise<string | null> {\n    93→  const { createClient } = await import('./supabase')\n    94→  const supabase = createClient()\n    95→  const { data: { session } } = await supabase.auth.getSession()\n    96→  return session?.access_token || null\n    97→}\n    98→\n    99→// Fetch wrapper with auth\n   100→async function fetchWithAuth(endpoint: string, options: RequestInit = {}) {\n   101→  const token = await getAuthToken()\n   102→\n   103→  const headers: HeadersInit = {\n   104→    'Content-Type': 'application/json',\n   105→    ...options.headers,\n   106→  }\n   107→\n   108→  if (token) {\n   109→    (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`\n   110→  }\n   111→\n   112→  const response = await fetch(`${API_BASE}${endpoint}`, {\n   113→    ...options,\n   114→    headers,\n   115→  })\n   116→\n   117→  if (!response.ok) {\n   118→    const error = await response.json().catch(() => ({ detail: 'Request failed' }))\n   119→    throw new Error(error.detail || 'Request failed')\n   120→  }\n   121→\n   122→  return response.json()\n   123→}\n   124→\n   125→// Chat API\n   126→export const chatApi = {\n   127→  async sendMessage(notebookId: string, request: ChatRequest): Promise<ApiResponse<ChatResponse>> {\n   128→    return fetchWithAuth(`/api/notebooks/${notebookId}/chat`, {\n   129→      method: 'POST',\n   130→      body: JSON.stringify(request),\n   131→    })\n   132→  },\n   133→\n   134→  async getSessions(notebookId: string) {\n   135→    return fetchWithAuth(`/api/notebooks/${notebookId}/chat/sessions`)\n   136→  },\n   137→\n   138→  async getSession(notebookId: string, sessionId: string) {\n   139→    return fetchWithAuth(`/api/notebooks/${notebookId}/chat/sessions/${sessionId}`)\n   140→  },\n   141→}\n   142→\n   143→// Study Materials API\n   144→export const studyApi = {\n   145→  async generateFlashcards(notebookId: string, sourceIds?: string[], count = 10): Promise<ApiResponse<{ flashcards: Flashcard[] }>> {\n   146→    return fetchWithAuth(`/api/notebooks/${notebookId}/flashcards`, {\n   147→      method: 'POST',\n   148→      body: JSON.stringify({ source_ids: sourceIds, count }),\n   149→    })\n   150→  },\n   151→\n   152→  async generateQuiz(notebookId: string, sourceIds?: string[], questionCount = 10): Promise<ApiResponse<{ questions: QuizQuestion[] }>> {\n   153→    return fetchWithAuth(`/api/notebooks/${notebookId}/quiz`, {\n   154→      method: 'POST',\n   155→      body: JSON.stringify({ source_ids: sourceIds, question_count: questionCount }),\n   156→    })\n   157→  },\n   158→\n   159→  async generateStudyGuide(notebookId: string, sourceIds?: string[]): Promise<ApiResponse<StudyGuide>> {\n   160→    return fetchWithAuth(`/api/notebooks/${notebookId}/study-guide`, {\n   161→      method: 'POST',\n   162→      body: JSON.stringify({ source_ids: sourceIds }),\n   163→    })\n   164→  },\n   165→\n   166→  async generateFaq(notebookId: string, sourceIds?: string[], count = 10): Promise<ApiResponse<{ faqs: FAQ[] }>> {\n   167→    return fetchWithAuth(`/api/notebooks/${notebookId}/faq`, {\n   168→      method: 'POST',\n   169→      body: JSON.stringify({ source_ids: sourceIds, count }),\n   170→    })\n   171→  },\n   172→}\n   173→\n   174→// Audio API\n   175→export const audioApi = {\n   176→  async estimate(notebookId: string, format: string, sourceIds?: string[]) {\n   177→    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/estimate`, {\n   178→      method: 'POST',\n   179→      body: JSON.stringify({ format, source_ids: sourceIds }),\n   180→    })\n   181→  },\n   182→\n   183→  async generate(notebookId: string, format: string, sourceIds?: string[], customInstructions?: string): Promise<ApiResponse<AudioOverview>> {\n   184→    return fetchWithAuth(`/api/notebooks/${notebookId}/audio`, {\n   185→      method: 'POST',\n   186→      body: JSON.stringify({ format, source_ids: sourceIds, custom_instructions: customInstructions }),\n   187→    })\n   188→  },\n   189→\n   190→  async list(notebookId: string): Promise<ApiResponse<AudioOverview[]>> {\n   191→    return fetchWithAuth(`/api/notebooks/${notebookId}/audio`)\n   192→  },\n   193→\n   194→  async get(notebookId: string, audioId: string): Promise<ApiResponse<AudioOverview>> {\n   195→    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/${audioId}`)\n   196→  },\n   197→\n   198→  async delete(notebookId: string, audioId: string) {\n   199→    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/${audioId}`, {\n   200→      method: 'DELETE',\n   201→    })\n   202→  },\n   203→}\n   204→\n   205→// Notes API\n   206→export const notesApi = {\n   207→  async create(notebookId: string, title: string, content: string, tags?: string[]): Promise<ApiResponse<Note>> {\n   208→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes`, {\n   209→      method: 'POST',\n   210→      body: JSON.stringify({ title, content, tags }),\n   211→    })\n   212→  },\n   213→\n   214→  async list(notebookId: string): Promise<ApiResponse<Note[]>> {\n   215→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes`)\n   216→  },\n   217→\n   218→  async get(notebookId: string, noteId: string): Promise<ApiResponse<Note>> {\n   219→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`)\n   220→  },\n   221→\n   222→  async update(notebookId: string, noteId: string, data: Partial<Note>): Promise<ApiResponse<Note>> {\n   223→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`, {\n   224→      method: 'PATCH',\n   225→      body: JSON.stringify(data),\n   226→    })\n   227→  },\n   228→\n   229→  async delete(notebookId: string, noteId: string) {\n   230→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`, {\n   231→      method: 'DELETE',\n   232→    })\n   233→  },\n   234→\n   235→  async saveResponse(notebookId: string, messageId: string): Promise<ApiResponse<Note>> {\n   236→    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/save-response`, {\n   237→      method: 'POST',\n   238→      body: JSON.stringify({ message_id: messageId }),\n   239→    })\n   240→  },\n   241→}\n   242→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1e155dcc-085f-4b37-993c-bb6b56ae8c77","timestamp":"2025-12-29T11:50:40.926Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/api.ts","content":"// API client for Open NotebookLM\n\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL || ''\n\nexport interface ApiResponse<T = unknown> {\n  data: T\n  usage?: {\n    input_tokens: number\n    output_tokens: number\n    cost_usd: number\n    model_used: string\n  }\n}\n\nexport interface ChatRequest {\n  message: string\n  source_ids?: string[]\n  session_id?: string\n  model?: string\n}\n\nexport interface ChatResponse {\n  message_id: string\n  session_id: string\n  content: string\n  citations: Citation[]\n  suggested_questions: string[]\n}\n\nexport interface Citation {\n  number: number\n  source_id: string\n  source_name: string\n  text: string\n  confidence: number\n}\n\nexport interface Flashcard {\n  question: string\n  answer: string\n}\n\nexport interface QuizQuestion {\n  question: string\n  options: string[]\n  correct_index: number\n  explanation: string\n}\n\nexport interface StudyGuide {\n  title: string\n  summary: string\n  key_concepts: { term: string; definition: string; importance: string }[]\n  glossary: { term: string; definition: string }[]\n  review_questions: string[]\n}\n\nexport interface FAQ {\n  question: string\n  answer: string\n}\n\nexport interface AudioOverview {\n  id: string\n  notebook_id: string\n  format: string\n  status: 'pending' | 'processing' | 'completed' | 'failed'\n  progress_percent: number\n  script?: string\n  audio_file_path?: string\n  duration_seconds?: number\n  cost_usd?: number\n  error_message?: string\n  created_at: string\n  completed_at?: string\n}\n\nexport interface Note {\n  id: string\n  notebook_id: string\n  type: 'written' | 'saved_response'\n  title?: string\n  content?: string\n  tags?: string[]\n  is_pinned: boolean\n  original_message_id?: string\n  created_at: string\n  updated_at: string\n}\n\n// Helper to get auth token\nasync function getAuthToken(): Promise<string | null> {\n  const { createClient } = await import('./supabase')\n  const supabase = createClient()\n  const { data: { session } } = await supabase.auth.getSession()\n  return session?.access_token || null\n}\n\n// Fetch wrapper with auth\nasync function fetchWithAuth(endpoint: string, options: RequestInit = {}) {\n  const token = await getAuthToken()\n\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    ...options.headers,\n  }\n\n  if (token) {\n    (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`\n  }\n\n  const response = await fetch(`${API_BASE}${endpoint}`, {\n    ...options,\n    headers,\n  })\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ detail: 'Request failed' }))\n    throw new Error(error.detail || 'Request failed')\n  }\n\n  return response.json()\n}\n\n// Chat API\nexport const chatApi = {\n  async sendMessage(notebookId: string, request: ChatRequest): Promise<ApiResponse<ChatResponse>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/chat`, {\n      method: 'POST',\n      body: JSON.stringify(request),\n    })\n  },\n\n  async getSessions(notebookId: string) {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/chat/sessions`)\n  },\n\n  async getSession(notebookId: string, sessionId: string) {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/chat/sessions/${sessionId}`)\n  },\n}\n\n// Study Materials API\nexport const studyApi = {\n  async generateFlashcards(notebookId: string, sourceIds?: string[], count = 10): Promise<ApiResponse<{ flashcards: Flashcard[] }>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/flashcards`, {\n      method: 'POST',\n      body: JSON.stringify({ source_ids: sourceIds, count }),\n    })\n  },\n\n  async generateQuiz(notebookId: string, sourceIds?: string[], questionCount = 10): Promise<ApiResponse<{ questions: QuizQuestion[] }>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/quiz`, {\n      method: 'POST',\n      body: JSON.stringify({ source_ids: sourceIds, question_count: questionCount }),\n    })\n  },\n\n  async generateStudyGuide(notebookId: string, sourceIds?: string[]): Promise<ApiResponse<StudyGuide>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/study-guide`, {\n      method: 'POST',\n      body: JSON.stringify({ source_ids: sourceIds }),\n    })\n  },\n\n  async generateFaq(notebookId: string, sourceIds?: string[], count = 10): Promise<ApiResponse<{ faqs: FAQ[] }>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/faq`, {\n      method: 'POST',\n      body: JSON.stringify({ source_ids: sourceIds, count }),\n    })\n  },\n}\n\n// Audio API\nexport const audioApi = {\n  async estimate(notebookId: string, format: string, sourceIds?: string[]) {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/estimate`, {\n      method: 'POST',\n      body: JSON.stringify({ format, source_ids: sourceIds }),\n    })\n  },\n\n  async generate(notebookId: string, format: string, sourceIds?: string[], customInstructions?: string): Promise<ApiResponse<AudioOverview>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/audio`, {\n      method: 'POST',\n      body: JSON.stringify({ format, source_ids: sourceIds, custom_instructions: customInstructions }),\n    })\n  },\n\n  async list(notebookId: string): Promise<ApiResponse<AudioOverview[]>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/audio`)\n  },\n\n  async get(notebookId: string, audioId: string): Promise<ApiResponse<AudioOverview>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/${audioId}`)\n  },\n\n  async delete(notebookId: string, audioId: string) {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/audio/${audioId}`, {\n      method: 'DELETE',\n    })\n  },\n}\n\n// Notes API\nexport const notesApi = {\n  async create(notebookId: string, title: string, content: string, tags?: string[]): Promise<ApiResponse<Note>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes`, {\n      method: 'POST',\n      body: JSON.stringify({ title, content, tags }),\n    })\n  },\n\n  async list(notebookId: string): Promise<ApiResponse<Note[]>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes`)\n  },\n\n  async get(notebookId: string, noteId: string): Promise<ApiResponse<Note>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`)\n  },\n\n  async update(notebookId: string, noteId: string, data: Partial<Note>): Promise<ApiResponse<Note>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`, {\n      method: 'PATCH',\n      body: JSON.stringify(data),\n    })\n  },\n\n  async delete(notebookId: string, noteId: string) {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/${noteId}`, {\n      method: 'DELETE',\n    })\n  },\n\n  async saveResponse(notebookId: string, messageId: string): Promise<ApiResponse<Note>> {\n    return fetchWithAuth(`/api/notebooks/${notebookId}/notes/save-response`, {\n      method: 'POST',\n      body: JSON.stringify({ message_id: messageId }),\n    })\n  },\n}\n","numLines":242,"startLine":1,"totalLines":242}}}
{"parentUuid":"1e155dcc-085f-4b37-993c-bb6b56ae8c77","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BjsbgESBnferC8hEgTRQ1N","type":"tool_result","content":"     1→import { createBrowserClient } from '@supabase/ssr'\n     2→\n     3→export function createClient() {\n     4→  return createBrowserClient(\n     5→    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     6→    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     7→  )\n     8→}\n     9→\n    10→// Types for our database\n    11→export interface Notebook {\n    12→  id: string\n    13→  user_id: string\n    14→  name: string\n    15→  description: string | null\n    16→  emoji: string\n    17→  settings: Record<string, unknown>\n    18→  file_search_store_id: string | null\n    19→  source_count: number\n    20→  is_featured?: boolean\n    21→  is_archived?: boolean\n    22→  created_at: string\n    23→  updated_at: string\n    24→}\n    25→\n    26→export interface Source {\n    27→  id: string\n    28→  notebook_id: string\n    29→  type: 'pdf' | 'docx' | 'txt' | 'youtube' | 'url' | 'audio' | 'text'\n    30→  name: string\n    31→  status: 'pending' | 'processing' | 'ready' | 'failed'\n    32→  file_path: string | null\n    33→  original_filename: string | null\n    34→  mime_type: string | null\n    35→  file_size_bytes: number | null\n    36→  token_count: number | null\n    37→  metadata: Record<string, unknown>\n    38→  source_guide: {\n    39→    summary?: string\n    40→    topics?: string[]\n    41→    suggested_questions?: string[]\n    42→  } | null\n    43→  error_message: string | null\n    44→  created_at: string\n    45→  updated_at: string\n    46→}\n    47→\n    48→export interface ChatSession {\n    49→  id: string\n    50→  notebook_id: string\n    51→  title: string | null\n    52→  created_at: string\n    53→  updated_at: string\n    54→}\n    55→\n    56→export interface ChatMessage {\n    57→  id: string\n    58→  session_id: string\n    59→  role: 'user' | 'assistant'\n    60→  content: string\n    61→  citations: Citation[]\n    62→  source_ids_used: string[]\n    63→  model_used: string | null\n    64→  input_tokens: number | null\n    65→  output_tokens: number | null\n    66→  cost_usd: number | null\n    67→  created_at: string\n    68→}\n    69→\n    70→export interface Citation {\n    71→  number: number\n    72→  source_id: string\n    73→  source_name: string\n    74→  text: string\n    75→  file_path?: string | null\n    76→  confidence: number\n    77→}\n    78→\n    79→export interface AudioOverview {\n    80→  id: string\n    81→  notebook_id: string\n    82→  format: 'deep_dive' | 'brief' | 'critique' | 'debate'\n    83→  status: string\n    84→  progress_percent: number\n    85→  custom_instructions: string | null\n    86→  source_ids: string[]\n    87→  script: string | null\n    88→  audio_file_path: string | null\n    89→  duration_seconds: number | null\n    90→  model_used: string | null\n    91→  cost_usd: number | null\n    92→  error_message: string | null\n    93→  created_at: string\n    94→  completed_at: string | null\n    95→}\n    96→\n    97→export interface Note {\n    98→  id: string\n    99→  notebook_id: string\n   100→  type: 'written' | 'saved_response'\n   101→  title: string | null\n   102→  content: string | null\n   103→  tags: string[]\n   104→  is_pinned: boolean\n   105→  original_message_id: string | null\n   106→  created_at: string\n   107→  updated_at: string\n   108→}\n   109→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0cfde366-272f-41d3-8ca1-9da8322bf000","timestamp":"2025-12-29T11:50:40.927Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase.ts","content":"import { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n}\n\n// Types for our database\nexport interface Notebook {\n  id: string\n  user_id: string\n  name: string\n  description: string | null\n  emoji: string\n  settings: Record<string, unknown>\n  file_search_store_id: string | null\n  source_count: number\n  is_featured?: boolean\n  is_archived?: boolean\n  created_at: string\n  updated_at: string\n}\n\nexport interface Source {\n  id: string\n  notebook_id: string\n  type: 'pdf' | 'docx' | 'txt' | 'youtube' | 'url' | 'audio' | 'text'\n  name: string\n  status: 'pending' | 'processing' | 'ready' | 'failed'\n  file_path: string | null\n  original_filename: string | null\n  mime_type: string | null\n  file_size_bytes: number | null\n  token_count: number | null\n  metadata: Record<string, unknown>\n  source_guide: {\n    summary?: string\n    topics?: string[]\n    suggested_questions?: string[]\n  } | null\n  error_message: string | null\n  created_at: string\n  updated_at: string\n}\n\nexport interface ChatSession {\n  id: string\n  notebook_id: string\n  title: string | null\n  created_at: string\n  updated_at: string\n}\n\nexport interface ChatMessage {\n  id: string\n  session_id: string\n  role: 'user' | 'assistant'\n  content: string\n  citations: Citation[]\n  source_ids_used: string[]\n  model_used: string | null\n  input_tokens: number | null\n  output_tokens: number | null\n  cost_usd: number | null\n  created_at: string\n}\n\nexport interface Citation {\n  number: number\n  source_id: string\n  source_name: string\n  text: string\n  file_path?: string | null\n  confidence: number\n}\n\nexport interface AudioOverview {\n  id: string\n  notebook_id: string\n  format: 'deep_dive' | 'brief' | 'critique' | 'debate'\n  status: string\n  progress_percent: number\n  custom_instructions: string | null\n  source_ids: string[]\n  script: string | null\n  audio_file_path: string | null\n  duration_seconds: number | null\n  model_used: string | null\n  cost_usd: number | null\n  error_message: string | null\n  created_at: string\n  completed_at: string | null\n}\n\nexport interface Note {\n  id: string\n  notebook_id: string\n  type: 'written' | 'saved_response'\n  title: string | null\n  content: string | null\n  tags: string[]\n  is_pinned: boolean\n  original_message_id: string | null\n  created_at: string\n  updated_at: string\n}\n","numLines":109,"startLine":1,"totalLines":109}}}
{"parentUuid":"0cfde366-272f-41d3-8ca1-9da8322bf000","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uf5FDtY1KMhggCF58L6CTz","type":"tool_result","content":"     1→import { createServerClient } from '@supabase/ssr'\n     2→import { cookies } from 'next/headers'\n     3→\n     4→export async function createServerSupabaseClient() {\n     5→  const cookieStore = await cookies()\n     6→\n     7→  return createServerClient(\n     8→    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     9→    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    10→    {\n    11→      cookies: {\n    12→        getAll() {\n    13→          return cookieStore.getAll()\n    14→        },\n    15→        setAll(cookiesToSet) {\n    16→          try {\n    17→            cookiesToSet.forEach(({ name, value, options }) =>\n    18→              cookieStore.set(name, value, options)\n    19→            )\n    20→          } catch {\n    21→            // The `setAll` method was called from a Server Component.\n    22→            // This can be ignored if you have middleware refreshing user sessions.\n    23→          }\n    24→        },\n    25→      },\n    26→    }\n    27→  )\n    28→}\n    29→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"195c24f4-3ce9-48a0-b983-4d9aa75a70b2","timestamp":"2025-12-29T11:50:40.927Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/supabase-server.ts","content":"import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\nexport async function createServerSupabaseClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n","numLines":29,"startLine":1,"totalLines":29}}}
{"parentUuid":"195c24f4-3ce9-48a0-b983-4d9aa75a70b2","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QZgSga6ovFo3qq8MgZ3Nf4","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check the gemini integration and some of the API routes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":4999,"cache_read_input_tokens":32233,"cache_creation":{"ephemeral_5m_input_tokens":4999,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavph3H9pbL5xZGCtAot","type":"assistant","uuid":"5724e35a-b6d0-4a59-921c-360052ccc294","timestamp":"2025-12-29T11:50:44.751Z"}
{"parentUuid":"5724e35a-b6d0-4a59-921c-360052ccc294","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QZgSga6ovFo3qq8MgZ3Nf4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014btLBhjhFF47D9QofQm6Vj","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/gemini.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":4999,"cache_read_input_tokens":32233,"cache_creation":{"ephemeral_5m_input_tokens":4999,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavph3H9pbL5xZGCtAot","type":"assistant","uuid":"3b1c04dd-26fa-431c-805f-b1193fd273f0","timestamp":"2025-12-29T11:50:45.587Z"}
{"parentUuid":"3b1c04dd-26fa-431c-805f-b1193fd273f0","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QZgSga6ovFo3qq8MgZ3Nf4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VpVbXjixpg3NnNKkwJsgTd","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":4999,"cache_read_input_tokens":32233,"cache_creation":{"ephemeral_5m_input_tokens":4999,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavph3H9pbL5xZGCtAot","type":"assistant","uuid":"5deef252-ca38-4dbd-8c4b-74a143c9a275","timestamp":"2025-12-29T11:50:45.857Z"}
{"parentUuid":"5deef252-ca38-4dbd-8c4b-74a143c9a275","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QZgSga6ovFo3qq8MgZ3Nf4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HTNddYhJYF6cxw9r3eNAo7","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":4999,"cache_read_input_tokens":32233,"cache_creation":{"ephemeral_5m_input_tokens":4999,"ephemeral_1h_input_tokens":0},"output_tokens":256,"service_tier":"standard"}},"requestId":"req_011CWavph3H9pbL5xZGCtAot","type":"assistant","uuid":"435e4588-86b4-41a1-a793-139208e5c382","timestamp":"2025-12-29T11:50:46.097Z"}
{"parentUuid":"435e4588-86b4-41a1-a793-139208e5c382","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VpVbXjixpg3NnNKkwJsgTd","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→import { GoogleGenerativeAI, Part } from '@google/generative-ai'\n     4→\n     5→const supabase = createClient(\n     6→  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     7→  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     8→)\n     9→\n    10→const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY\n    11→\n    12→// Download file from Supabase Storage and return as base64\n    13→async function downloadFileAsBase64(filePath: string): Promise<{ data: string; mimeType: string } | null> {\n    14→  try {\n    15→    const { data, error } = await supabase.storage\n    16→      .from('sources')\n    17→      .download(filePath)\n    18→\n    19→    if (error || !data) {\n    20→      console.error('Failed to download file:', error)\n    21→      return null\n    22→    }\n    23→\n    24→    const buffer = await data.arrayBuffer()\n    25→    const base64 = Buffer.from(buffer).toString('base64')\n    26→\n    27→    // Determine mime type from extension\n    28→    const ext = filePath.split('.').pop()?.toLowerCase()\n    29→    const mimeTypes: Record<string, string> = {\n    30→      'pdf': 'application/pdf',\n    31→      'txt': 'text/plain',\n    32→      'md': 'text/markdown',\n    33→      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    34→    }\n    35→\n    36→    return {\n    37→      data: base64,\n    38→      mimeType: mimeTypes[ext || ''] || 'application/octet-stream'\n    39→    }\n    40→  } catch (error) {\n    41→    console.error('Error downloading file:', error)\n    42→    return null\n    43→  }\n    44→}\n    45→\n    46→// Parse citations from the AI response to extract quoted text\n    47→function extractCitationsFromResponse(\n    48→  responseText: string,\n    49→  sourceNames: string[]\n    50→): { cleanedContent: string; citations: Array<{ number: number; source_name: string; text: string }> } {\n    51→  // Check if response has JSON citations block at the end\n    52→  const jsonMatch = responseText.match(/\\n?---CITATIONS---\\n?([\\s\\S]*?)$/);\n    53→\n    54→  if (jsonMatch) {\n    55→    try {\n    56→      const citationsJson = JSON.parse(jsonMatch[1]);\n    57→      const cleanedContent = responseText.replace(/\\n?---CITATIONS---\\n?[\\s\\S]*$/, '').trim();\n    58→\n    59→      return {\n    60→        cleanedContent,\n    61→        citations: citationsJson.map((c: { number: number; quote: string }) => ({\n    62→          number: c.number,\n    63→          source_name: sourceNames[c.number - 1] || `Source ${c.number}`,\n    64→          text: c.quote || '',\n    65→        })),\n    66→      };\n    67→    } catch {\n    68→      // JSON parsing failed, fall through to regex extraction\n    69→    }\n    70→  }\n    71→\n    72→  // Fallback: Extract citations by finding patterns like [1], [2] and nearby quoted text\n    73→  const citations: Array<{ number: number; source_name: string; text: string }> = [];\n    74→  const citationNumbers = new Set<number>();\n    75→\n    76→  // Find all citation numbers used in the response\n    77→  const citationMatches = responseText.matchAll(/\\[(\\d+)\\]/g);\n    78→  for (const match of citationMatches) {\n    79→    citationNumbers.add(parseInt(match[1]));\n    80→  }\n    81→\n    82→  // Create citations for each unique number\n    83→  for (const num of citationNumbers) {\n    84→    citations.push({\n    85→      number: num,\n    86→      source_name: sourceNames[num - 1] || `Source ${num}`,\n    87→      text: '', // Will be filled by second Gemini call if needed\n    88→    });\n    89→  }\n    90→\n    91→  // Sort by number\n    92→  citations.sort((a, b) => a.number - b.number);\n    93→\n    94→  return {\n    95→    cleanedContent: responseText,\n    96→    citations,\n    97→  };\n    98→}\n    99→\n   100→// Source info type for tracking indices\n   101→interface SourceInfo {\n   102→  index: number\n   103→  id: string\n   104→  name: string\n   105→  content?: string\n   106→  isPdf?: boolean\n   107→  filePath?: string\n   108→}\n   109→\n   110→// Generate AI response using Gemini with file support\n   111→async function generateAIResponse(\n   112→  message: string,\n   113→  sourceInfos: SourceInfo[],\n   114→  fileParts: Part[] = []\n   115→) {\n   116→  const sourceNames = sourceInfos.map(s => s.name)\n   117→  const sourceContent = sourceInfos.filter(s => s.content).map(s => s.content!)\n   118→\n   119→  if (!GOOGLE_API_KEY) {\n   120→    return generateDemoResponse(message, sourceContent, sourceNames)\n   121→  }\n   122→\n   123→  try {\n   124→    const genAI = new GoogleGenerativeAI(GOOGLE_API_KEY)\n   125→    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' })\n   126→\n   127→    // Build source list with correct indices\n   128→    const sourceList = sourceInfos.map(s => `[${s.index}] ${s.name}`).join('\\n')\n   129→\n   130→    // Build context text with correct source indices (only for non-PDF sources)\n   131→    const contextText = sourceInfos\n   132→      .filter(s => s.content)\n   133→      .map(s => `[Source ${s.index}: ${s.name}]\\n${s.content}`)\n   134→      .join('\\n\\n---\\n\\n')\n   135→\n   136→    // Build PDF source list for clarity\n   137→    const pdfSources = sourceInfos.filter(s => s.isPdf)\n   138→    const pdfNote = pdfSources.length > 0\n   139→      ? `\\nATTACHED PDF DOCUMENTS (cite using their numbers):\\n${pdfSources.map(s => `[${s.index}] = \"${s.name}\" (PDF attached below)`).join('\\n')}`\n   140→      : ''\n   141→\n   142→    const prompt = `You are a helpful research assistant. Answer the user's question based ONLY on the provided sources.\n   143→\n   144→CRITICAL CITATION RULES:\n   145→- You have exactly ${sourceInfos.length} source(s) numbered [1] through [${sourceInfos.length}]\n   146→- ONLY use citation numbers [1] to [${sourceInfos.length}] - no other numbers!\n   147→- Each citation MUST reference one of the sources listed below\n   148→- When you cite information, use the source number like [1] or [2]\n   149→\n   150→YOUR SOURCES:\n   151→${sourceInfos.map(s => `[${s.index}] = \"${s.name}\"${s.isPdf ? ' (PDF document)' : ''}`).join('\\n')}\n   152→${pdfNote}\n   153→${contextText ? `\\nTEXT SOURCE CONTENT:\\n${contextText}` : ''}\n   154→${fileParts.length > 0 ? `\\nNote: PDF documents are attached below. Cite them using their source numbers from the list above.` : ''}\n   155→\n   156→USER QUESTION: ${message}\n   157→\n   158→RESPONSE FORMAT:\n   159→1. Answer the question using information from the sources\n   160→2. Cite using ONLY [1], [2], etc. (up to [${sourceNames.length}])\n   161→3. At the very end, add this exact block with quotes from each source you cited:\n   162→\n   163→---CITATIONS---\n   164→[{\"number\": 1, \"quote\": \"the exact text you referenced from source 1\"}, {\"number\": 2, \"quote\": \"the exact text you referenced from source 2\"}]\n   165→\n   166→Begin your response:`\n   167→\n   168→    // Build content parts: text prompt first, then any file attachments\n   169→    const contentParts: Part[] = [{ text: prompt }, ...fileParts]\n   170→\n   171→    const result = await model.generateContent(contentParts)\n   172→    const response = result.response\n   173→    const text = response.text()\n   174→\n   175→    console.log('[CHAT] Raw response (last 500 chars):', text.slice(-500))\n   176→\n   177→    // Extract citations from the response\n   178→    const { cleanedContent, citations } = extractCitationsFromResponse(text, sourceNames)\n   179→\n   180→    console.log('[CHAT] Extracted citations:', JSON.stringify(citations, null, 2))\n   181→\n   182→    // Extract usage info\n   183→    const usageMetadata = response.usageMetadata\n   184→    const inputTokens = usageMetadata?.promptTokenCount || 0\n   185→    const outputTokens = usageMetadata?.candidatesTokenCount || 0\n   186→\n   187→    // Calculate cost (Gemini 2.0 Flash pricing)\n   188→    const inputCost = (inputTokens / 1_000_000) * 0.075\n   189→    const outputCost = (outputTokens / 1_000_000) * 0.30\n   190→    const totalCost = inputCost + outputCost\n   191→\n   192→    // If we got citations but no quotes, make a second call to extract quotes\n   193→    const hasTextSources = sourceInfos.some(s => s.content)\n   194→    if (citations.length > 0 && citations.every(c => !c.text) && (hasTextSources || fileParts.length > 0)) {\n   195→      try {\n   196→        // Build context for quote extraction including both text and PDF info\n   197→        const citationsList = citations.map(c => {\n   198→          const sourceInfo = sourceInfos.find(s => s.index === c.number)\n   199→          return `[${c.number}] ${c.source_name}${sourceInfo?.isPdf ? ' (PDF)' : ' (Text)'}`\n   200→        }).join('\\n')\n   201→\n   202→        // Include text content for better quote extraction\n   203→        const textContext = sourceInfos\n   204→          .filter(s => s.content && citations.some(c => c.number === s.index))\n   205→          .map(s => `[Source ${s.index}]: ${s.content?.slice(0, 2000)}`)\n   206→          .join('\\n\\n')\n   207→\n   208→        const quotesPrompt = `Extract the EXACT quotes that support each citation from the sources.\n   209→\n   210→CITATIONS USED:\n   211→${citationsList}\n   212→\n   213→RESPONSE THAT USED THESE CITATIONS:\n   214→\"${cleanedContent.slice(0, 1500)}\"\n   215→\n   216→${textContext ? `TEXT SOURCES:\\n${textContext}\\n\\n` : ''}${fileParts.length > 0 ? 'PDF documents are attached. Find the relevant passages from them.\\n\\n' : ''}\n   217→\n   218→IMPORTANT: For each citation number, extract 1-3 sentences that DIRECTLY support what was cited. These should be EXACT quotes from the documents.\n   219→\n   220→Return ONLY a valid JSON array (no other text):\n   221→[{\"number\": 1, \"quote\": \"The exact sentence from source 1\"}, {\"number\": 2, \"quote\": \"The exact sentence from source 2\"}]`\n   222→\n   223→        const quotesResult = await model.generateContent([{ text: quotesPrompt }, ...fileParts])\n   224→        const quotesText = quotesResult.response.text()\n   225→\n   226→        console.log('[CHAT] Quotes extraction response:', quotesText.slice(0, 500))\n   227→\n   228→        // Try to parse the JSON response - handle both array and wrapped formats\n   229→        const jsonMatch = quotesText.match(/\\[[\\s\\S]*?\\]/);\n   230→        if (jsonMatch) {\n   231→          const quotesJson = JSON.parse(jsonMatch[0]);\n   232→          for (const q of quotesJson) {\n   233→            const citation = citations.find(c => c.number === q.number);\n   234→            if (citation && q.quote) {\n   235→              citation.text = q.quote;\n   236→            }\n   237→          }\n   238→        }\n   239→      } catch (e) {\n   240→        console.log('[CHAT] Failed to extract quotes in second pass:', e);\n   241→      }\n   242→    }\n   243→\n   244→    return {\n   245→      content: cleanedContent,\n   246→      citations: citations.map(c => {\n   247→        const sourceInfo = sourceInfos.find(s => s.index === c.number)\n   248→        return {\n   249→          number: c.number,\n   250→          source_id: sourceInfo?.id || '',\n   251→          source_name: c.source_name,\n   252→          text: c.text,\n   253→          file_path: sourceInfo?.filePath || null,\n   254→          confidence: 0.9,\n   255→        }\n   256→      }),\n   257→      usage: {\n   258→        input_tokens: inputTokens,\n   259→        output_tokens: outputTokens,\n   260→        cost_usd: totalCost,\n   261→        model_used: 'gemini-2.0-flash-exp',\n   262→      }\n   263→    }\n   264→  } catch (error) {\n   265→    console.error('Gemini API error:', error)\n   266→    return generateDemoResponse(message, sourceContent, sourceNames)\n   267→  }\n   268→}\n   269→\n   270→// Demo response when Gemini is not configured\n   271→function generateDemoResponse(message: string, sourceContent: string[], sourceNames: string[]) {\n   272→  if (sourceContent.length === 0) {\n   273→    return {\n   274→      content: `I don't have any sources to reference. Please add some sources to your notebook and select them to get contextual answers.\\n\\nYour question was: \"${message}\"`,\n   275→      citations: [],\n   276→      usage: { input_tokens: 0, output_tokens: 0, cost_usd: 0, model_used: 'demo-mode' }\n   277→    }\n   278→  }\n   279→\n   280→  const context = sourceContent.slice(0, 3).map((c, i) => `[${i + 1}] ${c.slice(0, 200)}...`).join('\\n\\n')\n   281→\n   282→  return {\n   283→    content: `Based on your sources, here's what I found:\\n\\n${context}\\n\\n---\\n\\n**Note**: This is a demo response. To enable full AI-powered answers, add GOOGLE_API_KEY to your .env.local file.`,\n   284→    citations: sourceNames.map((name, i) => ({\n   285→      number: i + 1,\n   286→      source_id: '',\n   287→      source_name: name,\n   288→      text: sourceContent[i]?.slice(0, 100) || '',\n   289→      confidence: 0.8,\n   290→    })),\n   291→    usage: { input_tokens: 0, output_tokens: 0, cost_usd: 0, model_used: 'demo-mode' }\n   292→  }\n   293→}\n   294→\n   295→export async function POST(\n   296→  request: NextRequest,\n   297→  { params }: { params: Promise<{ id: string }> }\n   298→) {\n   299→  try {\n   300→    const { id: notebookId } = await params\n   301→    const body = await request.json()\n   302→    const { message, source_ids, session_id } = body\n   303→\n   304→    // Get auth header\n   305→    const authHeader = request.headers.get('authorization')\n   306→    if (!authHeader) {\n   307→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n   308→    }\n   309→\n   310→    // Verify user has access to notebook\n   311→    const token = authHeader.replace('Bearer ', '')\n   312→    const { data: { user } } = await supabase.auth.getUser(token)\n   313→\n   314→    if (!user) {\n   315→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n   316→    }\n   317→\n   318→    // Get notebook\n   319→    const { data: notebook } = await supabase\n   320→      .from('notebooks')\n   321→      .select('id')\n   322→      .eq('id', notebookId)\n   323→      .eq('user_id', user.id)\n   324→      .single()\n   325→\n   326→    if (!notebook) {\n   327→      return NextResponse.json({ error: 'Notebook not found' }, { status: 404 })\n   328→    }\n   329→\n   330→    // Get sources content - order by created_at DESC to match the sources panel display\n   331→    let query = supabase\n   332→      .from('sources')\n   333→      .select('*')\n   334→      .eq('notebook_id', notebookId)\n   335→      .eq('status', 'ready')\n   336→      .order('created_at', { ascending: false })\n   337→\n   338→    if (source_ids && source_ids.length > 0) {\n   339→      query = query.in('id', source_ids)\n   340→    }\n   341→\n   342→    const { data: sources } = await query\n   343→\n   344→    // Track sources with their index for proper citation mapping\n   345→    const sourceInfos: SourceInfo[] = []\n   346→    const fileParts: Part[] = []\n   347→\n   348→    for (let i = 0; i < (sources || []).length; i++) {\n   349→      const source = sources![i]\n   350→      const sourceInfo: SourceInfo = {\n   351→        index: i + 1, // 1-based index for citations\n   352→        id: source.id,\n   353→        name: source.name,\n   354→        filePath: source.file_path || undefined,\n   355→      }\n   356→\n   357→      // Handle text sources (pasted text)\n   358→      if (source.type === 'text' && source.metadata?.content) {\n   359→        sourceInfo.content = source.metadata.content\n   360→      }\n   361→      // Handle file sources (PDF, TXT, etc.)\n   362→      else if (source.file_path) {\n   363→        console.log(`[CHAT] Downloading file: ${source.file_path}`)\n   364→        const fileData = await downloadFileAsBase64(source.file_path)\n   365→        if (fileData) {\n   366→          // For text files, we can include as text content\n   367→          if (fileData.mimeType === 'text/plain' || fileData.mimeType === 'text/markdown') {\n   368→            const textContent = Buffer.from(fileData.data, 'base64').toString('utf-8')\n   369→            sourceInfo.content = textContent\n   370→          }\n   371→          // For PDFs and other binary files, add as file parts for Gemini\n   372→          else if (fileData.mimeType === 'application/pdf') {\n   373→            sourceInfo.isPdf = true\n   374→            fileParts.push({\n   375→              inlineData: {\n   376→                mimeType: fileData.mimeType,\n   377→                data: fileData.data\n   378→              }\n   379→            })\n   380→            console.log(`[CHAT] Added PDF as file part [${sourceInfo.index}]: ${source.name}`)\n   381→          }\n   382→        }\n   383→      }\n   384→      // Handle sources with summaries (fallback)\n   385→      else if (source.source_guide?.summary) {\n   386→        sourceInfo.content = source.source_guide.summary\n   387→      }\n   388→      // Handle URL/YouTube sources with metadata\n   389→      else if ((source.type === 'url' || source.type === 'youtube') && source.metadata?.url) {\n   390→        sourceInfo.content = `URL: ${source.metadata.url}`\n   391→      }\n   392→\n   393→      sourceInfos.push(sourceInfo)\n   394→    }\n   395→\n   396→    // Build arrays for the AI response generation\n   397→    const sourceNames = sourceInfos.map(s => s.name)\n   398→    const sourceContent = sourceInfos.filter(s => s.content).map(s => s.content!)\n   399→\n   400→    console.log(`[CHAT] Processed ${sources?.length || 0} sources: ${sourceInfos.filter(s => s.content).length} text, ${fileParts.length} files`)\n   401→\n   402→    // Get or create session\n   403→    let currentSessionId = session_id\n   404→    if (!currentSessionId) {\n   405→      const { data: session } = await supabase\n   406→        .from('chat_sessions')\n   407→        .insert({\n   408→          notebook_id: notebookId,\n   409→          title: message.slice(0, 50),\n   410→        })\n   411→        .select()\n   412→        .single()\n   413→      currentSessionId = session?.id\n   414→    }\n   415→\n   416→    // Save user message\n   417→    await supabase.from('chat_messages').insert({\n   418→      session_id: currentSessionId,\n   419→      role: 'user',\n   420→      content: message,\n   421→      source_ids_used: source_ids || [],\n   422→    })\n   423→\n   424→    // Generate AI response\n   425→    const response = await generateAIResponse(message, sourceInfos, fileParts)\n   426→\n   427→    // Save assistant message\n   428→    const { data: assistantMsg } = await supabase\n   429→      .from('chat_messages')\n   430→      .insert({\n   431→        session_id: currentSessionId,\n   432→        role: 'assistant',\n   433→        content: response.content,\n   434→        citations: response.citations,\n   435→        source_ids_used: source_ids || [],\n   436→        model_used: response.usage.model_used,\n   437→        input_tokens: response.usage.input_tokens,\n   438→        output_tokens: response.usage.output_tokens,\n   439→        cost_usd: response.usage.cost_usd,\n   440→      })\n   441→      .select()\n   442→      .single()\n   443→\n   444→    return NextResponse.json({\n   445→      data: {\n   446→        message_id: assistantMsg?.id,\n   447→        session_id: currentSessionId,\n   448→        content: response.content,\n   449→        citations: response.citations,\n   450→        suggested_questions: [\n   451→          'What are the main themes?',\n   452→          'Can you summarize this?',\n   453→          'What conclusions can we draw?',\n   454→        ],\n   455→      },\n   456→      usage: response.usage,\n   457→    })\n   458→  } catch (error) {\n   459→    console.error('Chat error:', error)\n   460→    return NextResponse.json(\n   461→      { error: 'Failed to process chat message' },\n   462→      { status: 500 }\n   463→    )\n   464→  }\n   465→}\n   466→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dd6572e2-3b96-4049-b2fd-c5df9a0b3960","timestamp":"2025-12-29T11:50:46.153Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/chat/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\nimport { GoogleGenerativeAI, Part } from '@google/generative-ai'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n)\n\nconst GOOGLE_API_KEY = process.env.GOOGLE_API_KEY\n\n// Download file from Supabase Storage and return as base64\nasync function downloadFileAsBase64(filePath: string): Promise<{ data: string; mimeType: string } | null> {\n  try {\n    const { data, error } = await supabase.storage\n      .from('sources')\n      .download(filePath)\n\n    if (error || !data) {\n      console.error('Failed to download file:', error)\n      return null\n    }\n\n    const buffer = await data.arrayBuffer()\n    const base64 = Buffer.from(buffer).toString('base64')\n\n    // Determine mime type from extension\n    const ext = filePath.split('.').pop()?.toLowerCase()\n    const mimeTypes: Record<string, string> = {\n      'pdf': 'application/pdf',\n      'txt': 'text/plain',\n      'md': 'text/markdown',\n      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    }\n\n    return {\n      data: base64,\n      mimeType: mimeTypes[ext || ''] || 'application/octet-stream'\n    }\n  } catch (error) {\n    console.error('Error downloading file:', error)\n    return null\n  }\n}\n\n// Parse citations from the AI response to extract quoted text\nfunction extractCitationsFromResponse(\n  responseText: string,\n  sourceNames: string[]\n): { cleanedContent: string; citations: Array<{ number: number; source_name: string; text: string }> } {\n  // Check if response has JSON citations block at the end\n  const jsonMatch = responseText.match(/\\n?---CITATIONS---\\n?([\\s\\S]*?)$/);\n\n  if (jsonMatch) {\n    try {\n      const citationsJson = JSON.parse(jsonMatch[1]);\n      const cleanedContent = responseText.replace(/\\n?---CITATIONS---\\n?[\\s\\S]*$/, '').trim();\n\n      return {\n        cleanedContent,\n        citations: citationsJson.map((c: { number: number; quote: string }) => ({\n          number: c.number,\n          source_name: sourceNames[c.number - 1] || `Source ${c.number}`,\n          text: c.quote || '',\n        })),\n      };\n    } catch {\n      // JSON parsing failed, fall through to regex extraction\n    }\n  }\n\n  // Fallback: Extract citations by finding patterns like [1], [2] and nearby quoted text\n  const citations: Array<{ number: number; source_name: string; text: string }> = [];\n  const citationNumbers = new Set<number>();\n\n  // Find all citation numbers used in the response\n  const citationMatches = responseText.matchAll(/\\[(\\d+)\\]/g);\n  for (const match of citationMatches) {\n    citationNumbers.add(parseInt(match[1]));\n  }\n\n  // Create citations for each unique number\n  for (const num of citationNumbers) {\n    citations.push({\n      number: num,\n      source_name: sourceNames[num - 1] || `Source ${num}`,\n      text: '', // Will be filled by second Gemini call if needed\n    });\n  }\n\n  // Sort by number\n  citations.sort((a, b) => a.number - b.number);\n\n  return {\n    cleanedContent: responseText,\n    citations,\n  };\n}\n\n// Source info type for tracking indices\ninterface SourceInfo {\n  index: number\n  id: string\n  name: string\n  content?: string\n  isPdf?: boolean\n  filePath?: string\n}\n\n// Generate AI response using Gemini with file support\nasync function generateAIResponse(\n  message: string,\n  sourceInfos: SourceInfo[],\n  fileParts: Part[] = []\n) {\n  const sourceNames = sourceInfos.map(s => s.name)\n  const sourceContent = sourceInfos.filter(s => s.content).map(s => s.content!)\n\n  if (!GOOGLE_API_KEY) {\n    return generateDemoResponse(message, sourceContent, sourceNames)\n  }\n\n  try {\n    const genAI = new GoogleGenerativeAI(GOOGLE_API_KEY)\n    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' })\n\n    // Build source list with correct indices\n    const sourceList = sourceInfos.map(s => `[${s.index}] ${s.name}`).join('\\n')\n\n    // Build context text with correct source indices (only for non-PDF sources)\n    const contextText = sourceInfos\n      .filter(s => s.content)\n      .map(s => `[Source ${s.index}: ${s.name}]\\n${s.content}`)\n      .join('\\n\\n---\\n\\n')\n\n    // Build PDF source list for clarity\n    const pdfSources = sourceInfos.filter(s => s.isPdf)\n    const pdfNote = pdfSources.length > 0\n      ? `\\nATTACHED PDF DOCUMENTS (cite using their numbers):\\n${pdfSources.map(s => `[${s.index}] = \"${s.name}\" (PDF attached below)`).join('\\n')}`\n      : ''\n\n    const prompt = `You are a helpful research assistant. Answer the user's question based ONLY on the provided sources.\n\nCRITICAL CITATION RULES:\n- You have exactly ${sourceInfos.length} source(s) numbered [1] through [${sourceInfos.length}]\n- ONLY use citation numbers [1] to [${sourceInfos.length}] - no other numbers!\n- Each citation MUST reference one of the sources listed below\n- When you cite information, use the source number like [1] or [2]\n\nYOUR SOURCES:\n${sourceInfos.map(s => `[${s.index}] = \"${s.name}\"${s.isPdf ? ' (PDF document)' : ''}`).join('\\n')}\n${pdfNote}\n${contextText ? `\\nTEXT SOURCE CONTENT:\\n${contextText}` : ''}\n${fileParts.length > 0 ? `\\nNote: PDF documents are attached below. Cite them using their source numbers from the list above.` : ''}\n\nUSER QUESTION: ${message}\n\nRESPONSE FORMAT:\n1. Answer the question using information from the sources\n2. Cite using ONLY [1], [2], etc. (up to [${sourceNames.length}])\n3. At the very end, add this exact block with quotes from each source you cited:\n\n---CITATIONS---\n[{\"number\": 1, \"quote\": \"the exact text you referenced from source 1\"}, {\"number\": 2, \"quote\": \"the exact text you referenced from source 2\"}]\n\nBegin your response:`\n\n    // Build content parts: text prompt first, then any file attachments\n    const contentParts: Part[] = [{ text: prompt }, ...fileParts]\n\n    const result = await model.generateContent(contentParts)\n    const response = result.response\n    const text = response.text()\n\n    console.log('[CHAT] Raw response (last 500 chars):', text.slice(-500))\n\n    // Extract citations from the response\n    const { cleanedContent, citations } = extractCitationsFromResponse(text, sourceNames)\n\n    console.log('[CHAT] Extracted citations:', JSON.stringify(citations, null, 2))\n\n    // Extract usage info\n    const usageMetadata = response.usageMetadata\n    const inputTokens = usageMetadata?.promptTokenCount || 0\n    const outputTokens = usageMetadata?.candidatesTokenCount || 0\n\n    // Calculate cost (Gemini 2.0 Flash pricing)\n    const inputCost = (inputTokens / 1_000_000) * 0.075\n    const outputCost = (outputTokens / 1_000_000) * 0.30\n    const totalCost = inputCost + outputCost\n\n    // If we got citations but no quotes, make a second call to extract quotes\n    const hasTextSources = sourceInfos.some(s => s.content)\n    if (citations.length > 0 && citations.every(c => !c.text) && (hasTextSources || fileParts.length > 0)) {\n      try {\n        // Build context for quote extraction including both text and PDF info\n        const citationsList = citations.map(c => {\n          const sourceInfo = sourceInfos.find(s => s.index === c.number)\n          return `[${c.number}] ${c.source_name}${sourceInfo?.isPdf ? ' (PDF)' : ' (Text)'}`\n        }).join('\\n')\n\n        // Include text content for better quote extraction\n        const textContext = sourceInfos\n          .filter(s => s.content && citations.some(c => c.number === s.index))\n          .map(s => `[Source ${s.index}]: ${s.content?.slice(0, 2000)}`)\n          .join('\\n\\n')\n\n        const quotesPrompt = `Extract the EXACT quotes that support each citation from the sources.\n\nCITATIONS USED:\n${citationsList}\n\nRESPONSE THAT USED THESE CITATIONS:\n\"${cleanedContent.slice(0, 1500)}\"\n\n${textContext ? `TEXT SOURCES:\\n${textContext}\\n\\n` : ''}${fileParts.length > 0 ? 'PDF documents are attached. Find the relevant passages from them.\\n\\n' : ''}\n\nIMPORTANT: For each citation number, extract 1-3 sentences that DIRECTLY support what was cited. These should be EXACT quotes from the documents.\n\nReturn ONLY a valid JSON array (no other text):\n[{\"number\": 1, \"quote\": \"The exact sentence from source 1\"}, {\"number\": 2, \"quote\": \"The exact sentence from source 2\"}]`\n\n        const quotesResult = await model.generateContent([{ text: quotesPrompt }, ...fileParts])\n        const quotesText = quotesResult.response.text()\n\n        console.log('[CHAT] Quotes extraction response:', quotesText.slice(0, 500))\n\n        // Try to parse the JSON response - handle both array and wrapped formats\n        const jsonMatch = quotesText.match(/\\[[\\s\\S]*?\\]/);\n        if (jsonMatch) {\n          const quotesJson = JSON.parse(jsonMatch[0]);\n          for (const q of quotesJson) {\n            const citation = citations.find(c => c.number === q.number);\n            if (citation && q.quote) {\n              citation.text = q.quote;\n            }\n          }\n        }\n      } catch (e) {\n        console.log('[CHAT] Failed to extract quotes in second pass:', e);\n      }\n    }\n\n    return {\n      content: cleanedContent,\n      citations: citations.map(c => {\n        const sourceInfo = sourceInfos.find(s => s.index === c.number)\n        return {\n          number: c.number,\n          source_id: sourceInfo?.id || '',\n          source_name: c.source_name,\n          text: c.text,\n          file_path: sourceInfo?.filePath || null,\n          confidence: 0.9,\n        }\n      }),\n      usage: {\n        input_tokens: inputTokens,\n        output_tokens: outputTokens,\n        cost_usd: totalCost,\n        model_used: 'gemini-2.0-flash-exp',\n      }\n    }\n  } catch (error) {\n    console.error('Gemini API error:', error)\n    return generateDemoResponse(message, sourceContent, sourceNames)\n  }\n}\n\n// Demo response when Gemini is not configured\nfunction generateDemoResponse(message: string, sourceContent: string[], sourceNames: string[]) {\n  if (sourceContent.length === 0) {\n    return {\n      content: `I don't have any sources to reference. Please add some sources to your notebook and select them to get contextual answers.\\n\\nYour question was: \"${message}\"`,\n      citations: [],\n      usage: { input_tokens: 0, output_tokens: 0, cost_usd: 0, model_used: 'demo-mode' }\n    }\n  }\n\n  const context = sourceContent.slice(0, 3).map((c, i) => `[${i + 1}] ${c.slice(0, 200)}...`).join('\\n\\n')\n\n  return {\n    content: `Based on your sources, here's what I found:\\n\\n${context}\\n\\n---\\n\\n**Note**: This is a demo response. To enable full AI-powered answers, add GOOGLE_API_KEY to your .env.local file.`,\n    citations: sourceNames.map((name, i) => ({\n      number: i + 1,\n      source_id: '',\n      source_name: name,\n      text: sourceContent[i]?.slice(0, 100) || '',\n      confidence: 0.8,\n    })),\n    usage: { input_tokens: 0, output_tokens: 0, cost_usd: 0, model_used: 'demo-mode' }\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const body = await request.json()\n    const { message, source_ids, session_id } = body\n\n    // Get auth header\n    const authHeader = request.headers.get('authorization')\n    if (!authHeader) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Verify user has access to notebook\n    const token = authHeader.replace('Bearer ', '')\n    const { data: { user } } = await supabase.auth.getUser(token)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Get notebook\n    const { data: notebook } = await supabase\n      .from('notebooks')\n      .select('id')\n      .eq('id', notebookId)\n      .eq('user_id', user.id)\n      .single()\n\n    if (!notebook) {\n      return NextResponse.json({ error: 'Notebook not found' }, { status: 404 })\n    }\n\n    // Get sources content - order by created_at DESC to match the sources panel display\n    let query = supabase\n      .from('sources')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('status', 'ready')\n      .order('created_at', { ascending: false })\n\n    if (source_ids && source_ids.length > 0) {\n      query = query.in('id', source_ids)\n    }\n\n    const { data: sources } = await query\n\n    // Track sources with their index for proper citation mapping\n    const sourceInfos: SourceInfo[] = []\n    const fileParts: Part[] = []\n\n    for (let i = 0; i < (sources || []).length; i++) {\n      const source = sources![i]\n      const sourceInfo: SourceInfo = {\n        index: i + 1, // 1-based index for citations\n        id: source.id,\n        name: source.name,\n        filePath: source.file_path || undefined,\n      }\n\n      // Handle text sources (pasted text)\n      if (source.type === 'text' && source.metadata?.content) {\n        sourceInfo.content = source.metadata.content\n      }\n      // Handle file sources (PDF, TXT, etc.)\n      else if (source.file_path) {\n        console.log(`[CHAT] Downloading file: ${source.file_path}`)\n        const fileData = await downloadFileAsBase64(source.file_path)\n        if (fileData) {\n          // For text files, we can include as text content\n          if (fileData.mimeType === 'text/plain' || fileData.mimeType === 'text/markdown') {\n            const textContent = Buffer.from(fileData.data, 'base64').toString('utf-8')\n            sourceInfo.content = textContent\n          }\n          // For PDFs and other binary files, add as file parts for Gemini\n          else if (fileData.mimeType === 'application/pdf') {\n            sourceInfo.isPdf = true\n            fileParts.push({\n              inlineData: {\n                mimeType: fileData.mimeType,\n                data: fileData.data\n              }\n            })\n            console.log(`[CHAT] Added PDF as file part [${sourceInfo.index}]: ${source.name}`)\n          }\n        }\n      }\n      // Handle sources with summaries (fallback)\n      else if (source.source_guide?.summary) {\n        sourceInfo.content = source.source_guide.summary\n      }\n      // Handle URL/YouTube sources with metadata\n      else if ((source.type === 'url' || source.type === 'youtube') && source.metadata?.url) {\n        sourceInfo.content = `URL: ${source.metadata.url}`\n      }\n\n      sourceInfos.push(sourceInfo)\n    }\n\n    // Build arrays for the AI response generation\n    const sourceNames = sourceInfos.map(s => s.name)\n    const sourceContent = sourceInfos.filter(s => s.content).map(s => s.content!)\n\n    console.log(`[CHAT] Processed ${sources?.length || 0} sources: ${sourceInfos.filter(s => s.content).length} text, ${fileParts.length} files`)\n\n    // Get or create session\n    let currentSessionId = session_id\n    if (!currentSessionId) {\n      const { data: session } = await supabase\n        .from('chat_sessions')\n        .insert({\n          notebook_id: notebookId,\n          title: message.slice(0, 50),\n        })\n        .select()\n        .single()\n      currentSessionId = session?.id\n    }\n\n    // Save user message\n    await supabase.from('chat_messages').insert({\n      session_id: currentSessionId,\n      role: 'user',\n      content: message,\n      source_ids_used: source_ids || [],\n    })\n\n    // Generate AI response\n    const response = await generateAIResponse(message, sourceInfos, fileParts)\n\n    // Save assistant message\n    const { data: assistantMsg } = await supabase\n      .from('chat_messages')\n      .insert({\n        session_id: currentSessionId,\n        role: 'assistant',\n        content: response.content,\n        citations: response.citations,\n        source_ids_used: source_ids || [],\n        model_used: response.usage.model_used,\n        input_tokens: response.usage.input_tokens,\n        output_tokens: response.usage.output_tokens,\n        cost_usd: response.usage.cost_usd,\n      })\n      .select()\n      .single()\n\n    return NextResponse.json({\n      data: {\n        message_id: assistantMsg?.id,\n        session_id: currentSessionId,\n        content: response.content,\n        citations: response.citations,\n        suggested_questions: [\n          'What are the main themes?',\n          'Can you summarize this?',\n          'What conclusions can we draw?',\n        ],\n      },\n      usage: response.usage,\n    })\n  } catch (error) {\n    console.error('Chat error:', error)\n    return NextResponse.json(\n      { error: 'Failed to process chat message' },\n      { status: 500 }\n    )\n  }\n}\n","numLines":466,"startLine":1,"totalLines":466}}}
{"parentUuid":"dd6572e2-3b96-4049-b2fd-c5df9a0b3960","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HTNddYhJYF6cxw9r3eNAo7","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→\n     4→const supabase = createClient(\n     5→  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     6→  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     7→)\n     8→\n     9→async function verifyAccess(request: NextRequest, notebookId: string) {\n    10→  const authHeader = request.headers.get('authorization')\n    11→  if (!authHeader) return null\n    12→\n    13→  const token = authHeader.replace('Bearer ', '')\n    14→  const { data: { user } } = await supabase.auth.getUser(token)\n    15→\n    16→  if (!user) return null\n    17→\n    18→  const { data: notebook } = await supabase\n    19→    .from('notebooks')\n    20→    .select('id')\n    21→    .eq('id', notebookId)\n    22→    .eq('user_id', user.id)\n    23→    .single()\n    24→\n    25→  if (!notebook) return null\n    26→\n    27→  return user\n    28→}\n    29→\n    30→export async function GET(\n    31→  request: NextRequest,\n    32→  { params }: { params: Promise<{ id: string }> }\n    33→) {\n    34→  try {\n    35→    const { id: notebookId } = await params\n    36→    const user = await verifyAccess(request, notebookId)\n    37→\n    38→    if (!user) {\n    39→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    40→    }\n    41→\n    42→    const { data: sources } = await supabase\n    43→      .from('sources')\n    44→      .select('*')\n    45→      .eq('notebook_id', notebookId)\n    46→      .order('created_at', { ascending: false })\n    47→\n    48→    return NextResponse.json({ data: sources || [] })\n    49→  } catch (error) {\n    50→    console.error('List sources error:', error)\n    51→    return NextResponse.json({ error: 'Failed to list sources' }, { status: 500 })\n    52→  }\n    53→}\n    54→\n    55→export async function POST(\n    56→  request: NextRequest,\n    57→  { params }: { params: Promise<{ id: string }> }\n    58→) {\n    59→  try {\n    60→    const { id: notebookId } = await params\n    61→    const user = await verifyAccess(request, notebookId)\n    62→\n    63→    if (!user) {\n    64→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    65→    }\n    66→\n    67→    const formData = await request.formData()\n    68→    const type = formData.get('type') as string\n    69→\n    70→    if (type === 'text') {\n    71→      const name = formData.get('name') as string\n    72→      const content = formData.get('content') as string\n    73→\n    74→      const { data: source, error } = await supabase\n    75→        .from('sources')\n    76→        .insert({\n    77→          notebook_id: notebookId,\n    78→          type: 'text',\n    79→          name: name || 'Pasted Text',\n    80→          status: 'ready',\n    81→          metadata: { content: content?.slice(0, 100000) },\n    82→        })\n    83→        .select()\n    84→        .single()\n    85→\n    86→      if (error) {\n    87→        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n    88→      }\n    89→\n    90→      return NextResponse.json({ data: source })\n    91→    }\n    92→\n    93→    if (type === 'url') {\n    94→      const url = formData.get('url') as string\n    95→      const name = formData.get('name') as string\n    96→\n    97→      const { data: source, error } = await supabase\n    98→        .from('sources')\n    99→        .insert({\n   100→          notebook_id: notebookId,\n   101→          type: 'url',\n   102→          name: name || url?.slice(0, 100),\n   103→          status: 'ready',\n   104→          metadata: { url },\n   105→        })\n   106→        .select()\n   107→        .single()\n   108→\n   109→      if (error) {\n   110→        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n   111→      }\n   112→\n   113→      return NextResponse.json({ data: source })\n   114→    }\n   115→\n   116→    if (type === 'youtube') {\n   117→      const url = formData.get('url') as string\n   118→      const name = formData.get('name') as string\n   119→\n   120→      let videoId = null\n   121→      if (url.includes('youtube.com/watch?v=')) {\n   122→        videoId = url.split('v=')[1]?.split('&')[0]\n   123→      } else if (url.includes('youtu.be/')) {\n   124→        videoId = url.split('youtu.be/')[1]?.split('?')[0]\n   125→      }\n   126→\n   127→      const { data: source, error } = await supabase\n   128→        .from('sources')\n   129→        .insert({\n   130→          notebook_id: notebookId,\n   131→          type: 'youtube',\n   132→          name: name || `YouTube: ${videoId || url}`,\n   133→          status: 'ready',\n   134→          metadata: { url, video_id: videoId },\n   135→        })\n   136→        .select()\n   137→        .single()\n   138→\n   139→      if (error) {\n   140→        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n   141→      }\n   142→\n   143→      return NextResponse.json({ data: source })\n   144→    }\n   145→\n   146→    // File upload\n   147→    const file = formData.get('file') as File\n   148→    if (!file) {\n   149→      return NextResponse.json({ error: 'No file provided' }, { status: 400 })\n   150→    }\n   151→\n   152→    const buffer = Buffer.from(await file.arrayBuffer())\n   153→    const filename = file.name\n   154→    const ext = filename.split('.').pop()?.toLowerCase() || 'txt'\n   155→    const storagePath = `${user.id}/${notebookId}/${Date.now()}_${filename}`\n   156→\n   157→    const { error: uploadError } = await supabase.storage\n   158→      .from('sources')\n   159→      .upload(storagePath, buffer, {\n   160→        contentType: file.type || 'application/octet-stream',\n   161→      })\n   162→\n   163→    if (uploadError) {\n   164→      return NextResponse.json({ error: 'Failed to upload file' }, { status: 400 })\n   165→    }\n   166→\n   167→    const typeMap: Record<string, string> = {\n   168→      pdf: 'pdf',\n   169→      docx: 'docx',\n   170→      doc: 'docx',\n   171→      txt: 'txt',\n   172→      md: 'txt',\n   173→    }\n   174→\n   175→    const { data: source, error } = await supabase\n   176→      .from('sources')\n   177→      .insert({\n   178→        notebook_id: notebookId,\n   179→        type: typeMap[ext] || 'txt',\n   180→        name: filename,\n   181→        status: 'ready',\n   182→        file_path: storagePath,\n   183→        original_filename: filename,\n   184→        mime_type: file.type,\n   185→        file_size_bytes: buffer.length,\n   186→      })\n   187→      .select()\n   188→      .single()\n   189→\n   190→    if (error) {\n   191→      return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n   192→    }\n   193→\n   194→    return NextResponse.json({ data: source })\n   195→  } catch (error) {\n   196→    console.error('Create source error:', error)\n   197→    return NextResponse.json({ error: 'Failed to create source' }, { status: 500 })\n   198→  }\n   199→}\n   200→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a1b85e1f-e946-41ff-a0be-de6b9ad42121","timestamp":"2025-12-29T11:50:46.153Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/sources/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n)\n\nasync function verifyAccess(request: NextRequest, notebookId: string) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader) return null\n\n  const token = authHeader.replace('Bearer ', '')\n  const { data: { user } } = await supabase.auth.getUser(token)\n\n  if (!user) return null\n\n  const { data: notebook } = await supabase\n    .from('notebooks')\n    .select('id')\n    .eq('id', notebookId)\n    .eq('user_id', user.id)\n    .single()\n\n  if (!notebook) return null\n\n  return user\n}\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { data: sources } = await supabase\n      .from('sources')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: false })\n\n    return NextResponse.json({ data: sources || [] })\n  } catch (error) {\n    console.error('List sources error:', error)\n    return NextResponse.json({ error: 'Failed to list sources' }, { status: 500 })\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const formData = await request.formData()\n    const type = formData.get('type') as string\n\n    if (type === 'text') {\n      const name = formData.get('name') as string\n      const content = formData.get('content') as string\n\n      const { data: source, error } = await supabase\n        .from('sources')\n        .insert({\n          notebook_id: notebookId,\n          type: 'text',\n          name: name || 'Pasted Text',\n          status: 'ready',\n          metadata: { content: content?.slice(0, 100000) },\n        })\n        .select()\n        .single()\n\n      if (error) {\n        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n      }\n\n      return NextResponse.json({ data: source })\n    }\n\n    if (type === 'url') {\n      const url = formData.get('url') as string\n      const name = formData.get('name') as string\n\n      const { data: source, error } = await supabase\n        .from('sources')\n        .insert({\n          notebook_id: notebookId,\n          type: 'url',\n          name: name || url?.slice(0, 100),\n          status: 'ready',\n          metadata: { url },\n        })\n        .select()\n        .single()\n\n      if (error) {\n        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n      }\n\n      return NextResponse.json({ data: source })\n    }\n\n    if (type === 'youtube') {\n      const url = formData.get('url') as string\n      const name = formData.get('name') as string\n\n      let videoId = null\n      if (url.includes('youtube.com/watch?v=')) {\n        videoId = url.split('v=')[1]?.split('&')[0]\n      } else if (url.includes('youtu.be/')) {\n        videoId = url.split('youtu.be/')[1]?.split('?')[0]\n      }\n\n      const { data: source, error } = await supabase\n        .from('sources')\n        .insert({\n          notebook_id: notebookId,\n          type: 'youtube',\n          name: name || `YouTube: ${videoId || url}`,\n          status: 'ready',\n          metadata: { url, video_id: videoId },\n        })\n        .select()\n        .single()\n\n      if (error) {\n        return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n      }\n\n      return NextResponse.json({ data: source })\n    }\n\n    // File upload\n    const file = formData.get('file') as File\n    if (!file) {\n      return NextResponse.json({ error: 'No file provided' }, { status: 400 })\n    }\n\n    const buffer = Buffer.from(await file.arrayBuffer())\n    const filename = file.name\n    const ext = filename.split('.').pop()?.toLowerCase() || 'txt'\n    const storagePath = `${user.id}/${notebookId}/${Date.now()}_${filename}`\n\n    const { error: uploadError } = await supabase.storage\n      .from('sources')\n      .upload(storagePath, buffer, {\n        contentType: file.type || 'application/octet-stream',\n      })\n\n    if (uploadError) {\n      return NextResponse.json({ error: 'Failed to upload file' }, { status: 400 })\n    }\n\n    const typeMap: Record<string, string> = {\n      pdf: 'pdf',\n      docx: 'docx',\n      doc: 'docx',\n      txt: 'txt',\n      md: 'txt',\n    }\n\n    const { data: source, error } = await supabase\n      .from('sources')\n      .insert({\n        notebook_id: notebookId,\n        type: typeMap[ext] || 'txt',\n        name: filename,\n        status: 'ready',\n        file_path: storagePath,\n        original_filename: filename,\n        mime_type: file.type,\n        file_size_bytes: buffer.length,\n      })\n      .select()\n      .single()\n\n    if (error) {\n      return NextResponse.json({ error: 'Failed to create source' }, { status: 400 })\n    }\n\n    return NextResponse.json({ data: source })\n  } catch (error) {\n    console.error('Create source error:', error)\n    return NextResponse.json({ error: 'Failed to create source' }, { status: 500 })\n  }\n}\n","numLines":200,"startLine":1,"totalLines":200}}}
{"parentUuid":"a1b85e1f-e946-41ff-a0be-de6b9ad42121","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014btLBhjhFF47D9QofQm6Vj","type":"tool_result","content":"     1→import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai'\n     2→\n     3→// Initialize Gemini with API key\n     4→const apiKey = process.env.GOOGLE_API_KEY\n     5→\n     6→if (!apiKey) {\n     7→  console.warn('GOOGLE_API_KEY is not set. Gemini features will not work.')\n     8→}\n     9→\n    10→const genAI = apiKey ? new GoogleGenerativeAI(apiKey) : null\n    11→\n    12→// Models for different use cases\n    13→export function getFlashModel(): GenerativeModel | null {\n    14→  if (!genAI) return null\n    15→  return genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' })\n    16→}\n    17→\n    18→export function getProModel(): GenerativeModel | null {\n    19→  if (!genAI) return null\n    20→  return genAI.getGenerativeModel({ model: 'gemini-2.5-pro' })\n    21→}\n    22→\n    23→// Generate flashcards from source content\n    24→export async function generateFlashcards(\n    25→  content: string,\n    26→  count: number = 10\n    27→): Promise<{ front: string; back: string }[]> {\n    28→  const model = getFlashModel()\n    29→  if (!model) throw new Error('Gemini API not configured')\n    30→\n    31→  const prompt = `You are an expert educator. Based on the following content, create ${count} high-quality flashcards for studying.\n    32→\n    33→CONTENT:\n    34→${content}\n    35→\n    36→Generate exactly ${count} flashcards. Each flashcard should:\n    37→- Have a clear, specific question on the front\n    38→- Have a comprehensive but concise answer on the back\n    39→- Cover key concepts, definitions, facts, and important details\n    40→- Be useful for active recall learning\n    41→\n    42→Return ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n    43→[\n    44→  {\"front\": \"Question 1?\", \"back\": \"Answer 1\"},\n    45→  {\"front\": \"Question 2?\", \"back\": \"Answer 2\"}\n    46→]`\n    47→\n    48→  const result = await model.generateContent(prompt)\n    49→  const text = result.response.text()\n    50→\n    51→  // Parse JSON from response (handle potential markdown code blocks)\n    52→  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n    53→  if (!jsonMatch) throw new Error('Invalid response format')\n    54→\n    55→  return JSON.parse(jsonMatch[0])\n    56→}\n    57→\n    58→// Generate quiz questions from source content\n    59→export async function generateQuiz(\n    60→  content: string,\n    61→  count: number = 5\n    62→): Promise<{ question: string; options: string[]; correct_index: number; explanation: string }[]> {\n    63→  const model = getFlashModel()\n    64→  if (!model) throw new Error('Gemini API not configured')\n    65→\n    66→  const prompt = `You are an expert educator. Based on the following content, create ${count} multiple-choice quiz questions.\n    67→\n    68→CONTENT:\n    69→${content}\n    70→\n    71→Generate exactly ${count} quiz questions. Each question should:\n    72→- Test understanding of key concepts from the content\n    73→- Have 4 plausible options (A, B, C, D)\n    74→- Have exactly one correct answer\n    75→- Include a brief explanation of why the correct answer is right\n    76→\n    77→Return ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n    78→[\n    79→  {\n    80→    \"question\": \"Question text?\",\n    81→    \"options\": [\"Option A\", \"Option B\", \"Option C\", \"Option D\"],\n    82→    \"correct_index\": 0,\n    83→    \"explanation\": \"Explanation of why this is correct\"\n    84→  }\n    85→]`\n    86→\n    87→  const result = await model.generateContent(prompt)\n    88→  const text = result.response.text()\n    89→\n    90→  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n    91→  if (!jsonMatch) throw new Error('Invalid response format')\n    92→\n    93→  return JSON.parse(jsonMatch[0])\n    94→}\n    95→\n    96→// Generate study guide from source content\n    97→export async function generateStudyGuide(\n    98→  content: string\n    99→): Promise<{ title: string; sections: { heading: string; content: string }[] }> {\n   100→  const model = getFlashModel()\n   101→  if (!model) throw new Error('Gemini API not configured')\n   102→\n   103→  const prompt = `You are an expert educator. Based on the following content, create a comprehensive study guide.\n   104→\n   105→CONTENT:\n   106→${content}\n   107→\n   108→Create a well-structured study guide with:\n   109→- A clear, descriptive title\n   110→- Multiple sections covering all major topics\n   111→- Each section should have a heading and detailed content\n   112→- Include key concepts, definitions, examples, and important points\n   113→- Use bullet points and clear formatting within the content\n   114→\n   115→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   116→{\n   117→  \"title\": \"Study Guide Title\",\n   118→  \"sections\": [\n   119→    {\"heading\": \"Section 1 Title\", \"content\": \"Section 1 content with key points...\"},\n   120→    {\"heading\": \"Section 2 Title\", \"content\": \"Section 2 content...\"}\n   121→  ]\n   122→}`\n   123→\n   124→  const result = await model.generateContent(prompt)\n   125→  const text = result.response.text()\n   126→\n   127→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   128→  if (!jsonMatch) throw new Error('Invalid response format')\n   129→\n   130→  return JSON.parse(jsonMatch[0])\n   131→}\n   132→\n   133→// Generate FAQ from source content\n   134→export async function generateFAQ(\n   135→  content: string,\n   136→  count: number = 8\n   137→): Promise<{ question: string; answer: string }[]> {\n   138→  const model = getFlashModel()\n   139→  if (!model) throw new Error('Gemini API not configured')\n   140→\n   141→  const prompt = `You are an expert educator. Based on the following content, create ${count} frequently asked questions and answers.\n   142→\n   143→CONTENT:\n   144→${content}\n   145→\n   146→Generate ${count} FAQs that:\n   147→- Address common questions someone studying this material might have\n   148→- Cover key concepts and potential points of confusion\n   149→- Have clear, comprehensive answers\n   150→- Range from basic to more advanced questions\n   151→\n   152→Return ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n   153→[\n   154→  {\"question\": \"FAQ question 1?\", \"answer\": \"Comprehensive answer 1\"},\n   155→  {\"question\": \"FAQ question 2?\", \"answer\": \"Comprehensive answer 2\"}\n   156→]`\n   157→\n   158→  const result = await model.generateContent(prompt)\n   159→  const text = result.response.text()\n   160→\n   161→  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n   162→  if (!jsonMatch) throw new Error('Invalid response format')\n   163→\n   164→  return JSON.parse(jsonMatch[0])\n   165→}\n   166→\n   167→// Mind map node structure\n   168→export interface MindMapNode {\n   169→  id: string\n   170→  label: string\n   171→  description?: string\n   172→  children?: MindMapNode[]\n   173→}\n   174→\n   175→// Generate mind map from source content\n   176→export async function generateMindMap(\n   177→  content: string\n   178→): Promise<{ title: string; nodes: MindMapNode[] }> {\n   179→  const model = getFlashModel()\n   180→  if (!model) throw new Error('Gemini API not configured')\n   181→\n   182→  const prompt = `You are an expert at creating visual knowledge maps. Based on the following content, create a hierarchical mind map structure.\n   183→\n   184→CONTENT:\n   185→${content}\n   186→\n   187→Create a mind map with:\n   188→- A central topic/theme as the root\n   189→- 4-6 main branches (key concepts/themes)\n   190→- Each main branch should have 2-4 sub-branches (supporting details)\n   191→- Keep labels concise (2-5 words max)\n   192→- Add brief descriptions where helpful (1 sentence max)\n   193→\n   194→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   195→{\n   196→  \"title\": \"Central Topic\",\n   197→  \"nodes\": [\n   198→    {\n   199→      \"id\": \"1\",\n   200→      \"label\": \"Main Concept 1\",\n   201→      \"description\": \"Brief description\",\n   202→      \"children\": [\n   203→        {\"id\": \"1-1\", \"label\": \"Sub-concept\", \"description\": \"Detail\"},\n   204→        {\"id\": \"1-2\", \"label\": \"Sub-concept 2\"}\n   205→      ]\n   206→    },\n   207→    {\n   208→      \"id\": \"2\",\n   209→      \"label\": \"Main Concept 2\",\n   210→      \"children\": [\n   211→        {\"id\": \"2-1\", \"label\": \"Sub-concept\"}\n   212→      ]\n   213→    }\n   214→  ]\n   215→}`\n   216→\n   217→  const result = await model.generateContent(prompt)\n   218→  const text = result.response.text()\n   219→\n   220→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   221→  if (!jsonMatch) throw new Error('Invalid response format')\n   222→\n   223→  return JSON.parse(jsonMatch[0])\n   224→}\n   225→\n   226→// Generate audio script for podcast-style overview with two speakers\n   227→export async function generateAudioScript(\n   228→  content: string,\n   229→  format: 'deep_dive' | 'brief' | 'critique' | 'debate' = 'deep_dive'\n   230→): Promise<string> {\n   231→  const model = getProModel() || getFlashModel()\n   232→  if (!model) throw new Error('Gemini API not configured')\n   233→\n   234→  const durationGuide: Record<string, string> = {\n   235→    deep_dive: '10-15 minutes when read aloud',\n   236→    brief: '3-5 minutes when read aloud',\n   237→    critique: '8-10 minutes when read aloud',\n   238→    debate: '10-12 minutes when read aloud'\n   239→  }\n   240→\n   241→  const prompt = `You are an expert podcast scriptwriter creating a NotebookLM-style audio overview. Create an engaging two-person podcast conversation about the following content.\n   242→\n   243→CONTENT TO DISCUSS:\n   244→${content}\n   245→\n   246→REQUIREMENTS:\n   247→1. Write a ${format.replace('_', ' ')} style podcast (${durationGuide[format]})\n   248→2. Format as a natural conversation between exactly TWO speakers named \"Alex\" and \"Sam\"\n   249→3. Use EXACTLY this format for each line - speaker name followed by colon:\n   250→   Alex: [dialogue]\n   251→   Sam: [dialogue]\n   252→4. Make it sound like two friends having an engaging, informative conversation\n   253→5. Include natural reactions like \"That's fascinating!\", \"Right, exactly!\", \"Oh interesting...\"\n   254→6. Alex should be the main explainer, Sam asks good questions and adds insights\n   255→7. Start with a brief intro, cover the key points, end with a summary\n   256→8. Keep it conversational and accessible - avoid being too academic\n   257→9. Include smooth transitions between topics\n   258→\n   259→${format === 'critique' ? 'Focus on analyzing strengths and weaknesses of the content.' : ''}\n   260→${format === 'debate' ? 'Have Alex and Sam take slightly different perspectives and discuss them respectfully.' : ''}\n   261→\n   262→Write ONLY the dialogue, no stage directions or extra formatting. Start directly with \"Alex:\" on the first line.`\n   263→\n   264→  const result = await model.generateContent(prompt)\n   265→  return result.response.text()\n   266→}\n   267→\n   268→// Generate video script\n   269→export async function generateVideoScript(\n   270→  content: string,\n   271→  style: 'documentary' | 'explainer' | 'presentation' = 'explainer'\n   272→): Promise<string> {\n   273→  const model = getProModel() || getFlashModel()\n   274→  if (!model) throw new Error('Gemini API not configured')\n   275→\n   276→  const styleInstructions: Record<string, string> = {\n   277→    documentary: `Create a documentary-style video script (5-8 minutes).\n   278→Include:\n   279→- Scene descriptions with visual suggestions\n   280→- Narration text\n   281→- B-roll suggestions\n   282→- Interview-style segments if appropriate\n   283→- Atmospheric/emotional beats`,\n   284→\n   285→    explainer: `Create an explainer video script (3-5 minutes).\n   286→Include:\n   287→- Clear scene breakdowns\n   288→- On-screen text suggestions\n   289→- Visual diagram/animation descriptions\n   290→- Step-by-step explanations\n   291→- Call-to-action ending`,\n   292→\n   293→    presentation: `Create a presentation-style video script (5-7 minutes).\n   294→Include:\n   295→- Slide suggestions with bullet points\n   296→- Speaker notes for each section\n   297→- Transition suggestions\n   298→- Visual aid descriptions\n   299→- Q&A prompts at the end`\n   300→  }\n   301→\n   302→  const prompt = `You are an expert video scriptwriter. Based on the following content, create a ${style} video script.\n   303→\n   304→CONTENT:\n   305→${content}\n   306→\n   307→${styleInstructions[style]}\n   308→\n   309→Format the script with clear scene markers like [SCENE 1], [SCENE 2], etc.\n   310→Include [VISUAL] tags for visual suggestions and [NARRATION] tags for spoken content.\n   311→\n   312→Do NOT include any JSON formatting. Write the script as plain text with clear markers.`\n   313→\n   314→  const result = await model.generateContent(prompt)\n   315→  return result.response.text()\n   316→}\n   317→\n   318→// Generate research report\n   319→export async function generateResearchReport(\n   320→  query: string,\n   321→  mode: 'fast' | 'deep' = 'fast'\n   322→): Promise<{\n   323→  report_content: string\n   324→  sources_found_count: number\n   325→  sources_analyzed_count: number\n   326→  citations: { title: string; url: string }[]\n   327→}> {\n   328→  const model = mode === 'deep' ? getProModel() : getFlashModel()\n   329→  if (!model) throw new Error('Gemini API not configured')\n   330→\n   331→  const prompt = `You are an expert researcher. Conduct ${mode === 'deep' ? 'comprehensive' : 'focused'} research on the following query:\n   332→\n   333→QUERY: ${query}\n   334→\n   335→${mode === 'deep'\n   336→  ? 'Provide a thorough, well-researched report with multiple perspectives, detailed analysis, and comprehensive coverage of the topic.'\n   337→  : 'Provide a focused, concise research report covering the key aspects of the query.'}\n   338→\n   339→Structure your report with:\n   340→# Research Report: [Topic]\n   341→\n   342→## Executive Summary\n   343→Brief overview of findings\n   344→\n   345→## Background\n   346→Context and background information\n   347→\n   348→## Key Findings\n   349→Main discoveries and insights (use numbered points)\n   350→\n   351→## Analysis\n   352→Deeper examination of the findings\n   353→\n   354→## Conclusion\n   355→Summary and implications\n   356→\n   357→## References\n   358→List sources you would cite (note: as an AI, provide hypothetical but realistic sources)\n   359→\n   360→Write in an academic but accessible style. Be thorough and evidence-based.`\n   361→\n   362→  const result = await model.generateContent(prompt)\n   363→  const reportContent = result.response.text()\n   364→\n   365→  // Generate hypothetical but realistic citations based on the query\n   366→  const citationPrompt = `For a research report about \"${query}\", generate 5 realistic academic/web citations. Return ONLY a JSON array:\n   367→[{\"title\": \"Article Title\", \"url\": \"https://example.com/article\"}]`\n   368→\n   369→  let citations: { title: string; url: string }[] = []\n   370→  try {\n   371→    const citationResult = await model.generateContent(citationPrompt)\n   372→    const citationText = citationResult.response.text()\n   373→    const jsonMatch = citationText.match(/\\[[\\s\\S]*\\]/)\n   374→    if (jsonMatch) {\n   375→      citations = JSON.parse(jsonMatch[0])\n   376→    }\n   377→  } catch {\n   378→    // If citation generation fails, use empty array\n   379→    citations = []\n   380→  }\n   381→\n   382→  return {\n   383→    report_content: reportContent,\n   384→    sources_found_count: Math.floor(Math.random() * 10) + 15,\n   385→    sources_analyzed_count: Math.floor(Math.random() * 5) + 8,\n   386→    citations\n   387→  }\n   388→}\n   389→\n   390→// Check if Gemini is configured\n   391→export function isGeminiConfigured(): boolean {\n   392→  return !!apiKey\n   393→}\n   394→\n   395→// ============ STUDIO OUTPUT GENERATORS ============\n   396→\n   397→// Data table structure\n   398→export interface TableColumn {\n   399→  header: string\n   400→  key: string\n   401→  type: 'text' | 'number' | 'date' | 'boolean'\n   402→}\n   403→\n   404→export interface DataTableData {\n   405→  title: string\n   406→  description: string\n   407→  columns: TableColumn[]\n   408→  rows: Record<string, string | number | boolean>[]\n   409→}\n   410→\n   411→// Generate data table from source content\n   412→export async function generateDataTable(\n   413→  content: string,\n   414→  customInstructions?: string\n   415→): Promise<DataTableData> {\n   416→  const model = getFlashModel()\n   417→  if (!model) throw new Error('Gemini API not configured')\n   418→\n   419→  const prompt = `You are an expert data analyst. Based on the following content, extract and structure the key information into a data table format.\n   420→\n   421→CONTENT:\n   422→${content}\n   423→\n   424→${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n   425→\n   426→Create a well-structured data table that:\n   427→- Has a clear, descriptive title\n   428→- Includes 3-7 relevant columns based on the content\n   429→- Contains 5-15 rows of extracted data\n   430→- Uses appropriate column types (text, number, date, boolean)\n   431→- Captures the most important information from the sources\n   432→\n   433→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   434→{\n   435→  \"title\": \"Table Title\",\n   436→  \"description\": \"Brief description of what this table shows\",\n   437→  \"columns\": [\n   438→    {\"header\": \"Column Name\", \"key\": \"column_key\", \"type\": \"text\"},\n   439→    {\"header\": \"Value\", \"key\": \"value\", \"type\": \"number\"}\n   440→  ],\n   441→  \"rows\": [\n   442→    {\"column_key\": \"Value 1\", \"value\": 100},\n   443→    {\"column_key\": \"Value 2\", \"value\": 200}\n   444→  ]\n   445→}`\n   446→\n   447→  const result = await model.generateContent(prompt)\n   448→  const text = result.response.text()\n   449→\n   450→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   451→  if (!jsonMatch) throw new Error('Invalid response format')\n   452→\n   453→  return JSON.parse(jsonMatch[0])\n   454→}\n   455→\n   456→// Report structure\n   457→export interface ReportSection {\n   458→  heading: string\n   459→  content: string\n   460→  subsections?: { subheading: string; content: string }[]\n   461→}\n   462→\n   463→export interface ReportData {\n   464→  title: string\n   465→  executive_summary: string\n   466→  sections: ReportSection[]\n   467→  key_takeaways: string[]\n   468→  references?: string[]\n   469→}\n   470→\n   471→// Generate report from source content\n   472→export async function generateReport(\n   473→  content: string,\n   474→  reportType: 'briefing_doc' | 'study_guide' | 'blog_post' | 'custom' = 'briefing_doc',\n   475→  customInstructions?: string\n   476→): Promise<ReportData> {\n   477→  const model = getProModel() || getFlashModel()\n   478→  if (!model) throw new Error('Gemini API not configured')\n   479→\n   480→  const reportTypeInstructions: Record<string, string> = {\n   481→    briefing_doc: `Create a professional briefing document:\n   482→- Executive summary with key insights\n   483→- Well-organized sections with clear headings\n   484→- Bullet points for key facts\n   485→- Formal, concise writing style\n   486→- Action items or recommendations if applicable`,\n   487→\n   488→    study_guide: `Create a comprehensive study guide:\n   489→- Overview of the topic\n   490→- Key concepts and definitions\n   491→- Important details organized by topic\n   492→- Practice questions or review points\n   493→- Summary of main takeaways`,\n   494→\n   495→    blog_post: `Create an engaging blog post:\n   496→- Catchy introduction that hooks the reader\n   497→- Conversational but informative tone\n   498→- Clear sections with engaging headings\n   499→- Examples and analogies to explain concepts\n   500→- Strong conclusion with call-to-action`,\n   501→\n   502→    custom: customInstructions || 'Create a comprehensive report covering the main points.'\n   503→  }\n   504→\n   505→  const prompt = `You are an expert writer. Based on the following content, create a ${reportType.replace('_', ' ')}.\n   506→\n   507→CONTENT:\n   508→${content}\n   509→\n   510→${reportTypeInstructions[reportType]}\n   511→\n   512→${customInstructions && reportType !== 'custom' ? `ADDITIONAL INSTRUCTIONS: ${customInstructions}` : ''}\n   513→\n   514→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   515→{\n   516→  \"title\": \"Report Title\",\n   517→  \"executive_summary\": \"A brief executive summary...\",\n   518→  \"sections\": [\n   519→    {\n   520→      \"heading\": \"Section 1 Title\",\n   521→      \"content\": \"Section content with full markdown formatting...\",\n   522→      \"subsections\": [\n   523→        {\"subheading\": \"Subsection Title\", \"content\": \"Subsection content...\"}\n   524→      ]\n   525→    }\n   526→  ],\n   527→  \"key_takeaways\": [\"Takeaway 1\", \"Takeaway 2\", \"Takeaway 3\"],\n   528→  \"references\": [\"Source 1\", \"Source 2\"]\n   529→}`\n   530→\n   531→  const result = await model.generateContent(prompt)\n   532→  const text = result.response.text()\n   533→\n   534→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   535→  if (!jsonMatch) throw new Error('Invalid response format')\n   536→\n   537→  return JSON.parse(jsonMatch[0])\n   538→}\n   539→\n   540→// Slide structure\n   541→export interface Slide {\n   542→  slide_number: number\n   543→  title: string\n   544→  content_type: 'title' | 'content' | 'bullets' | 'image_placeholder' | 'comparison' | 'summary'\n   545→  main_content: string\n   546→  bullet_points?: string[]\n   547→  speaker_notes?: string\n   548→  visual_suggestion?: string\n   549→}\n   550→\n   551→export interface SlideDeckData {\n   552→  title: string\n   553→  subtitle?: string\n   554→  slides: Slide[]\n   555→  theme_suggestion: string\n   556→}\n   557→\n   558→// Generate slide deck from source content\n   559→export async function generateSlideDeck(\n   560→  content: string,\n   561→  customInstructions?: string\n   562→): Promise<SlideDeckData> {\n   563→  const model = getProModel() || getFlashModel()\n   564→  if (!model) throw new Error('Gemini API not configured')\n   565→\n   566→  const prompt = `You are an expert presentation designer. Based on the following content, create a professional slide deck structure.\n   567→\n   568→CONTENT:\n   569→${content}\n   570→\n   571→${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n   572→\n   573→Create a presentation with:\n   574→- 8-15 slides total\n   575→- Title slide with subtitle\n   576→- Content slides with clear hierarchy\n   577→- Bullet points (3-5 per slide max)\n   578→- Visual suggestions for key slides\n   579→- Speaker notes for each slide\n   580→- Summary/conclusion slide\n   581→\n   582→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   583→{\n   584→  \"title\": \"Presentation Title\",\n   585→  \"subtitle\": \"Subtitle or Tagline\",\n   586→  \"slides\": [\n   587→    {\n   588→      \"slide_number\": 1,\n   589→      \"title\": \"Presentation Title\",\n   590→      \"content_type\": \"title\",\n   591→      \"main_content\": \"Subtitle text\",\n   592→      \"speaker_notes\": \"Welcome everyone...\",\n   593→      \"visual_suggestion\": \"Company logo, professional background\"\n   594→    },\n   595→    {\n   596→      \"slide_number\": 2,\n   597→      \"title\": \"Overview\",\n   598→      \"content_type\": \"bullets\",\n   599→      \"main_content\": \"What we'll cover today\",\n   600→      \"bullet_points\": [\"Point 1\", \"Point 2\", \"Point 3\"],\n   601→      \"speaker_notes\": \"Here's what we'll discuss...\",\n   602→      \"visual_suggestion\": \"Agenda icons or timeline graphic\"\n   603→    }\n   604→  ],\n   605→  \"theme_suggestion\": \"Professional blue theme with clean typography\"\n   606→}`\n   607→\n   608→  const result = await model.generateContent(prompt)\n   609→  const text = result.response.text()\n   610→\n   611→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   612→  if (!jsonMatch) throw new Error('Invalid response format')\n   613→\n   614→  return JSON.parse(jsonMatch[0])\n   615→}\n   616→\n   617→// Infographic structure\n   618→export interface InfographicSection {\n   619→  section_type: 'header' | 'stats' | 'timeline' | 'comparison' | 'process' | 'list' | 'quote' | 'footer'\n   620→  title?: string\n   621→  content: Record<string, unknown>\n   622→}\n   623→\n   624→export interface InfographicData {\n   625→  title: string\n   626→  subtitle?: string\n   627→  color_scheme: string[]\n   628→  sections: InfographicSection[]\n   629→  style_suggestion: string\n   630→}\n   631→\n   632→// Generate infographic structure from source content\n   633→// Note: This generates the data structure. Actual image generation will use Nano Banana API\n   634→export async function generateInfographic(\n   635→  content: string,\n   636→  customInstructions?: string\n   637→): Promise<InfographicData> {\n   638→  const model = getFlashModel()\n   639→  if (!model) throw new Error('Gemini API not configured')\n   640→\n   641→  const prompt = `You are an expert infographic designer. Based on the following content, create a detailed infographic structure that can be rendered visually.\n   642→\n   643→CONTENT:\n   644→${content}\n   645→\n   646→${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n   647→\n   648→Create an infographic structure with:\n   649→- Engaging title and subtitle\n   650→- 4-8 distinct sections\n   651→- Mix of section types: stats, timeline, comparison, process, list, quote\n   652→- Color scheme suggestion (4-5 hex colors)\n   653→- Clear visual hierarchy\n   654→\n   655→Return ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n   656→{\n   657→  \"title\": \"Infographic Title\",\n   658→  \"subtitle\": \"A brief subtitle\",\n   659→  \"color_scheme\": [\"#1a73e8\", \"#34a853\", \"#fbbc04\", \"#ea4335\", \"#ffffff\"],\n   660→  \"sections\": [\n   661→    {\n   662→      \"section_type\": \"header\",\n   663→      \"title\": \"Main Title\",\n   664→      \"content\": {\"subtitle\": \"Subtitle text\", \"background_style\": \"gradient\"}\n   665→    },\n   666→    {\n   667→      \"section_type\": \"stats\",\n   668→      \"title\": \"Key Statistics\",\n   669→      \"content\": {\n   670→        \"items\": [\n   671→          {\"value\": \"85%\", \"label\": \"Success Rate\", \"icon\": \"chart-up\"},\n   672→          {\"value\": \"1M+\", \"label\": \"Users\", \"icon\": \"users\"},\n   673→          {\"value\": \"50+\", \"label\": \"Countries\", \"icon\": \"globe\"}\n   674→        ]\n   675→      }\n   676→    },\n   677→    {\n   678→      \"section_type\": \"timeline\",\n   679→      \"title\": \"Timeline\",\n   680→      \"content\": {\n   681→        \"events\": [\n   682→          {\"date\": \"2020\", \"title\": \"Event 1\", \"description\": \"What happened\"},\n   683→          {\"date\": \"2022\", \"title\": \"Event 2\", \"description\": \"Another milestone\"}\n   684→        ]\n   685→      }\n   686→    },\n   687→    {\n   688→      \"section_type\": \"comparison\",\n   689→      \"title\": \"Comparison\",\n   690→      \"content\": {\n   691→        \"left\": {\"label\": \"Option A\", \"points\": [\"Point 1\", \"Point 2\"]},\n   692→        \"right\": {\"label\": \"Option B\", \"points\": [\"Point 1\", \"Point 2\"]}\n   693→      }\n   694→    },\n   695→    {\n   696→      \"section_type\": \"process\",\n   697→      \"title\": \"Process Flow\",\n   698→      \"content\": {\n   699→        \"steps\": [\n   700→          {\"step\": 1, \"title\": \"Step 1\", \"description\": \"First step\"},\n   701→          {\"step\": 2, \"title\": \"Step 2\", \"description\": \"Second step\"}\n   702→        ]\n   703→      }\n   704→    },\n   705→    {\n   706→      \"section_type\": \"list\",\n   707→      \"title\": \"Key Points\",\n   708→      \"content\": {\n   709→        \"items\": [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"]\n   710→      }\n   711→    },\n   712→    {\n   713→      \"section_type\": \"footer\",\n   714→      \"content\": {\"text\": \"Source: Your Sources\", \"logo_placeholder\": true}\n   715→    }\n   716→  ],\n   717→  \"style_suggestion\": \"Modern, clean design with bold icons and clear typography\"\n   718→}`\n   719→\n   720→  const result = await model.generateContent(prompt)\n   721→  const text = result.response.text()\n   722→\n   723→  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n   724→  if (!jsonMatch) throw new Error('Invalid response format')\n   725→\n   726→  return JSON.parse(jsonMatch[0])\n   727→}\n   728→\n   729→// Convert raw PCM audio data to WAV format\n   730→// PCM from Gemini TTS is 16-bit mono at 24000Hz\n   731→export function pcmToWav(pcmData: Buffer, sampleRate: number = 24000): Buffer {\n   732→  const numChannels = 1  // Mono\n   733→  const bitsPerSample = 16\n   734→  const byteRate = sampleRate * numChannels * (bitsPerSample / 8)\n   735→  const blockAlign = numChannels * (bitsPerSample / 8)\n   736→  const dataSize = pcmData.length\n   737→  const headerSize = 44\n   738→\n   739→  const wavBuffer = Buffer.alloc(headerSize + dataSize)\n   740→\n   741→  // RIFF header\n   742→  wavBuffer.write('RIFF', 0)\n   743→  wavBuffer.writeUInt32LE(36 + dataSize, 4)  // File size - 8\n   744→  wavBuffer.write('WAVE', 8)\n   745→\n   746→  // fmt chunk\n   747→  wavBuffer.write('fmt ', 12)\n   748→  wavBuffer.writeUInt32LE(16, 16)  // Chunk size\n   749→  wavBuffer.writeUInt16LE(1, 20)   // Audio format (1 = PCM)\n   750→  wavBuffer.writeUInt16LE(numChannels, 22)\n   751→  wavBuffer.writeUInt32LE(sampleRate, 24)\n   752→  wavBuffer.writeUInt32LE(byteRate, 28)\n   753→  wavBuffer.writeUInt16LE(blockAlign, 32)\n   754→  wavBuffer.writeUInt16LE(bitsPerSample, 34)\n   755→\n   756→  // data chunk\n   757→  wavBuffer.write('data', 36)\n   758→  wavBuffer.writeUInt32LE(dataSize, 40)\n   759→\n   760→  // Copy PCM data\n   761→  pcmData.copy(wavBuffer, headerSize)\n   762→\n   763→  return wavBuffer\n   764→}\n   765→\n   766→// Generate multi-speaker TTS audio from podcast script using Gemini TTS\n   767→export async function generateTTSAudio(\n   768→  script: string,\n   769→  voiceConfig: { voice1?: string; voice2?: string } = {}\n   770→): Promise<{ audioData: string; mimeType: string }> {\n   771→  if (!apiKey) throw new Error('Gemini API not configured')\n   772→\n   773→  // Voice options: Kore (firm), Puck (upbeat), Charon (informative), Fenrir (excitable),\n   774→  // Leda (youthful), Orus (firm), Aoede (breezy), Zephyr (bright)\n   775→  const voice1 = voiceConfig.voice1 || 'Orus'   // Alex - deeper, authoritative\n   776→  const voice2 = voiceConfig.voice2 || 'Aoede'  // Sam - lighter, curious\n   777→\n   778→  // Use Gemini 2.5 Flash Preview TTS for multi-speaker support\n   779→  const response = await fetch(\n   780→    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,\n   781→    {\n   782→      method: 'POST',\n   783→      headers: { 'Content-Type': 'application/json' },\n   784→      body: JSON.stringify({\n   785→        contents: [{\n   786→          parts: [{\n   787→            text: script\n   788→          }]\n   789→        }],\n   790→        generationConfig: {\n   791→          responseModalities: ['AUDIO'],\n   792→          speechConfig: {\n   793→            multiSpeakerVoiceConfig: {\n   794→              speakerVoiceConfigs: [\n   795→                {\n   796→                  speaker: 'Alex',\n   797→                  voiceConfig: {\n   798→                    prebuiltVoiceConfig: {\n   799→                      voiceName: voice1\n   800→                    }\n   801→                  }\n   802→                },\n   803→                {\n   804→                  speaker: 'Sam',\n   805→                  voiceConfig: {\n   806→                    prebuiltVoiceConfig: {\n   807→                      voiceName: voice2\n   808→                    }\n   809→                  }\n   810→                }\n   811→              ]\n   812→            }\n   813→          }\n   814→        }\n   815→      })\n   816→    }\n   817→  )\n   818→\n   819→  if (!response.ok) {\n   820→    const error = await response.text()\n   821→    console.error('TTS API error:', error)\n   822→    throw new Error(`TTS generation failed: ${response.status}`)\n   823→  }\n   824→\n   825→  const data = await response.json()\n   826→\n   827→  // Extract audio data from response\n   828→  const audioPart = data.candidates?.[0]?.content?.parts?.find(\n   829→    (part: { inlineData?: { mimeType: string; data: string } }) => part.inlineData?.mimeType?.startsWith('audio/')\n   830→  )\n   831→\n   832→  if (!audioPart?.inlineData) {\n   833→    throw new Error('No audio data in response')\n   834→  }\n   835→\n   836→  return {\n   837→    audioData: audioPart.inlineData.data,\n   838→    mimeType: audioPart.inlineData.mimeType\n   839→  }\n   840→}\n   841→\n   842→// Generate video using Veo\n   843→export async function generateVideo(\n   844→  prompt: string,\n   845→  durationSeconds: number = 8\n   846→): Promise<{ videoData: string; mimeType: string } | { operationName: string }> {\n   847→  if (!apiKey) throw new Error('Gemini API not configured')\n   848→\n   849→  // Veo video generation - start async operation\n   850→  const response = await fetch(\n   851→    `https://generativelanguage.googleapis.com/v1beta/models/veo-2.0-generate-001:predictLongRunning?key=${apiKey}`,\n   852→    {\n   853→      method: 'POST',\n   854→      headers: { 'Content-Type': 'application/json' },\n   855→      body: JSON.stringify({\n   856→        instances: [{\n   857→          prompt: prompt\n   858→        }],\n   859→        parameters: {\n   860→          aspectRatio: '16:9',\n   861→          durationSeconds: Math.min(durationSeconds, 8), // Veo max is 8 seconds per clip\n   862→          personGeneration: 'dont_allow',\n   863→          sampleCount: 1\n   864→        }\n   865→      })\n   866→    }\n   867→  )\n   868→\n   869→  if (!response.ok) {\n   870→    const error = await response.text()\n   871→    console.error('Veo API error:', error)\n   872→    throw new Error(`Video generation failed: ${response.status}`)\n   873→  }\n   874→\n   875→  const data = await response.json()\n   876→\n   877→  // Veo returns an operation name for long-running generation\n   878→  if (data.name) {\n   879→    return { operationName: data.name }\n   880→  }\n   881→\n   882→  // If immediate result (unlikely for video)\n   883→  const videoPart = data.predictions?.[0]\n   884→  if (videoPart?.bytesBase64Encoded) {\n   885→    return {\n   886→      videoData: videoPart.bytesBase64Encoded,\n   887→      mimeType: 'video/mp4'\n   888→    }\n   889→  }\n   890→\n   891→  throw new Error('Unexpected video generation response')\n   892→}\n   893→\n   894→// Check video generation operation status\n   895→export async function checkVideoOperation(\n   896→  operationName: string\n   897→): Promise<{ done: boolean; videoUrl?: string; error?: string }> {\n   898→  if (!apiKey) throw new Error('Gemini API not configured')\n   899→\n   900→  const response = await fetch(\n   901→    `https://generativelanguage.googleapis.com/v1beta/${operationName}?key=${apiKey}`,\n   902→    {\n   903→      method: 'GET',\n   904→      headers: { 'Content-Type': 'application/json' }\n   905→    }\n   906→  )\n   907→\n   908→  if (!response.ok) {\n   909→    const error = await response.text()\n   910→    throw new Error(`Operation check failed: ${error}`)\n   911→  }\n   912→\n   913→  const data = await response.json()\n   914→\n   915→  if (data.done) {\n   916→    if (data.error) {\n   917→      return { done: true, error: data.error.message }\n   918→    }\n   919→\n   920→    const videoUri = data.response?.generatedSamples?.[0]?.video?.uri\n   921→    return { done: true, videoUrl: videoUri }\n   922→  }\n   923→\n   924→  return { done: false }\n   925→}\n   926→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dfb7a646-ec98-4af4-8ef9-d41bee34bc2f","timestamp":"2025-12-29T11:50:46.434Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/lib/gemini.ts","content":"import { GoogleGenerativeAI, GenerativeModel } from '@google/generative-ai'\n\n// Initialize Gemini with API key\nconst apiKey = process.env.GOOGLE_API_KEY\n\nif (!apiKey) {\n  console.warn('GOOGLE_API_KEY is not set. Gemini features will not work.')\n}\n\nconst genAI = apiKey ? new GoogleGenerativeAI(apiKey) : null\n\n// Models for different use cases\nexport function getFlashModel(): GenerativeModel | null {\n  if (!genAI) return null\n  return genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' })\n}\n\nexport function getProModel(): GenerativeModel | null {\n  if (!genAI) return null\n  return genAI.getGenerativeModel({ model: 'gemini-2.5-pro' })\n}\n\n// Generate flashcards from source content\nexport async function generateFlashcards(\n  content: string,\n  count: number = 10\n): Promise<{ front: string; back: string }[]> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert educator. Based on the following content, create ${count} high-quality flashcards for studying.\n\nCONTENT:\n${content}\n\nGenerate exactly ${count} flashcards. Each flashcard should:\n- Have a clear, specific question on the front\n- Have a comprehensive but concise answer on the back\n- Cover key concepts, definitions, facts, and important details\n- Be useful for active recall learning\n\nReturn ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n[\n  {\"front\": \"Question 1?\", \"back\": \"Answer 1\"},\n  {\"front\": \"Question 2?\", \"back\": \"Answer 2\"}\n]`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  // Parse JSON from response (handle potential markdown code blocks)\n  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Generate quiz questions from source content\nexport async function generateQuiz(\n  content: string,\n  count: number = 5\n): Promise<{ question: string; options: string[]; correct_index: number; explanation: string }[]> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert educator. Based on the following content, create ${count} multiple-choice quiz questions.\n\nCONTENT:\n${content}\n\nGenerate exactly ${count} quiz questions. Each question should:\n- Test understanding of key concepts from the content\n- Have 4 plausible options (A, B, C, D)\n- Have exactly one correct answer\n- Include a brief explanation of why the correct answer is right\n\nReturn ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n[\n  {\n    \"question\": \"Question text?\",\n    \"options\": [\"Option A\", \"Option B\", \"Option C\", \"Option D\"],\n    \"correct_index\": 0,\n    \"explanation\": \"Explanation of why this is correct\"\n  }\n]`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Generate study guide from source content\nexport async function generateStudyGuide(\n  content: string\n): Promise<{ title: string; sections: { heading: string; content: string }[] }> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert educator. Based on the following content, create a comprehensive study guide.\n\nCONTENT:\n${content}\n\nCreate a well-structured study guide with:\n- A clear, descriptive title\n- Multiple sections covering all major topics\n- Each section should have a heading and detailed content\n- Include key concepts, definitions, examples, and important points\n- Use bullet points and clear formatting within the content\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Study Guide Title\",\n  \"sections\": [\n    {\"heading\": \"Section 1 Title\", \"content\": \"Section 1 content with key points...\"},\n    {\"heading\": \"Section 2 Title\", \"content\": \"Section 2 content...\"}\n  ]\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Generate FAQ from source content\nexport async function generateFAQ(\n  content: string,\n  count: number = 8\n): Promise<{ question: string; answer: string }[]> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert educator. Based on the following content, create ${count} frequently asked questions and answers.\n\nCONTENT:\n${content}\n\nGenerate ${count} FAQs that:\n- Address common questions someone studying this material might have\n- Cover key concepts and potential points of confusion\n- Have clear, comprehensive answers\n- Range from basic to more advanced questions\n\nReturn ONLY a valid JSON array with no markdown formatting, code blocks, or extra text. Format:\n[\n  {\"question\": \"FAQ question 1?\", \"answer\": \"Comprehensive answer 1\"},\n  {\"question\": \"FAQ question 2?\", \"answer\": \"Comprehensive answer 2\"}\n]`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\[[\\s\\S]*\\]/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Mind map node structure\nexport interface MindMapNode {\n  id: string\n  label: string\n  description?: string\n  children?: MindMapNode[]\n}\n\n// Generate mind map from source content\nexport async function generateMindMap(\n  content: string\n): Promise<{ title: string; nodes: MindMapNode[] }> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert at creating visual knowledge maps. Based on the following content, create a hierarchical mind map structure.\n\nCONTENT:\n${content}\n\nCreate a mind map with:\n- A central topic/theme as the root\n- 4-6 main branches (key concepts/themes)\n- Each main branch should have 2-4 sub-branches (supporting details)\n- Keep labels concise (2-5 words max)\n- Add brief descriptions where helpful (1 sentence max)\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Central Topic\",\n  \"nodes\": [\n    {\n      \"id\": \"1\",\n      \"label\": \"Main Concept 1\",\n      \"description\": \"Brief description\",\n      \"children\": [\n        {\"id\": \"1-1\", \"label\": \"Sub-concept\", \"description\": \"Detail\"},\n        {\"id\": \"1-2\", \"label\": \"Sub-concept 2\"}\n      ]\n    },\n    {\n      \"id\": \"2\",\n      \"label\": \"Main Concept 2\",\n      \"children\": [\n        {\"id\": \"2-1\", \"label\": \"Sub-concept\"}\n      ]\n    }\n  ]\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Generate audio script for podcast-style overview with two speakers\nexport async function generateAudioScript(\n  content: string,\n  format: 'deep_dive' | 'brief' | 'critique' | 'debate' = 'deep_dive'\n): Promise<string> {\n  const model = getProModel() || getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const durationGuide: Record<string, string> = {\n    deep_dive: '10-15 minutes when read aloud',\n    brief: '3-5 minutes when read aloud',\n    critique: '8-10 minutes when read aloud',\n    debate: '10-12 minutes when read aloud'\n  }\n\n  const prompt = `You are an expert podcast scriptwriter creating a NotebookLM-style audio overview. Create an engaging two-person podcast conversation about the following content.\n\nCONTENT TO DISCUSS:\n${content}\n\nREQUIREMENTS:\n1. Write a ${format.replace('_', ' ')} style podcast (${durationGuide[format]})\n2. Format as a natural conversation between exactly TWO speakers named \"Alex\" and \"Sam\"\n3. Use EXACTLY this format for each line - speaker name followed by colon:\n   Alex: [dialogue]\n   Sam: [dialogue]\n4. Make it sound like two friends having an engaging, informative conversation\n5. Include natural reactions like \"That's fascinating!\", \"Right, exactly!\", \"Oh interesting...\"\n6. Alex should be the main explainer, Sam asks good questions and adds insights\n7. Start with a brief intro, cover the key points, end with a summary\n8. Keep it conversational and accessible - avoid being too academic\n9. Include smooth transitions between topics\n\n${format === 'critique' ? 'Focus on analyzing strengths and weaknesses of the content.' : ''}\n${format === 'debate' ? 'Have Alex and Sam take slightly different perspectives and discuss them respectfully.' : ''}\n\nWrite ONLY the dialogue, no stage directions or extra formatting. Start directly with \"Alex:\" on the first line.`\n\n  const result = await model.generateContent(prompt)\n  return result.response.text()\n}\n\n// Generate video script\nexport async function generateVideoScript(\n  content: string,\n  style: 'documentary' | 'explainer' | 'presentation' = 'explainer'\n): Promise<string> {\n  const model = getProModel() || getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const styleInstructions: Record<string, string> = {\n    documentary: `Create a documentary-style video script (5-8 minutes).\nInclude:\n- Scene descriptions with visual suggestions\n- Narration text\n- B-roll suggestions\n- Interview-style segments if appropriate\n- Atmospheric/emotional beats`,\n\n    explainer: `Create an explainer video script (3-5 minutes).\nInclude:\n- Clear scene breakdowns\n- On-screen text suggestions\n- Visual diagram/animation descriptions\n- Step-by-step explanations\n- Call-to-action ending`,\n\n    presentation: `Create a presentation-style video script (5-7 minutes).\nInclude:\n- Slide suggestions with bullet points\n- Speaker notes for each section\n- Transition suggestions\n- Visual aid descriptions\n- Q&A prompts at the end`\n  }\n\n  const prompt = `You are an expert video scriptwriter. Based on the following content, create a ${style} video script.\n\nCONTENT:\n${content}\n\n${styleInstructions[style]}\n\nFormat the script with clear scene markers like [SCENE 1], [SCENE 2], etc.\nInclude [VISUAL] tags for visual suggestions and [NARRATION] tags for spoken content.\n\nDo NOT include any JSON formatting. Write the script as plain text with clear markers.`\n\n  const result = await model.generateContent(prompt)\n  return result.response.text()\n}\n\n// Generate research report\nexport async function generateResearchReport(\n  query: string,\n  mode: 'fast' | 'deep' = 'fast'\n): Promise<{\n  report_content: string\n  sources_found_count: number\n  sources_analyzed_count: number\n  citations: { title: string; url: string }[]\n}> {\n  const model = mode === 'deep' ? getProModel() : getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert researcher. Conduct ${mode === 'deep' ? 'comprehensive' : 'focused'} research on the following query:\n\nQUERY: ${query}\n\n${mode === 'deep'\n  ? 'Provide a thorough, well-researched report with multiple perspectives, detailed analysis, and comprehensive coverage of the topic.'\n  : 'Provide a focused, concise research report covering the key aspects of the query.'}\n\nStructure your report with:\n# Research Report: [Topic]\n\n## Executive Summary\nBrief overview of findings\n\n## Background\nContext and background information\n\n## Key Findings\nMain discoveries and insights (use numbered points)\n\n## Analysis\nDeeper examination of the findings\n\n## Conclusion\nSummary and implications\n\n## References\nList sources you would cite (note: as an AI, provide hypothetical but realistic sources)\n\nWrite in an academic but accessible style. Be thorough and evidence-based.`\n\n  const result = await model.generateContent(prompt)\n  const reportContent = result.response.text()\n\n  // Generate hypothetical but realistic citations based on the query\n  const citationPrompt = `For a research report about \"${query}\", generate 5 realistic academic/web citations. Return ONLY a JSON array:\n[{\"title\": \"Article Title\", \"url\": \"https://example.com/article\"}]`\n\n  let citations: { title: string; url: string }[] = []\n  try {\n    const citationResult = await model.generateContent(citationPrompt)\n    const citationText = citationResult.response.text()\n    const jsonMatch = citationText.match(/\\[[\\s\\S]*\\]/)\n    if (jsonMatch) {\n      citations = JSON.parse(jsonMatch[0])\n    }\n  } catch {\n    // If citation generation fails, use empty array\n    citations = []\n  }\n\n  return {\n    report_content: reportContent,\n    sources_found_count: Math.floor(Math.random() * 10) + 15,\n    sources_analyzed_count: Math.floor(Math.random() * 5) + 8,\n    citations\n  }\n}\n\n// Check if Gemini is configured\nexport function isGeminiConfigured(): boolean {\n  return !!apiKey\n}\n\n// ============ STUDIO OUTPUT GENERATORS ============\n\n// Data table structure\nexport interface TableColumn {\n  header: string\n  key: string\n  type: 'text' | 'number' | 'date' | 'boolean'\n}\n\nexport interface DataTableData {\n  title: string\n  description: string\n  columns: TableColumn[]\n  rows: Record<string, string | number | boolean>[]\n}\n\n// Generate data table from source content\nexport async function generateDataTable(\n  content: string,\n  customInstructions?: string\n): Promise<DataTableData> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert data analyst. Based on the following content, extract and structure the key information into a data table format.\n\nCONTENT:\n${content}\n\n${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n\nCreate a well-structured data table that:\n- Has a clear, descriptive title\n- Includes 3-7 relevant columns based on the content\n- Contains 5-15 rows of extracted data\n- Uses appropriate column types (text, number, date, boolean)\n- Captures the most important information from the sources\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Table Title\",\n  \"description\": \"Brief description of what this table shows\",\n  \"columns\": [\n    {\"header\": \"Column Name\", \"key\": \"column_key\", \"type\": \"text\"},\n    {\"header\": \"Value\", \"key\": \"value\", \"type\": \"number\"}\n  ],\n  \"rows\": [\n    {\"column_key\": \"Value 1\", \"value\": 100},\n    {\"column_key\": \"Value 2\", \"value\": 200}\n  ]\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Report structure\nexport interface ReportSection {\n  heading: string\n  content: string\n  subsections?: { subheading: string; content: string }[]\n}\n\nexport interface ReportData {\n  title: string\n  executive_summary: string\n  sections: ReportSection[]\n  key_takeaways: string[]\n  references?: string[]\n}\n\n// Generate report from source content\nexport async function generateReport(\n  content: string,\n  reportType: 'briefing_doc' | 'study_guide' | 'blog_post' | 'custom' = 'briefing_doc',\n  customInstructions?: string\n): Promise<ReportData> {\n  const model = getProModel() || getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const reportTypeInstructions: Record<string, string> = {\n    briefing_doc: `Create a professional briefing document:\n- Executive summary with key insights\n- Well-organized sections with clear headings\n- Bullet points for key facts\n- Formal, concise writing style\n- Action items or recommendations if applicable`,\n\n    study_guide: `Create a comprehensive study guide:\n- Overview of the topic\n- Key concepts and definitions\n- Important details organized by topic\n- Practice questions or review points\n- Summary of main takeaways`,\n\n    blog_post: `Create an engaging blog post:\n- Catchy introduction that hooks the reader\n- Conversational but informative tone\n- Clear sections with engaging headings\n- Examples and analogies to explain concepts\n- Strong conclusion with call-to-action`,\n\n    custom: customInstructions || 'Create a comprehensive report covering the main points.'\n  }\n\n  const prompt = `You are an expert writer. Based on the following content, create a ${reportType.replace('_', ' ')}.\n\nCONTENT:\n${content}\n\n${reportTypeInstructions[reportType]}\n\n${customInstructions && reportType !== 'custom' ? `ADDITIONAL INSTRUCTIONS: ${customInstructions}` : ''}\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Report Title\",\n  \"executive_summary\": \"A brief executive summary...\",\n  \"sections\": [\n    {\n      \"heading\": \"Section 1 Title\",\n      \"content\": \"Section content with full markdown formatting...\",\n      \"subsections\": [\n        {\"subheading\": \"Subsection Title\", \"content\": \"Subsection content...\"}\n      ]\n    }\n  ],\n  \"key_takeaways\": [\"Takeaway 1\", \"Takeaway 2\", \"Takeaway 3\"],\n  \"references\": [\"Source 1\", \"Source 2\"]\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Slide structure\nexport interface Slide {\n  slide_number: number\n  title: string\n  content_type: 'title' | 'content' | 'bullets' | 'image_placeholder' | 'comparison' | 'summary'\n  main_content: string\n  bullet_points?: string[]\n  speaker_notes?: string\n  visual_suggestion?: string\n}\n\nexport interface SlideDeckData {\n  title: string\n  subtitle?: string\n  slides: Slide[]\n  theme_suggestion: string\n}\n\n// Generate slide deck from source content\nexport async function generateSlideDeck(\n  content: string,\n  customInstructions?: string\n): Promise<SlideDeckData> {\n  const model = getProModel() || getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert presentation designer. Based on the following content, create a professional slide deck structure.\n\nCONTENT:\n${content}\n\n${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n\nCreate a presentation with:\n- 8-15 slides total\n- Title slide with subtitle\n- Content slides with clear hierarchy\n- Bullet points (3-5 per slide max)\n- Visual suggestions for key slides\n- Speaker notes for each slide\n- Summary/conclusion slide\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Presentation Title\",\n  \"subtitle\": \"Subtitle or Tagline\",\n  \"slides\": [\n    {\n      \"slide_number\": 1,\n      \"title\": \"Presentation Title\",\n      \"content_type\": \"title\",\n      \"main_content\": \"Subtitle text\",\n      \"speaker_notes\": \"Welcome everyone...\",\n      \"visual_suggestion\": \"Company logo, professional background\"\n    },\n    {\n      \"slide_number\": 2,\n      \"title\": \"Overview\",\n      \"content_type\": \"bullets\",\n      \"main_content\": \"What we'll cover today\",\n      \"bullet_points\": [\"Point 1\", \"Point 2\", \"Point 3\"],\n      \"speaker_notes\": \"Here's what we'll discuss...\",\n      \"visual_suggestion\": \"Agenda icons or timeline graphic\"\n    }\n  ],\n  \"theme_suggestion\": \"Professional blue theme with clean typography\"\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Infographic structure\nexport interface InfographicSection {\n  section_type: 'header' | 'stats' | 'timeline' | 'comparison' | 'process' | 'list' | 'quote' | 'footer'\n  title?: string\n  content: Record<string, unknown>\n}\n\nexport interface InfographicData {\n  title: string\n  subtitle?: string\n  color_scheme: string[]\n  sections: InfographicSection[]\n  style_suggestion: string\n}\n\n// Generate infographic structure from source content\n// Note: This generates the data structure. Actual image generation will use Nano Banana API\nexport async function generateInfographic(\n  content: string,\n  customInstructions?: string\n): Promise<InfographicData> {\n  const model = getFlashModel()\n  if (!model) throw new Error('Gemini API not configured')\n\n  const prompt = `You are an expert infographic designer. Based on the following content, create a detailed infographic structure that can be rendered visually.\n\nCONTENT:\n${content}\n\n${customInstructions ? `CUSTOM INSTRUCTIONS: ${customInstructions}` : ''}\n\nCreate an infographic structure with:\n- Engaging title and subtitle\n- 4-8 distinct sections\n- Mix of section types: stats, timeline, comparison, process, list, quote\n- Color scheme suggestion (4-5 hex colors)\n- Clear visual hierarchy\n\nReturn ONLY a valid JSON object with no markdown formatting, code blocks, or extra text. Format:\n{\n  \"title\": \"Infographic Title\",\n  \"subtitle\": \"A brief subtitle\",\n  \"color_scheme\": [\"#1a73e8\", \"#34a853\", \"#fbbc04\", \"#ea4335\", \"#ffffff\"],\n  \"sections\": [\n    {\n      \"section_type\": \"header\",\n      \"title\": \"Main Title\",\n      \"content\": {\"subtitle\": \"Subtitle text\", \"background_style\": \"gradient\"}\n    },\n    {\n      \"section_type\": \"stats\",\n      \"title\": \"Key Statistics\",\n      \"content\": {\n        \"items\": [\n          {\"value\": \"85%\", \"label\": \"Success Rate\", \"icon\": \"chart-up\"},\n          {\"value\": \"1M+\", \"label\": \"Users\", \"icon\": \"users\"},\n          {\"value\": \"50+\", \"label\": \"Countries\", \"icon\": \"globe\"}\n        ]\n      }\n    },\n    {\n      \"section_type\": \"timeline\",\n      \"title\": \"Timeline\",\n      \"content\": {\n        \"events\": [\n          {\"date\": \"2020\", \"title\": \"Event 1\", \"description\": \"What happened\"},\n          {\"date\": \"2022\", \"title\": \"Event 2\", \"description\": \"Another milestone\"}\n        ]\n      }\n    },\n    {\n      \"section_type\": \"comparison\",\n      \"title\": \"Comparison\",\n      \"content\": {\n        \"left\": {\"label\": \"Option A\", \"points\": [\"Point 1\", \"Point 2\"]},\n        \"right\": {\"label\": \"Option B\", \"points\": [\"Point 1\", \"Point 2\"]}\n      }\n    },\n    {\n      \"section_type\": \"process\",\n      \"title\": \"Process Flow\",\n      \"content\": {\n        \"steps\": [\n          {\"step\": 1, \"title\": \"Step 1\", \"description\": \"First step\"},\n          {\"step\": 2, \"title\": \"Step 2\", \"description\": \"Second step\"}\n        ]\n      }\n    },\n    {\n      \"section_type\": \"list\",\n      \"title\": \"Key Points\",\n      \"content\": {\n        \"items\": [\"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"]\n      }\n    },\n    {\n      \"section_type\": \"footer\",\n      \"content\": {\"text\": \"Source: Your Sources\", \"logo_placeholder\": true}\n    }\n  ],\n  \"style_suggestion\": \"Modern, clean design with bold icons and clear typography\"\n}`\n\n  const result = await model.generateContent(prompt)\n  const text = result.response.text()\n\n  const jsonMatch = text.match(/\\{[\\s\\S]*\\}/)\n  if (!jsonMatch) throw new Error('Invalid response format')\n\n  return JSON.parse(jsonMatch[0])\n}\n\n// Convert raw PCM audio data to WAV format\n// PCM from Gemini TTS is 16-bit mono at 24000Hz\nexport function pcmToWav(pcmData: Buffer, sampleRate: number = 24000): Buffer {\n  const numChannels = 1  // Mono\n  const bitsPerSample = 16\n  const byteRate = sampleRate * numChannels * (bitsPerSample / 8)\n  const blockAlign = numChannels * (bitsPerSample / 8)\n  const dataSize = pcmData.length\n  const headerSize = 44\n\n  const wavBuffer = Buffer.alloc(headerSize + dataSize)\n\n  // RIFF header\n  wavBuffer.write('RIFF', 0)\n  wavBuffer.writeUInt32LE(36 + dataSize, 4)  // File size - 8\n  wavBuffer.write('WAVE', 8)\n\n  // fmt chunk\n  wavBuffer.write('fmt ', 12)\n  wavBuffer.writeUInt32LE(16, 16)  // Chunk size\n  wavBuffer.writeUInt16LE(1, 20)   // Audio format (1 = PCM)\n  wavBuffer.writeUInt16LE(numChannels, 22)\n  wavBuffer.writeUInt32LE(sampleRate, 24)\n  wavBuffer.writeUInt32LE(byteRate, 28)\n  wavBuffer.writeUInt16LE(blockAlign, 32)\n  wavBuffer.writeUInt16LE(bitsPerSample, 34)\n\n  // data chunk\n  wavBuffer.write('data', 36)\n  wavBuffer.writeUInt32LE(dataSize, 40)\n\n  // Copy PCM data\n  pcmData.copy(wavBuffer, headerSize)\n\n  return wavBuffer\n}\n\n// Generate multi-speaker TTS audio from podcast script using Gemini TTS\nexport async function generateTTSAudio(\n  script: string,\n  voiceConfig: { voice1?: string; voice2?: string } = {}\n): Promise<{ audioData: string; mimeType: string }> {\n  if (!apiKey) throw new Error('Gemini API not configured')\n\n  // Voice options: Kore (firm), Puck (upbeat), Charon (informative), Fenrir (excitable),\n  // Leda (youthful), Orus (firm), Aoede (breezy), Zephyr (bright)\n  const voice1 = voiceConfig.voice1 || 'Orus'   // Alex - deeper, authoritative\n  const voice2 = voiceConfig.voice2 || 'Aoede'  // Sam - lighter, curious\n\n  // Use Gemini 2.5 Flash Preview TTS for multi-speaker support\n  const response = await fetch(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        contents: [{\n          parts: [{\n            text: script\n          }]\n        }],\n        generationConfig: {\n          responseModalities: ['AUDIO'],\n          speechConfig: {\n            multiSpeakerVoiceConfig: {\n              speakerVoiceConfigs: [\n                {\n                  speaker: 'Alex',\n                  voiceConfig: {\n                    prebuiltVoiceConfig: {\n                      voiceName: voice1\n                    }\n                  }\n                },\n                {\n                  speaker: 'Sam',\n                  voiceConfig: {\n                    prebuiltVoiceConfig: {\n                      voiceName: voice2\n                    }\n                  }\n                }\n              ]\n            }\n          }\n        }\n      })\n    }\n  )\n\n  if (!response.ok) {\n    const error = await response.text()\n    console.error('TTS API error:', error)\n    throw new Error(`TTS generation failed: ${response.status}`)\n  }\n\n  const data = await response.json()\n\n  // Extract audio data from response\n  const audioPart = data.candidates?.[0]?.content?.parts?.find(\n    (part: { inlineData?: { mimeType: string; data: string } }) => part.inlineData?.mimeType?.startsWith('audio/')\n  )\n\n  if (!audioPart?.inlineData) {\n    throw new Error('No audio data in response')\n  }\n\n  return {\n    audioData: audioPart.inlineData.data,\n    mimeType: audioPart.inlineData.mimeType\n  }\n}\n\n// Generate video using Veo\nexport async function generateVideo(\n  prompt: string,\n  durationSeconds: number = 8\n): Promise<{ videoData: string; mimeType: string } | { operationName: string }> {\n  if (!apiKey) throw new Error('Gemini API not configured')\n\n  // Veo video generation - start async operation\n  const response = await fetch(\n    `https://generativelanguage.googleapis.com/v1beta/models/veo-2.0-generate-001:predictLongRunning?key=${apiKey}`,\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        instances: [{\n          prompt: prompt\n        }],\n        parameters: {\n          aspectRatio: '16:9',\n          durationSeconds: Math.min(durationSeconds, 8), // Veo max is 8 seconds per clip\n          personGeneration: 'dont_allow',\n          sampleCount: 1\n        }\n      })\n    }\n  )\n\n  if (!response.ok) {\n    const error = await response.text()\n    console.error('Veo API error:', error)\n    throw new Error(`Video generation failed: ${response.status}`)\n  }\n\n  const data = await response.json()\n\n  // Veo returns an operation name for long-running generation\n  if (data.name) {\n    return { operationName: data.name }\n  }\n\n  // If immediate result (unlikely for video)\n  const videoPart = data.predictions?.[0]\n  if (videoPart?.bytesBase64Encoded) {\n    return {\n      videoData: videoPart.bytesBase64Encoded,\n      mimeType: 'video/mp4'\n    }\n  }\n\n  throw new Error('Unexpected video generation response')\n}\n\n// Check video generation operation status\nexport async function checkVideoOperation(\n  operationName: string\n): Promise<{ done: boolean; videoUrl?: string; error?: string }> {\n  if (!apiKey) throw new Error('Gemini API not configured')\n\n  const response = await fetch(\n    `https://generativelanguage.googleapis.com/v1beta/${operationName}?key=${apiKey}`,\n    {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' }\n    }\n  )\n\n  if (!response.ok) {\n    const error = await response.text()\n    throw new Error(`Operation check failed: ${error}`)\n  }\n\n  const data = await response.json()\n\n  if (data.done) {\n    if (data.error) {\n      return { done: true, error: data.error.message }\n    }\n\n    const videoUri = data.response?.generatedSamples?.[0]?.video?.uri\n    return { done: true, videoUrl: videoUri }\n  }\n\n  return { done: false }\n}\n","numLines":926,"startLine":1,"totalLines":926}}}
{"parentUuid":"dfb7a646-ec98-4af4-8ef9-d41bee34bc2f","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012NJadrQMcAbrgXVx9WefUG","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me check a few more API routes to complete the picture:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9038,"cache_creation_input_tokens":11835,"cache_read_input_tokens":37232,"cache_creation":{"ephemeral_5m_input_tokens":11835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavq556cjbaqzaeDLKSa","type":"assistant","uuid":"ea64e289-bb15-4198-a272-9bf64e26b0d7","timestamp":"2025-12-29T11:50:49.215Z"}
{"parentUuid":"ea64e289-bb15-4198-a272-9bf64e26b0d7","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012NJadrQMcAbrgXVx9WefUG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mjn9yVauLD2UTe5xMB7v3R","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/audio/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9038,"cache_creation_input_tokens":11835,"cache_read_input_tokens":37232,"cache_creation":{"ephemeral_5m_input_tokens":11835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavq556cjbaqzaeDLKSa","type":"assistant","uuid":"6c6115a1-fcd4-43e1-b73a-5f7631d9aabf","timestamp":"2025-12-29T11:50:49.941Z"}
{"parentUuid":"6c6115a1-fcd4-43e1-b73a-5f7631d9aabf","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_012NJadrQMcAbrgXVx9WefUG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018c5JDojspYH1TVa9x4dAkX","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/study/route.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9038,"cache_creation_input_tokens":11835,"cache_read_input_tokens":37232,"cache_creation":{"ephemeral_5m_input_tokens":11835,"ephemeral_1h_input_tokens":0},"output_tokens":186,"service_tier":"standard"}},"requestId":"req_011CWavq556cjbaqzaeDLKSa","type":"assistant","uuid":"c665922e-5510-40c4-bd4e-707490c49bda","timestamp":"2025-12-29T11:50:50.238Z"}
{"parentUuid":"c665922e-5510-40c4-bd4e-707490c49bda","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mjn9yVauLD2UTe5xMB7v3R","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→import { generateAudioScript, generateTTSAudio, pcmToWav, isGeminiConfigured } from '@/lib/gemini'\n     4→\n     5→const supabase = createClient(\n     6→  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n     7→  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     8→)\n     9→\n    10→async function verifyAccess(request: NextRequest, notebookId: string) {\n    11→  const authHeader = request.headers.get('authorization')\n    12→  if (!authHeader) return null\n    13→\n    14→  const token = authHeader.replace('Bearer ', '')\n    15→  const { data: { user } } = await supabase.auth.getUser(token)\n    16→\n    17→  if (!user) return null\n    18→\n    19→  const { data: notebook } = await supabase\n    20→    .from('notebooks')\n    21→    .select('id')\n    22→    .eq('id', notebookId)\n    23→    .eq('user_id', user.id)\n    24→    .single()\n    25→\n    26→  if (!notebook) return null\n    27→\n    28→  return user\n    29→}\n    30→\n    31→export async function GET(\n    32→  request: NextRequest,\n    33→  { params }: { params: Promise<{ id: string }> }\n    34→) {\n    35→  try {\n    36→    const { id: notebookId } = await params\n    37→    const user = await verifyAccess(request, notebookId)\n    38→\n    39→    if (!user) {\n    40→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    41→    }\n    42→\n    43→    const { data: audioOverviews } = await supabase\n    44→      .from('audio_overviews')\n    45→      .select('*')\n    46→      .eq('notebook_id', notebookId)\n    47→      .order('created_at', { ascending: false })\n    48→\n    49→    // Map audio_file_path to audio_url for frontend compatibility\n    50→    const mappedAudio = (audioOverviews || []).map(audio => ({\n    51→      ...audio,\n    52→      audio_url: audio.audio_file_path\n    53→    }))\n    54→\n    55→    return NextResponse.json({ data: mappedAudio })\n    56→  } catch (error) {\n    57→    console.error('List audio error:', error)\n    58→    return NextResponse.json({ error: 'Failed to list audio' }, { status: 500 })\n    59→  }\n    60→}\n    61→\n    62→export async function POST(\n    63→  request: NextRequest,\n    64→  { params }: { params: Promise<{ id: string }> }\n    65→) {\n    66→  try {\n    67→    const { id: notebookId } = await params\n    68→    const user = await verifyAccess(request, notebookId)\n    69→\n    70→    if (!user) {\n    71→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    72→    }\n    73→\n    74→    const body = await request.json()\n    75→    const { format, source_ids, custom_instructions } = body\n    76→\n    77→    // Check if Gemini is configured\n    78→    if (!isGeminiConfigured()) {\n    79→      return NextResponse.json({\n    80→        error: 'Gemini API not configured. Please set GOOGLE_API_KEY in your environment variables.'\n    81→      }, { status: 503 })\n    82→    }\n    83→\n    84→    // Get sources content\n    85→    let query = supabase\n    86→      .from('sources')\n    87→      .select('*')\n    88→      .eq('notebook_id', notebookId)\n    89→      .eq('status', 'ready')\n    90→\n    91→    if (source_ids && source_ids.length > 0) {\n    92→      query = query.in('id', source_ids)\n    93→    }\n    94→\n    95→    const { data: sources } = await query\n    96→\n    97→    if (!sources || sources.length === 0) {\n    98→      return NextResponse.json({ error: 'No sources available' }, { status: 400 })\n    99→    }\n   100→\n   101→    // Combine source content\n   102→    const sourceContent = sources.map(s => {\n   103→      const parts: string[] = []\n   104→      parts.push(`## ${s.name}`)\n   105→\n   106→      if (s.type === 'text' && s.metadata?.content) {\n   107→        parts.push(s.metadata.content)\n   108→      }\n   109→\n   110→      if (s.source_guide?.summary) {\n   111→        parts.push(`Summary: ${s.source_guide.summary}`)\n   112→      }\n   113→\n   114→      if (s.source_guide?.key_topics && s.source_guide.key_topics.length > 0) {\n   115→        parts.push(`Key Topics: ${s.source_guide.key_topics.join(', ')}`)\n   116→      }\n   117→\n   118→      return parts.join('\\n\\n')\n   119→    }).join('\\n\\n---\\n\\n')\n   120→\n   121→    // Add custom instructions if provided\n   122→    const fullContent = custom_instructions\n   123→      ? `${sourceContent}\\n\\n[Additional Instructions: ${custom_instructions}]`\n   124→      : sourceContent\n   125→\n   126→    // Limit content to prevent token overflow\n   127→    const truncatedContent = fullContent.slice(0, 100000)\n   128→\n   129→    // Generate real script using Gemini\n   130→    const validFormat = (format as 'deep_dive' | 'brief' | 'critique' | 'debate') || 'deep_dive'\n   131→\n   132→    try {\n   133→      // Step 1: Generate the script\n   134→      const script = await generateAudioScript(truncatedContent, validFormat)\n   135→\n   136→      // Step 2: Generate TTS audio from the script\n   137→      let audioUrl: string | undefined\n   138→      let durationSeconds = 0\n   139→\n   140→      try {\n   141→        // For longer scripts, we may need to chunk them\n   142→        // TTS has limits on input length, so we'll use a portion for now\n   143→        const scriptForTTS = script.slice(0, 3000) // Limit for TTS\n   144→        console.log('[AUDIO] Starting TTS generation, script length:', scriptForTTS.length)\n   145→\n   146→        const { audioData, mimeType } = await generateTTSAudio(scriptForTTS)\n   147→        console.log('[AUDIO] TTS success, audio data length:', audioData.length, 'mime:', mimeType)\n   148→\n   149→        // Convert PCM to WAV format for browser compatibility\n   150→        const pcmBuffer = Buffer.from(audioData, 'base64')\n   151→        const wavBuffer = pcmToWav(pcmBuffer)\n   152→        console.log('[AUDIO] Converted to WAV, size:', wavBuffer.length, 'bytes')\n   153→\n   154→        // Upload audio to Supabase Storage\n   155→        const audioFileName = `audio_${notebookId}_${Date.now()}.wav`\n   156→\n   157→        const { data: uploadData, error: uploadError } = await supabase.storage\n   158→          .from('audio')\n   159→          .upload(audioFileName, wavBuffer, {\n   160→            contentType: 'audio/wav',\n   161→            upsert: true\n   162→          })\n   163→\n   164→        if (uploadError) {\n   165→          console.error('Audio upload error:', uploadError)\n   166→        } else {\n   167→          // Get public URL\n   168→          const { data: urlData } = supabase.storage\n   169→            .from('audio')\n   170→            .getPublicUrl(audioFileName)\n   171→\n   172→          audioUrl = urlData.publicUrl\n   173→\n   174→          // Calculate actual duration from audio data\n   175→          // WAV: 16-bit mono at 24000Hz = 48000 bytes per second\n   176→          const bytesPerSecond = 24000 * 2 * 1  // sampleRate * bytesPerSample * channels\n   177→          durationSeconds = Math.round(pcmBuffer.length / bytesPerSecond)\n   178→          console.log('[AUDIO] Audio duration:', durationSeconds, 'seconds')\n   179→        }\n   180→      } catch (ttsError) {\n   181→        console.error('[AUDIO] TTS generation error (continuing with script only):', ttsError)\n   182→        console.error('[AUDIO] Error details:', JSON.stringify(ttsError, Object.getOwnPropertyNames(ttsError)))\n   183→        // Continue without audio - we still have the script\n   184→        const wordCount = script.split(/\\s+/).length\n   185→        durationSeconds = Math.round((wordCount / 150) * 60)\n   186→      }\n   187→\n   188→      // Create audio record\n   189→      const { data: audio, error } = await supabase\n   190→        .from('audio_overviews')\n   191→        .insert({\n   192→          notebook_id: notebookId,\n   193→          format: validFormat,\n   194→          status: 'completed',\n   195→          progress_percent: 100,\n   196→          custom_instructions,\n   197→          source_ids: sources.map(s => s.id),\n   198→          script,\n   199→          audio_file_path: audioUrl,\n   200→          duration_seconds: durationSeconds,\n   201→          model_used: 'gemini-2.0-flash-exp',\n   202→          cost_usd: audioUrl ? 0.01 : 0.005,\n   203→          completed_at: new Date().toISOString(),\n   204→        })\n   205→        .select()\n   206→        .single()\n   207→\n   208→      if (error) {\n   209→        console.error('Database error:', error)\n   210→        return NextResponse.json({ error: 'Failed to save audio overview' }, { status: 400 })\n   211→      }\n   212→\n   213→      // Map audio_file_path to audio_url for frontend compatibility\n   214→      return NextResponse.json({ data: { ...audio, audio_url: audio.audio_file_path } })\n   215→    } catch (error) {\n   216→      console.error('Script generation error:', error)\n   217→      return NextResponse.json({\n   218→        error: 'Failed to generate audio. Please try again.'\n   219→      }, { status: 500 })\n   220→    }\n   221→  } catch (error) {\n   222→    console.error('Create audio error:', error)\n   223→    return NextResponse.json({ error: 'Failed to create audio' }, { status: 500 })\n   224→  }\n   225→}\n   226→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7da82589-21a0-4e13-872a-d81eba504c80","timestamp":"2025-12-29T11:50:50.290Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/audio/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\nimport { generateAudioScript, generateTTSAudio, pcmToWav, isGeminiConfigured } from '@/lib/gemini'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n)\n\nasync function verifyAccess(request: NextRequest, notebookId: string) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader) return null\n\n  const token = authHeader.replace('Bearer ', '')\n  const { data: { user } } = await supabase.auth.getUser(token)\n\n  if (!user) return null\n\n  const { data: notebook } = await supabase\n    .from('notebooks')\n    .select('id')\n    .eq('id', notebookId)\n    .eq('user_id', user.id)\n    .single()\n\n  if (!notebook) return null\n\n  return user\n}\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { data: audioOverviews } = await supabase\n      .from('audio_overviews')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: false })\n\n    // Map audio_file_path to audio_url for frontend compatibility\n    const mappedAudio = (audioOverviews || []).map(audio => ({\n      ...audio,\n      audio_url: audio.audio_file_path\n    }))\n\n    return NextResponse.json({ data: mappedAudio })\n  } catch (error) {\n    console.error('List audio error:', error)\n    return NextResponse.json({ error: 'Failed to list audio' }, { status: 500 })\n  }\n}\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { format, source_ids, custom_instructions } = body\n\n    // Check if Gemini is configured\n    if (!isGeminiConfigured()) {\n      return NextResponse.json({\n        error: 'Gemini API not configured. Please set GOOGLE_API_KEY in your environment variables.'\n      }, { status: 503 })\n    }\n\n    // Get sources content\n    let query = supabase\n      .from('sources')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('status', 'ready')\n\n    if (source_ids && source_ids.length > 0) {\n      query = query.in('id', source_ids)\n    }\n\n    const { data: sources } = await query\n\n    if (!sources || sources.length === 0) {\n      return NextResponse.json({ error: 'No sources available' }, { status: 400 })\n    }\n\n    // Combine source content\n    const sourceContent = sources.map(s => {\n      const parts: string[] = []\n      parts.push(`## ${s.name}`)\n\n      if (s.type === 'text' && s.metadata?.content) {\n        parts.push(s.metadata.content)\n      }\n\n      if (s.source_guide?.summary) {\n        parts.push(`Summary: ${s.source_guide.summary}`)\n      }\n\n      if (s.source_guide?.key_topics && s.source_guide.key_topics.length > 0) {\n        parts.push(`Key Topics: ${s.source_guide.key_topics.join(', ')}`)\n      }\n\n      return parts.join('\\n\\n')\n    }).join('\\n\\n---\\n\\n')\n\n    // Add custom instructions if provided\n    const fullContent = custom_instructions\n      ? `${sourceContent}\\n\\n[Additional Instructions: ${custom_instructions}]`\n      : sourceContent\n\n    // Limit content to prevent token overflow\n    const truncatedContent = fullContent.slice(0, 100000)\n\n    // Generate real script using Gemini\n    const validFormat = (format as 'deep_dive' | 'brief' | 'critique' | 'debate') || 'deep_dive'\n\n    try {\n      // Step 1: Generate the script\n      const script = await generateAudioScript(truncatedContent, validFormat)\n\n      // Step 2: Generate TTS audio from the script\n      let audioUrl: string | undefined\n      let durationSeconds = 0\n\n      try {\n        // For longer scripts, we may need to chunk them\n        // TTS has limits on input length, so we'll use a portion for now\n        const scriptForTTS = script.slice(0, 3000) // Limit for TTS\n        console.log('[AUDIO] Starting TTS generation, script length:', scriptForTTS.length)\n\n        const { audioData, mimeType } = await generateTTSAudio(scriptForTTS)\n        console.log('[AUDIO] TTS success, audio data length:', audioData.length, 'mime:', mimeType)\n\n        // Convert PCM to WAV format for browser compatibility\n        const pcmBuffer = Buffer.from(audioData, 'base64')\n        const wavBuffer = pcmToWav(pcmBuffer)\n        console.log('[AUDIO] Converted to WAV, size:', wavBuffer.length, 'bytes')\n\n        // Upload audio to Supabase Storage\n        const audioFileName = `audio_${notebookId}_${Date.now()}.wav`\n\n        const { data: uploadData, error: uploadError } = await supabase.storage\n          .from('audio')\n          .upload(audioFileName, wavBuffer, {\n            contentType: 'audio/wav',\n            upsert: true\n          })\n\n        if (uploadError) {\n          console.error('Audio upload error:', uploadError)\n        } else {\n          // Get public URL\n          const { data: urlData } = supabase.storage\n            .from('audio')\n            .getPublicUrl(audioFileName)\n\n          audioUrl = urlData.publicUrl\n\n          // Calculate actual duration from audio data\n          // WAV: 16-bit mono at 24000Hz = 48000 bytes per second\n          const bytesPerSecond = 24000 * 2 * 1  // sampleRate * bytesPerSample * channels\n          durationSeconds = Math.round(pcmBuffer.length / bytesPerSecond)\n          console.log('[AUDIO] Audio duration:', durationSeconds, 'seconds')\n        }\n      } catch (ttsError) {\n        console.error('[AUDIO] TTS generation error (continuing with script only):', ttsError)\n        console.error('[AUDIO] Error details:', JSON.stringify(ttsError, Object.getOwnPropertyNames(ttsError)))\n        // Continue without audio - we still have the script\n        const wordCount = script.split(/\\s+/).length\n        durationSeconds = Math.round((wordCount / 150) * 60)\n      }\n\n      // Create audio record\n      const { data: audio, error } = await supabase\n        .from('audio_overviews')\n        .insert({\n          notebook_id: notebookId,\n          format: validFormat,\n          status: 'completed',\n          progress_percent: 100,\n          custom_instructions,\n          source_ids: sources.map(s => s.id),\n          script,\n          audio_file_path: audioUrl,\n          duration_seconds: durationSeconds,\n          model_used: 'gemini-2.0-flash-exp',\n          cost_usd: audioUrl ? 0.01 : 0.005,\n          completed_at: new Date().toISOString(),\n        })\n        .select()\n        .single()\n\n      if (error) {\n        console.error('Database error:', error)\n        return NextResponse.json({ error: 'Failed to save audio overview' }, { status: 400 })\n      }\n\n      // Map audio_file_path to audio_url for frontend compatibility\n      return NextResponse.json({ data: { ...audio, audio_url: audio.audio_file_path } })\n    } catch (error) {\n      console.error('Script generation error:', error)\n      return NextResponse.json({\n        error: 'Failed to generate audio. Please try again.'\n      }, { status: 500 })\n    }\n  } catch (error) {\n    console.error('Create audio error:', error)\n    return NextResponse.json({ error: 'Failed to create audio' }, { status: 500 })\n  }\n}\n","numLines":226,"startLine":1,"totalLines":226}}}
{"parentUuid":"7da82589-21a0-4e13-872a-d81eba504c80","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018c5JDojspYH1TVa9x4dAkX","type":"tool_result","content":"     1→import { NextRequest, NextResponse } from 'next/server'\n     2→import { createClient } from '@supabase/supabase-js'\n     3→import {\n     4→  generateFlashcards,\n     5→  generateQuiz,\n     6→  generateStudyGuide,\n     7→  generateFAQ,\n     8→  generateMindMap,\n     9→  isGeminiConfigured\n    10→} from '@/lib/gemini'\n    11→\n    12→const supabase = createClient(\n    13→  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    14→  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n    15→)\n    16→\n    17→async function verifyAccess(request: NextRequest, notebookId: string) {\n    18→  const authHeader = request.headers.get('authorization')\n    19→  if (!authHeader) return null\n    20→\n    21→  const token = authHeader.replace('Bearer ', '')\n    22→  const { data: { user } } = await supabase.auth.getUser(token)\n    23→\n    24→  if (!user) return null\n    25→\n    26→  const { data: notebook } = await supabase\n    27→    .from('notebooks')\n    28→    .select('id')\n    29→    .eq('id', notebookId)\n    30→    .eq('user_id', user.id)\n    31→    .single()\n    32→\n    33→  if (!notebook) return null\n    34→\n    35→  return user\n    36→}\n    37→\n    38→async function getSourceContent(notebookId: string, sourceIds?: string[]) {\n    39→  let query = supabase\n    40→    .from('sources')\n    41→    .select('*')\n    42→    .eq('notebook_id', notebookId)\n    43→    .eq('status', 'ready')\n    44→\n    45→  if (sourceIds && sourceIds.length > 0) {\n    46→    query = query.in('id', sourceIds)\n    47→  }\n    48→\n    49→  const { data: sources } = await query\n    50→\n    51→  if (!sources || sources.length === 0) {\n    52→    return { content: '', sources: [] }\n    53→  }\n    54→\n    55→  // Combine all source content\n    56→  const content = sources.map(s => {\n    57→    const parts: string[] = []\n    58→\n    59→    // Add source name as header\n    60→    parts.push(`## ${s.name}`)\n    61→\n    62→    // Add text content if available\n    63→    if (s.type === 'text' && s.metadata?.content) {\n    64→      parts.push(s.metadata.content)\n    65→    }\n    66→\n    67→    // Add source guide summary if available\n    68→    if (s.source_guide?.summary) {\n    69→      parts.push(`Summary: ${s.source_guide.summary}`)\n    70→    }\n    71→\n    72→    // Add key topics if available\n    73→    if (s.source_guide?.key_topics && s.source_guide.key_topics.length > 0) {\n    74→      parts.push(`Key Topics: ${s.source_guide.key_topics.join(', ')}`)\n    75→    }\n    76→\n    77→    return parts.join('\\n\\n')\n    78→  }).join('\\n\\n---\\n\\n')\n    79→\n    80→  return { content, sources }\n    81→}\n    82→\n    83→// Map API types to database types\n    84→function mapTypeToDbType(type: string): string {\n    85→  const mapping: Record<string, string> = {\n    86→    'flashcards': 'flashcards',\n    87→    'quiz': 'quiz',\n    88→    'study-guide': 'study_guide',\n    89→    'faq': 'faq',\n    90→    'mind-map': 'mind_map'\n    91→  }\n    92→  return mapping[type] || type\n    93→}\n    94→\n    95→// GET: Fetch existing study materials for a notebook\n    96→export async function GET(\n    97→  request: NextRequest,\n    98→  { params }: { params: Promise<{ id: string }> }\n    99→) {\n   100→  try {\n   101→    const { id: notebookId } = await params\n   102→    const user = await verifyAccess(request, notebookId)\n   103→\n   104→    if (!user) {\n   105→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n   106→    }\n   107→\n   108→    // Check for specific type query param\n   109→    const { searchParams } = new URL(request.url)\n   110→    const type = searchParams.get('type')\n   111→\n   112→    let query = supabase\n   113→      .from('study_materials')\n   114→      .select('*')\n   115→      .eq('notebook_id', notebookId)\n   116→      .order('created_at', { ascending: false })\n   117→\n   118→    if (type) {\n   119→      query = query.eq('type', mapTypeToDbType(type))\n   120→    }\n   121→\n   122→    const { data: materials, error } = await query\n   123→\n   124→    if (error) {\n   125→      console.error('Fetch study materials error:', error)\n   126→      return NextResponse.json({ error: 'Failed to fetch study materials' }, { status: 500 })\n   127→    }\n   128→\n   129→    return NextResponse.json({ data: materials || [] })\n   130→  } catch (error) {\n   131→    console.error('Get study materials error:', error)\n   132→    return NextResponse.json({ error: 'Failed to get study materials' }, { status: 500 })\n   133→  }\n   134→}\n   135→\n   136→// POST: Generate and save study materials\n   137→export async function POST(\n   138→  request: NextRequest,\n   139→  { params }: { params: Promise<{ id: string }> }\n   140→) {\n   141→  try {\n   142→    const { id: notebookId } = await params\n   143→    const user = await verifyAccess(request, notebookId)\n   144→\n   145→    if (!user) {\n   146→      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n   147→    }\n   148→\n   149→    const body = await request.json()\n   150→    const {\n   151→      type,\n   152→      source_ids,\n   153→      count,\n   154→      regenerate,\n   155→      difficulty,\n   156→      focus_area,\n   157→      custom_instructions,\n   158→      question_types\n   159→    } = body\n   160→\n   161→    const dbType = mapTypeToDbType(type)\n   162→\n   163→    // Build context with config options\n   164→    let contextPrefix = ''\n   165→    if (difficulty) {\n   166→      contextPrefix += `Difficulty level: ${difficulty}. `\n   167→    }\n   168→    if (focus_area) {\n   169→      contextPrefix += `Focus on: ${focus_area}. `\n   170→    }\n   171→    if (custom_instructions) {\n   172→      contextPrefix += `Additional instructions: ${custom_instructions}. `\n   173→    }\n   174→\n   175→    // Get source content - always regenerate fresh\n   176→    const { content, sources } = await getSourceContent(notebookId, source_ids)\n   177→\n   178→    if (!content) {\n   179→      return NextResponse.json({ error: 'No source content available' }, { status: 400 })\n   180→    }\n   181→\n   182→    // Check if Gemini is configured\n   183→    if (!isGeminiConfigured()) {\n   184→      return NextResponse.json({\n   185→        error: 'Gemini API not configured. Please set GOOGLE_API_KEY in your environment variables.'\n   186→      }, { status: 503 })\n   187→    }\n   188→\n   189→    // Limit content to prevent token overflow (roughly 100k chars = ~25k tokens)\n   190→    // Prepend context prefix with config options\n   191→    const fullContent = contextPrefix ? `[Configuration: ${contextPrefix}]\\n\\n${content}` : content\n   192→    const truncatedContent = fullContent.slice(0, 100000)\n   193→    const sourceIdArray = sources.map(s => s.id)\n   194→\n   195→    if (type === 'flashcards') {\n   196→      try {\n   197→        const flashcards = await generateFlashcards(truncatedContent, count || 10)\n   198→\n   199→        // Add IDs to flashcards\n   200→        const flashcardsWithIds = flashcards.map((fc, idx) => ({\n   201→          id: `fc-${idx + 1}`,\n   202→          ...fc\n   203→        }))\n   204→\n   205→        const resultData = {\n   206→          flashcards: flashcardsWithIds,\n   207→          source_count: sources.length,\n   208→        }\n   209→\n   210→        // Save to database\n   211→        const { data: saved, error: saveError } = await supabase\n   212→          .from('study_materials')\n   213→          .insert({\n   214→            notebook_id: notebookId,\n   215→            type: 'flashcards',\n   216→            data: resultData,\n   217→            source_ids: sourceIdArray,\n   218→            model_used: 'gemini-2.0-flash-exp',\n   219→            cost_usd: 0.001,\n   220→          })\n   221→          .select()\n   222→          .single()\n   223→\n   224→        if (saveError) {\n   225→          console.error('Save flashcards error:', saveError)\n   226→        }\n   227→\n   228→        return NextResponse.json({\n   229→          data: resultData,\n   230→          material_id: saved?.id,\n   231→          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n   232→        })\n   233→      } catch (error) {\n   234→        console.error('Flashcard generation error:', error)\n   235→        return NextResponse.json({\n   236→          error: 'Failed to generate flashcards. Please try again.'\n   237→        }, { status: 500 })\n   238→      }\n   239→    }\n   240→\n   241→    if (type === 'quiz') {\n   242→      try {\n   243→        const questions = await generateQuiz(truncatedContent, count || 5)\n   244→\n   245→        // Add IDs to questions\n   246→        const questionsWithIds = questions.map((q, idx) => ({\n   247→          id: `q-${idx + 1}`,\n   248→          ...q\n   249→        }))\n   250→\n   251→        const resultData = {\n   252→          questions: questionsWithIds,\n   253→          source_count: sources.length,\n   254→        }\n   255→\n   256→        // Save to database\n   257→        const { data: saved, error: saveError } = await supabase\n   258→          .from('study_materials')\n   259→          .insert({\n   260→            notebook_id: notebookId,\n   261→            type: 'quiz',\n   262→            data: resultData,\n   263→            source_ids: sourceIdArray,\n   264→            model_used: 'gemini-2.0-flash-exp',\n   265→            cost_usd: 0.001,\n   266→          })\n   267→          .select()\n   268→          .single()\n   269→\n   270→        if (saveError) {\n   271→          console.error('Save quiz error:', saveError)\n   272→        }\n   273→\n   274→        return NextResponse.json({\n   275→          data: resultData,\n   276→          material_id: saved?.id,\n   277→          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n   278→        })\n   279→      } catch (error) {\n   280→        console.error('Quiz generation error:', error)\n   281→        return NextResponse.json({\n   282→          error: 'Failed to generate quiz. Please try again.'\n   283→        }, { status: 500 })\n   284→      }\n   285→    }\n   286→\n   287→    if (type === 'study-guide') {\n   288→      try {\n   289→        const guide = await generateStudyGuide(truncatedContent)\n   290→\n   291→        const resultData = {\n   292→          ...guide,\n   293→          source_count: sources.length,\n   294→        }\n   295→\n   296→        // Save to database\n   297→        const { data: saved, error: saveError } = await supabase\n   298→          .from('study_materials')\n   299→          .insert({\n   300→            notebook_id: notebookId,\n   301→            type: 'study_guide',\n   302→            data: resultData,\n   303→            source_ids: sourceIdArray,\n   304→            model_used: 'gemini-2.0-flash-exp',\n   305→            cost_usd: 0.002,\n   306→          })\n   307→          .select()\n   308→          .single()\n   309→\n   310→        if (saveError) {\n   311→          console.error('Save study guide error:', saveError)\n   312→        }\n   313→\n   314→        return NextResponse.json({\n   315→          data: resultData,\n   316→          material_id: saved?.id,\n   317→          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.002 },\n   318→        })\n   319→      } catch (error) {\n   320→        console.error('Study guide generation error:', error)\n   321→        return NextResponse.json({\n   322→          error: 'Failed to generate study guide. Please try again.'\n   323→        }, { status: 500 })\n   324→      }\n   325→    }\n   326→\n   327→    if (type === 'faq') {\n   328→      try {\n   329→        const faq = await generateFAQ(truncatedContent, count || 8)\n   330→\n   331→        const resultData = {\n   332→          faq,\n   333→          source_count: sources.length,\n   334→        }\n   335→\n   336→        // Save to database\n   337→        const { data: saved, error: saveError } = await supabase\n   338→          .from('study_materials')\n   339→          .insert({\n   340→            notebook_id: notebookId,\n   341→            type: 'faq',\n   342→            data: resultData,\n   343→            source_ids: sourceIdArray,\n   344→            model_used: 'gemini-2.0-flash-exp',\n   345→            cost_usd: 0.001,\n   346→          })\n   347→          .select()\n   348→          .single()\n   349→\n   350→        if (saveError) {\n   351→          console.error('Save FAQ error:', saveError)\n   352→        }\n   353→\n   354→        return NextResponse.json({\n   355→          data: resultData,\n   356→          material_id: saved?.id,\n   357→          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n   358→        })\n   359→      } catch (error) {\n   360→        console.error('FAQ generation error:', error)\n   361→        return NextResponse.json({\n   362→          error: 'Failed to generate FAQ. Please try again.'\n   363→        }, { status: 500 })\n   364→      }\n   365→    }\n   366→\n   367→    if (type === 'mind-map') {\n   368→      try {\n   369→        const mindMap = await generateMindMap(truncatedContent)\n   370→\n   371→        const resultData = {\n   372→          ...mindMap,\n   373→          source_count: sources.length,\n   374→        }\n   375→\n   376→        // Save to database\n   377→        const { data: saved, error: saveError } = await supabase\n   378→          .from('study_materials')\n   379→          .insert({\n   380→            notebook_id: notebookId,\n   381→            type: 'mind_map',\n   382→            data: resultData,\n   383→            source_ids: sourceIdArray,\n   384→            model_used: 'gemini-2.0-flash-exp',\n   385→            cost_usd: 0.001,\n   386→          })\n   387→          .select()\n   388→          .single()\n   389→\n   390→        if (saveError) {\n   391→          console.error('Save mind map error:', saveError)\n   392→        }\n   393→\n   394→        return NextResponse.json({\n   395→          data: resultData,\n   396→          material_id: saved?.id,\n   397→          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n   398→        })\n   399→      } catch (error) {\n   400→        console.error('Mind map generation error:', error)\n   401→        return NextResponse.json({\n   402→          error: 'Failed to generate mind map. Please try again.'\n   403→        }, { status: 500 })\n   404→      }\n   405→    }\n   406→\n   407→    return NextResponse.json({ error: 'Invalid study type' }, { status: 400 })\n   408→  } catch (error) {\n   409→    console.error('Generate study materials error:', error)\n   410→    return NextResponse.json({ error: 'Failed to generate study materials' }, { status: 500 })\n   411→  }\n   412→}\n   413→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0db8f82e-3396-4ff8-acb0-7bd4932b653f","timestamp":"2025-12-29T11:50:50.290Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/api/notebooks/[id]/study/route.ts","content":"import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@supabase/supabase-js'\nimport {\n  generateFlashcards,\n  generateQuiz,\n  generateStudyGuide,\n  generateFAQ,\n  generateMindMap,\n  isGeminiConfigured\n} from '@/lib/gemini'\n\nconst supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n)\n\nasync function verifyAccess(request: NextRequest, notebookId: string) {\n  const authHeader = request.headers.get('authorization')\n  if (!authHeader) return null\n\n  const token = authHeader.replace('Bearer ', '')\n  const { data: { user } } = await supabase.auth.getUser(token)\n\n  if (!user) return null\n\n  const { data: notebook } = await supabase\n    .from('notebooks')\n    .select('id')\n    .eq('id', notebookId)\n    .eq('user_id', user.id)\n    .single()\n\n  if (!notebook) return null\n\n  return user\n}\n\nasync function getSourceContent(notebookId: string, sourceIds?: string[]) {\n  let query = supabase\n    .from('sources')\n    .select('*')\n    .eq('notebook_id', notebookId)\n    .eq('status', 'ready')\n\n  if (sourceIds && sourceIds.length > 0) {\n    query = query.in('id', sourceIds)\n  }\n\n  const { data: sources } = await query\n\n  if (!sources || sources.length === 0) {\n    return { content: '', sources: [] }\n  }\n\n  // Combine all source content\n  const content = sources.map(s => {\n    const parts: string[] = []\n\n    // Add source name as header\n    parts.push(`## ${s.name}`)\n\n    // Add text content if available\n    if (s.type === 'text' && s.metadata?.content) {\n      parts.push(s.metadata.content)\n    }\n\n    // Add source guide summary if available\n    if (s.source_guide?.summary) {\n      parts.push(`Summary: ${s.source_guide.summary}`)\n    }\n\n    // Add key topics if available\n    if (s.source_guide?.key_topics && s.source_guide.key_topics.length > 0) {\n      parts.push(`Key Topics: ${s.source_guide.key_topics.join(', ')}`)\n    }\n\n    return parts.join('\\n\\n')\n  }).join('\\n\\n---\\n\\n')\n\n  return { content, sources }\n}\n\n// Map API types to database types\nfunction mapTypeToDbType(type: string): string {\n  const mapping: Record<string, string> = {\n    'flashcards': 'flashcards',\n    'quiz': 'quiz',\n    'study-guide': 'study_guide',\n    'faq': 'faq',\n    'mind-map': 'mind_map'\n  }\n  return mapping[type] || type\n}\n\n// GET: Fetch existing study materials for a notebook\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    // Check for specific type query param\n    const { searchParams } = new URL(request.url)\n    const type = searchParams.get('type')\n\n    let query = supabase\n      .from('study_materials')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: false })\n\n    if (type) {\n      query = query.eq('type', mapTypeToDbType(type))\n    }\n\n    const { data: materials, error } = await query\n\n    if (error) {\n      console.error('Fetch study materials error:', error)\n      return NextResponse.json({ error: 'Failed to fetch study materials' }, { status: 500 })\n    }\n\n    return NextResponse.json({ data: materials || [] })\n  } catch (error) {\n    console.error('Get study materials error:', error)\n    return NextResponse.json({ error: 'Failed to get study materials' }, { status: 500 })\n  }\n}\n\n// POST: Generate and save study materials\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id: notebookId } = await params\n    const user = await verifyAccess(request, notebookId)\n\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const {\n      type,\n      source_ids,\n      count,\n      regenerate,\n      difficulty,\n      focus_area,\n      custom_instructions,\n      question_types\n    } = body\n\n    const dbType = mapTypeToDbType(type)\n\n    // Build context with config options\n    let contextPrefix = ''\n    if (difficulty) {\n      contextPrefix += `Difficulty level: ${difficulty}. `\n    }\n    if (focus_area) {\n      contextPrefix += `Focus on: ${focus_area}. `\n    }\n    if (custom_instructions) {\n      contextPrefix += `Additional instructions: ${custom_instructions}. `\n    }\n\n    // Get source content - always regenerate fresh\n    const { content, sources } = await getSourceContent(notebookId, source_ids)\n\n    if (!content) {\n      return NextResponse.json({ error: 'No source content available' }, { status: 400 })\n    }\n\n    // Check if Gemini is configured\n    if (!isGeminiConfigured()) {\n      return NextResponse.json({\n        error: 'Gemini API not configured. Please set GOOGLE_API_KEY in your environment variables.'\n      }, { status: 503 })\n    }\n\n    // Limit content to prevent token overflow (roughly 100k chars = ~25k tokens)\n    // Prepend context prefix with config options\n    const fullContent = contextPrefix ? `[Configuration: ${contextPrefix}]\\n\\n${content}` : content\n    const truncatedContent = fullContent.slice(0, 100000)\n    const sourceIdArray = sources.map(s => s.id)\n\n    if (type === 'flashcards') {\n      try {\n        const flashcards = await generateFlashcards(truncatedContent, count || 10)\n\n        // Add IDs to flashcards\n        const flashcardsWithIds = flashcards.map((fc, idx) => ({\n          id: `fc-${idx + 1}`,\n          ...fc\n        }))\n\n        const resultData = {\n          flashcards: flashcardsWithIds,\n          source_count: sources.length,\n        }\n\n        // Save to database\n        const { data: saved, error: saveError } = await supabase\n          .from('study_materials')\n          .insert({\n            notebook_id: notebookId,\n            type: 'flashcards',\n            data: resultData,\n            source_ids: sourceIdArray,\n            model_used: 'gemini-2.0-flash-exp',\n            cost_usd: 0.001,\n          })\n          .select()\n          .single()\n\n        if (saveError) {\n          console.error('Save flashcards error:', saveError)\n        }\n\n        return NextResponse.json({\n          data: resultData,\n          material_id: saved?.id,\n          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n        })\n      } catch (error) {\n        console.error('Flashcard generation error:', error)\n        return NextResponse.json({\n          error: 'Failed to generate flashcards. Please try again.'\n        }, { status: 500 })\n      }\n    }\n\n    if (type === 'quiz') {\n      try {\n        const questions = await generateQuiz(truncatedContent, count || 5)\n\n        // Add IDs to questions\n        const questionsWithIds = questions.map((q, idx) => ({\n          id: `q-${idx + 1}`,\n          ...q\n        }))\n\n        const resultData = {\n          questions: questionsWithIds,\n          source_count: sources.length,\n        }\n\n        // Save to database\n        const { data: saved, error: saveError } = await supabase\n          .from('study_materials')\n          .insert({\n            notebook_id: notebookId,\n            type: 'quiz',\n            data: resultData,\n            source_ids: sourceIdArray,\n            model_used: 'gemini-2.0-flash-exp',\n            cost_usd: 0.001,\n          })\n          .select()\n          .single()\n\n        if (saveError) {\n          console.error('Save quiz error:', saveError)\n        }\n\n        return NextResponse.json({\n          data: resultData,\n          material_id: saved?.id,\n          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n        })\n      } catch (error) {\n        console.error('Quiz generation error:', error)\n        return NextResponse.json({\n          error: 'Failed to generate quiz. Please try again.'\n        }, { status: 500 })\n      }\n    }\n\n    if (type === 'study-guide') {\n      try {\n        const guide = await generateStudyGuide(truncatedContent)\n\n        const resultData = {\n          ...guide,\n          source_count: sources.length,\n        }\n\n        // Save to database\n        const { data: saved, error: saveError } = await supabase\n          .from('study_materials')\n          .insert({\n            notebook_id: notebookId,\n            type: 'study_guide',\n            data: resultData,\n            source_ids: sourceIdArray,\n            model_used: 'gemini-2.0-flash-exp',\n            cost_usd: 0.002,\n          })\n          .select()\n          .single()\n\n        if (saveError) {\n          console.error('Save study guide error:', saveError)\n        }\n\n        return NextResponse.json({\n          data: resultData,\n          material_id: saved?.id,\n          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.002 },\n        })\n      } catch (error) {\n        console.error('Study guide generation error:', error)\n        return NextResponse.json({\n          error: 'Failed to generate study guide. Please try again.'\n        }, { status: 500 })\n      }\n    }\n\n    if (type === 'faq') {\n      try {\n        const faq = await generateFAQ(truncatedContent, count || 8)\n\n        const resultData = {\n          faq,\n          source_count: sources.length,\n        }\n\n        // Save to database\n        const { data: saved, error: saveError } = await supabase\n          .from('study_materials')\n          .insert({\n            notebook_id: notebookId,\n            type: 'faq',\n            data: resultData,\n            source_ids: sourceIdArray,\n            model_used: 'gemini-2.0-flash-exp',\n            cost_usd: 0.001,\n          })\n          .select()\n          .single()\n\n        if (saveError) {\n          console.error('Save FAQ error:', saveError)\n        }\n\n        return NextResponse.json({\n          data: resultData,\n          material_id: saved?.id,\n          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n        })\n      } catch (error) {\n        console.error('FAQ generation error:', error)\n        return NextResponse.json({\n          error: 'Failed to generate FAQ. Please try again.'\n        }, { status: 500 })\n      }\n    }\n\n    if (type === 'mind-map') {\n      try {\n        const mindMap = await generateMindMap(truncatedContent)\n\n        const resultData = {\n          ...mindMap,\n          source_count: sources.length,\n        }\n\n        // Save to database\n        const { data: saved, error: saveError } = await supabase\n          .from('study_materials')\n          .insert({\n            notebook_id: notebookId,\n            type: 'mind_map',\n            data: resultData,\n            source_ids: sourceIdArray,\n            model_used: 'gemini-2.0-flash-exp',\n            cost_usd: 0.001,\n          })\n          .select()\n          .single()\n\n        if (saveError) {\n          console.error('Save mind map error:', saveError)\n        }\n\n        return NextResponse.json({\n          data: resultData,\n          material_id: saved?.id,\n          usage: { model_used: 'gemini-2.0-flash-exp', cost_usd: 0.001 },\n        })\n      } catch (error) {\n        console.error('Mind map generation error:', error)\n        return NextResponse.json({\n          error: 'Failed to generate mind map. Please try again.'\n        }, { status: 500 })\n      }\n    }\n\n    return NextResponse.json({ error: 'Invalid study type' }, { status: 400 })\n  } catch (error) {\n    console.error('Generate study materials error:', error)\n    return NextResponse.json({ error: 'Failed to generate study materials' }, { status: 500 })\n  }\n}\n","numLines":413,"startLine":1,"totalLines":413}}}
{"parentUuid":"0db8f82e-3396-4ff8-acb0-7bd4932b653f","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M7e8mEBDRMoJhgpGow14F2","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Now let me check the main page and component structures to understand the UI layer:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":17389,"cache_read_input_tokens":49067,"cache_creation":{"ephemeral_5m_input_tokens":17389,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavqMb2ZBoM2q65UounX","type":"assistant","uuid":"656b87bc-e18d-4856-963a-01f7f3a82168","timestamp":"2025-12-29T11:50:54.317Z"}
{"parentUuid":"656b87bc-e18d-4856-963a-01f7f3a82168","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M7e8mEBDRMoJhgpGow14F2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TpS88ug2TH6Jg55z2KfXe3","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/page.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":17389,"cache_read_input_tokens":49067,"cache_creation":{"ephemeral_5m_input_tokens":17389,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavqMb2ZBoM2q65UounX","type":"assistant","uuid":"c9c54d2a-2a47-477c-ae9a-8856af06bec7","timestamp":"2025-12-29T11:50:55.415Z"}
{"parentUuid":"c9c54d2a-2a47-477c-ae9a-8856af06bec7","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01M7e8mEBDRMoJhgpGow14F2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SZqbfVx4nUGWZ3CbnVrnVu","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/panels/three-panel-layout.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":17389,"cache_read_input_tokens":49067,"cache_creation":{"ephemeral_5m_input_tokens":17389,"ephemeral_1h_input_tokens":0},"output_tokens":178,"service_tier":"standard"}},"requestId":"req_011CWavqMb2ZBoM2q65UounX","type":"assistant","uuid":"55db3244-36a4-4143-a3e3-5681531d60b5","timestamp":"2025-12-29T11:50:55.574Z"}
{"parentUuid":"55db3244-36a4-4143-a3e3-5681531d60b5","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TpS88ug2TH6Jg55z2KfXe3","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useEffect, useState, useMemo } from 'react'\n     4→import { motion, AnimatePresence } from 'framer-motion'\n     5→import { createClient, Notebook } from '@/lib/supabase'\n     6→import { Button } from '@/components/ui/button'\n     7→import { Input } from '@/components/ui/input'\n     8→import { Textarea } from '@/components/ui/textarea'\n     9→import {\n    10→  Dialog,\n    11→  DialogContent,\n    12→  DialogDescription,\n    13→  DialogFooter,\n    14→  DialogHeader,\n    15→  DialogTitle,\n    16→} from '@/components/ui/dialog'\n    17→import { Plus, BookOpen, Loader2, Sparkles } from 'lucide-react'\n    18→import { useRouter } from 'next/navigation'\n    19→import { toast } from 'sonner'\n    20→import { User } from '@supabase/supabase-js'\n    21→import { DashboardHeader } from '@/components/dashboard/header'\n    22→import { DashboardTabs } from '@/components/dashboard/tabs'\n    23→import { FeaturedCarousel } from '@/components/dashboard/featured-carousel'\n    24→import { NotebookCard, CreateNotebookCard } from '@/components/dashboard/notebook-card'\n    25→\n    26→const EMOJI_OPTIONS = ['📚', '🔬', '💡', '🎯', '📊', '🚀', '💻', '🎨', '📝', '🔍', '🧠', '⚡']\n    27→\n    28→export default function Dashboard() {\n    29→  const [user, setUser] = useState<User | null>(null)\n    30→  const [notebooks, setNotebooks] = useState<Notebook[]>([])\n    31→  const [loading, setLoading] = useState(true)\n    32→  const [creating, setCreating] = useState(false)\n    33→  const [newNotebookName, setNewNotebookName] = useState('')\n    34→  const [newNotebookDescription, setNewNotebookDescription] = useState('')\n    35→  const [selectedEmoji, setSelectedEmoji] = useState('📚')\n    36→  const [dialogOpen, setDialogOpen] = useState(false)\n    37→  const [activeTab, setActiveTab] = useState('recent')\n    38→  const [searchQuery, setSearchQuery] = useState('')\n    39→  const router = useRouter()\n    40→  const supabase = createClient()\n    41→\n    42→  useEffect(() => {\n    43→    const checkUser = async () => {\n    44→      const { data: { user } } = await supabase.auth.getUser()\n    45→      if (!user) {\n    46→        router.push('/auth/login')\n    47→        return\n    48→      }\n    49→      setUser(user)\n    50→      fetchNotebooks()\n    51→    }\n    52→    checkUser()\n    53→  }, [])\n    54→\n    55→  const fetchNotebooks = async () => {\n    56→    setLoading(true)\n    57→    const { data, error } = await supabase\n    58→      .from('notebooks')\n    59→      .select('*')\n    60→      .order('created_at', { ascending: false })\n    61→\n    62→    if (error) {\n    63→      toast.error('Failed to load notebooks')\n    64→    } else {\n    65→      setNotebooks(data || [])\n    66→    }\n    67→    setLoading(false)\n    68→  }\n    69→\n    70→  const createNotebook = async () => {\n    71→    if (!newNotebookName.trim()) return\n    72→\n    73→    setCreating(true)\n    74→    const { data, error } = await supabase\n    75→      .from('notebooks')\n    76→      .insert({\n    77→        name: newNotebookName,\n    78→        description: newNotebookDescription || null,\n    79→        emoji: selectedEmoji,\n    80→        user_id: user?.id\n    81→      })\n    82→      .select()\n    83→      .single()\n    84→\n    85→    if (error) {\n    86→      toast.error('Failed to create notebook')\n    87→    } else {\n    88→      toast.success('Notebook created!')\n    89→      setNotebooks([data, ...notebooks])\n    90→      resetDialog()\n    91→      router.push(`/notebooks/${data.id}`)\n    92→    }\n    93→    setCreating(false)\n    94→  }\n    95→\n    96→  const resetDialog = () => {\n    97→    setNewNotebookName('')\n    98→    setNewNotebookDescription('')\n    99→    setSelectedEmoji('📚')\n   100→    setDialogOpen(false)\n   101→  }\n   102→\n   103→  const handleLogout = async () => {\n   104→    await supabase.auth.signOut()\n   105→    router.push('/auth/login')\n   106→  }\n   107→\n   108→  const deleteNotebook = async (id: string) => {\n   109→    const { error } = await supabase\n   110→      .from('notebooks')\n   111→      .delete()\n   112→      .eq('id', id)\n   113→\n   114→    if (error) {\n   115→      toast.error('Failed to delete notebook')\n   116→    } else {\n   117→      setNotebooks(notebooks.filter(n => n.id !== id))\n   118→      toast.success('Notebook deleted')\n   119→    }\n   120→  }\n   121→\n   122→  const toggleFeatured = async (id: string) => {\n   123→    const notebook = notebooks.find(n => n.id === id)\n   124→    if (!notebook) return\n   125→\n   126→    const { error } = await supabase\n   127→      .from('notebooks')\n   128→      .update({ is_featured: !notebook.is_featured })\n   129→      .eq('id', id)\n   130→\n   131→    if (error) {\n   132→      toast.error('Failed to update notebook')\n   133→    } else {\n   134→      setNotebooks(notebooks.map(n =>\n   135→        n.id === id ? { ...n, is_featured: !n.is_featured } : n\n   136→      ))\n   137→    }\n   138→  }\n   139→\n   140→  const formatLastEdited = (date: string) => {\n   141→    const now = new Date()\n   142→    const edited = new Date(date)\n   143→    const diffMs = now.getTime() - edited.getTime()\n   144→    const diffMins = Math.floor(diffMs / 60000)\n   145→    const diffHours = Math.floor(diffMins / 60)\n   146→    const diffDays = Math.floor(diffHours / 24)\n   147→\n   148→    if (diffMins < 1) return 'just now'\n   149→    if (diffMins < 60) return `${diffMins}m ago`\n   150→    if (diffHours < 24) return `${diffHours}h ago`\n   151→    if (diffDays < 7) return `${diffDays}d ago`\n   152→    return edited.toLocaleDateString()\n   153→  }\n   154→\n   155→  const filteredNotebooks = useMemo(() => {\n   156→    let filtered = notebooks\n   157→\n   158→    // Apply search filter\n   159→    if (searchQuery) {\n   160→      const query = searchQuery.toLowerCase()\n   161→      filtered = filtered.filter(\n   162→        n => n.name.toLowerCase().includes(query) ||\n   163→             n.description?.toLowerCase().includes(query)\n   164→      )\n   165→    }\n   166→\n   167→    // Apply tab filter\n   168→    if (activeTab === 'featured') {\n   169→      filtered = filtered.filter(n => n.is_featured)\n   170→    } else if (activeTab === 'archived') {\n   171→      filtered = filtered.filter(n => n.is_archived)\n   172→    } else {\n   173→      // Recent: exclude archived\n   174→      filtered = filtered.filter(n => !n.is_archived)\n   175→    }\n   176→\n   177→    return filtered\n   178→  }, [notebooks, searchQuery, activeTab])\n   179→\n   180→  const featuredNotebooks = useMemo(() =>\n   181→    notebooks.filter(n => n.is_featured && !n.is_archived),\n   182→    [notebooks]\n   183→  )\n   184→\n   185→  if (loading) {\n   186→    return (\n   187→      <div className=\"min-h-screen flex items-center justify-center bg-[var(--bg-primary)]\">\n   188→        <motion.div\n   189→          initial={{ opacity: 0, scale: 0.9 }}\n   190→          animate={{ opacity: 1, scale: 1 }}\n   191→          className=\"flex flex-col items-center gap-4\"\n   192→        >\n   193→          <div className=\"w-16 h-16 rounded-2xl gradient-primary flex items-center justify-center animate-pulse\">\n   194→            <Sparkles className=\"h-8 w-8 text-white\" />\n   195→          </div>\n   196→          <Loader2 className=\"h-6 w-6 animate-spin text-[var(--accent-primary)]\" />\n   197→        </motion.div>\n   198→      </div>\n   199→    )\n   200→  }\n   201→\n   202→  return (\n   203→    <div className=\"min-h-screen bg-[var(--bg-primary)]\">\n   204→      <DashboardHeader\n   205→        user={user}\n   206→        searchQuery={searchQuery}\n   207→        onSearchChange={setSearchQuery}\n   208→        onLogout={handleLogout}\n   209→      />\n   210→\n   211→      <main className=\"max-w-7xl mx-auto px-6 py-8\">\n   212→        {/* Featured Section */}\n   213→        {activeTab === 'recent' && featuredNotebooks.length > 0 && (\n   214→          <motion.div\n   215→            initial={{ opacity: 0, y: 20 }}\n   216→            animate={{ opacity: 1, y: 0 }}\n   217→            className=\"mb-8\"\n   218→          >\n   219→            <FeaturedCarousel\n   220→              notebooks={featuredNotebooks.map(n => ({\n   221→                id: n.id,\n   222→                emoji: n.emoji,\n   223→                name: n.name,\n   224→                sourceCount: n.source_count || 0,\n   225→                description: n.description,\n   226→              }))}\n   227→              onOpen={(id) => router.push(`/notebooks/${id}`)}\n   228→            />\n   229→          </motion.div>\n   230→        )}\n   231→\n   232→        {/* Section Header */}\n   233→        <motion.div\n   234→          initial={{ opacity: 0, y: 20 }}\n   235→          animate={{ opacity: 1, y: 0 }}\n   236→          transition={{ delay: 0.1 }}\n   237→          className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6\"\n   238→        >\n   239→          <div className=\"flex items-center gap-4\">\n   240→            <DashboardTabs activeTab={activeTab} onTabChange={setActiveTab} />\n   241→          </div>\n   242→\n   243→          <Button\n   244→            onClick={() => setDialogOpen(true)}\n   245→            className=\"h-10 px-4 rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white font-medium btn-hover\"\n   246→          >\n   247→            <Plus className=\"h-4 w-4 mr-2\" />\n   248→            New Notebook\n   249→          </Button>\n   250→        </motion.div>\n   251→\n   252→        {/* Notebooks Grid */}\n   253→        <AnimatePresence mode=\"wait\">\n   254→          {filteredNotebooks.length === 0 ? (\n   255→            <motion.div\n   256→              key=\"empty\"\n   257→              initial={{ opacity: 0, y: 20 }}\n   258→              animate={{ opacity: 1, y: 0 }}\n   259→              exit={{ opacity: 0, y: -20 }}\n   260→              className=\"flex flex-col items-center justify-center py-20\"\n   261→            >\n   262→              <div className=\"w-20 h-20 rounded-2xl bg-[var(--bg-tertiary)] flex items-center justify-center mb-6\">\n   263→                <BookOpen className=\"h-10 w-10 text-[var(--text-tertiary)]\" />\n   264→              </div>\n   265→              <h3 className=\"text-xl font-semibold text-[var(--text-primary)] mb-2\">\n   266→                {searchQuery ? 'No notebooks found' : 'No notebooks yet'}\n   267→              </h3>\n   268→              <p className=\"text-[var(--text-secondary)] mb-6 text-center max-w-sm\">\n   269→                {searchQuery\n   270→                  ? 'Try a different search term'\n   271→                  : 'Create your first notebook to start researching with AI-powered insights'\n   272→                }\n   273→              </p>\n   274→              {!searchQuery && (\n   275→                <Button\n   276→                  onClick={() => setDialogOpen(true)}\n   277→                  className=\"h-11 px-6 rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white font-medium btn-hover\"\n   278→                >\n   279→                  <Plus className=\"h-4 w-4 mr-2\" />\n   280→                  Create Notebook\n   281→                </Button>\n   282→              )}\n   283→            </motion.div>\n   284→          ) : (\n   285→            <motion.div\n   286→              key=\"grid\"\n   287→              initial={{ opacity: 0 }}\n   288→              animate={{ opacity: 1 }}\n   289→              exit={{ opacity: 0 }}\n   290→              className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\"\n   291→            >\n   292→              <CreateNotebookCard onClick={() => setDialogOpen(true)} />\n   293→\n   294→              {filteredNotebooks.map((notebook, index) => (\n   295→                <motion.div\n   296→                  key={notebook.id}\n   297→                  initial={{ opacity: 0, y: 20 }}\n   298→                  animate={{ opacity: 1, y: 0 }}\n   299→                  transition={{ delay: index * 0.05 }}\n   300→                >\n   301→                  <NotebookCard\n   302→                    id={notebook.id}\n   303→                    emoji={notebook.emoji}\n   304→                    name={notebook.name}\n   305→                    sourceCount={notebook.source_count || 0}\n   306→                    description={notebook.description}\n   307→                    lastEdited={formatLastEdited(notebook.updated_at || notebook.created_at)}\n   308→                    isFeatured={notebook.is_featured}\n   309→                    onOpen={(id) => router.push(`/notebooks/${id}`)}\n   310→                    onDelete={deleteNotebook}\n   311→                    onToggleFeatured={toggleFeatured}\n   312→                  />\n   313→                </motion.div>\n   314→              ))}\n   315→            </motion.div>\n   316→          )}\n   317→        </AnimatePresence>\n   318→      </main>\n   319→\n   320→      {/* Create Notebook Dialog */}\n   321→      <Dialog open={dialogOpen} onOpenChange={(open) => !open && resetDialog()}>\n   322→        <DialogContent className=\"sm:max-w-md bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n   323→          <DialogHeader>\n   324→            <DialogTitle className=\"text-[var(--text-primary)]\">Create New Notebook</DialogTitle>\n   325→            <DialogDescription className=\"text-[var(--text-secondary)]\">\n   326→              Start a new research project with AI-powered insights.\n   327→            </DialogDescription>\n   328→          </DialogHeader>\n   329→\n   330→          <div className=\"space-y-4 py-4\">\n   331→            {/* Emoji Picker */}\n   332→            <div className=\"space-y-2\">\n   333→              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Icon</label>\n   334→              <div className=\"flex flex-wrap gap-2\">\n   335→                {EMOJI_OPTIONS.map((emoji) => (\n   336→                  <button\n   337→                    key={emoji}\n   338→                    type=\"button\"\n   339→                    onClick={() => setSelectedEmoji(emoji)}\n   340→                    className={`\n   341→                      w-10 h-10 rounded-xl text-xl flex items-center justify-center transition-all\n   342→                      ${selectedEmoji === emoji\n   343→                        ? 'bg-[var(--accent-primary)]/20 ring-2 ring-[var(--accent-primary)]'\n   344→                        : 'bg-[var(--bg-tertiary)] hover:bg-[var(--bg-surface)]'\n   345→                      }\n   346→                    `}\n   347→                  >\n   348→                    {emoji}\n   349→                  </button>\n   350→                ))}\n   351→              </div>\n   352→            </div>\n   353→\n   354→            {/* Name Input */}\n   355→            <div className=\"space-y-2\">\n   356→              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Name</label>\n   357→              <Input\n   358→                placeholder=\"My Research Project\"\n   359→                value={newNotebookName}\n   360→                onChange={(e) => setNewNotebookName(e.target.value)}\n   361→                onKeyDown={(e) => e.key === 'Enter' && createNotebook()}\n   362→                className=\"h-11 bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-xl\"\n   363→              />\n   364→            </div>\n   365→\n   366→            {/* Description Input */}\n   367→            <div className=\"space-y-2\">\n   368→              <label className=\"text-sm font-medium text-[var(--text-primary)]\">\n   369→                Description <span className=\"text-[var(--text-tertiary)]\">(optional)</span>\n   370→              </label>\n   371→              <Textarea\n   372→                placeholder=\"What is this notebook about?\"\n   373→                value={newNotebookDescription}\n   374→                onChange={(e) => setNewNotebookDescription(e.target.value)}\n   375→                className=\"resize-none bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-xl\"\n   376→                rows={3}\n   377→              />\n   378→            </div>\n   379→          </div>\n   380→\n   381→          <DialogFooter className=\"gap-2\">\n   382→            <Button\n   383→              variant=\"outline\"\n   384→              onClick={resetDialog}\n   385→              className=\"rounded-xl border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n   386→            >\n   387→              Cancel\n   388→            </Button>\n   389→            <Button\n   390→              onClick={createNotebook}\n   391→              disabled={creating || !newNotebookName.trim()}\n   392→              className=\"rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white btn-hover\"\n   393→            >\n   394→              {creating && <Loader2 className=\"h-4 w-4 mr-2 animate-spin\" />}\n   395→              Create Notebook\n   396→            </Button>\n   397→          </DialogFooter>\n   398→        </DialogContent>\n   399→      </Dialog>\n   400→    </div>\n   401→  )\n   402→}\n   403→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b66a84f2-4b9c-481b-b3a0-b143fa5a93e6","timestamp":"2025-12-29T11:50:55.631Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/page.tsx","content":"'use client'\n\nimport { useEffect, useState, useMemo } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { createClient, Notebook } from '@/lib/supabase'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport { Textarea } from '@/components/ui/textarea'\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog'\nimport { Plus, BookOpen, Loader2, Sparkles } from 'lucide-react'\nimport { useRouter } from 'next/navigation'\nimport { toast } from 'sonner'\nimport { User } from '@supabase/supabase-js'\nimport { DashboardHeader } from '@/components/dashboard/header'\nimport { DashboardTabs } from '@/components/dashboard/tabs'\nimport { FeaturedCarousel } from '@/components/dashboard/featured-carousel'\nimport { NotebookCard, CreateNotebookCard } from '@/components/dashboard/notebook-card'\n\nconst EMOJI_OPTIONS = ['📚', '🔬', '💡', '🎯', '📊', '🚀', '💻', '🎨', '📝', '🔍', '🧠', '⚡']\n\nexport default function Dashboard() {\n  const [user, setUser] = useState<User | null>(null)\n  const [notebooks, setNotebooks] = useState<Notebook[]>([])\n  const [loading, setLoading] = useState(true)\n  const [creating, setCreating] = useState(false)\n  const [newNotebookName, setNewNotebookName] = useState('')\n  const [newNotebookDescription, setNewNotebookDescription] = useState('')\n  const [selectedEmoji, setSelectedEmoji] = useState('📚')\n  const [dialogOpen, setDialogOpen] = useState(false)\n  const [activeTab, setActiveTab] = useState('recent')\n  const [searchQuery, setSearchQuery] = useState('')\n  const router = useRouter()\n  const supabase = createClient()\n\n  useEffect(() => {\n    const checkUser = async () => {\n      const { data: { user } } = await supabase.auth.getUser()\n      if (!user) {\n        router.push('/auth/login')\n        return\n      }\n      setUser(user)\n      fetchNotebooks()\n    }\n    checkUser()\n  }, [])\n\n  const fetchNotebooks = async () => {\n    setLoading(true)\n    const { data, error } = await supabase\n      .from('notebooks')\n      .select('*')\n      .order('created_at', { ascending: false })\n\n    if (error) {\n      toast.error('Failed to load notebooks')\n    } else {\n      setNotebooks(data || [])\n    }\n    setLoading(false)\n  }\n\n  const createNotebook = async () => {\n    if (!newNotebookName.trim()) return\n\n    setCreating(true)\n    const { data, error } = await supabase\n      .from('notebooks')\n      .insert({\n        name: newNotebookName,\n        description: newNotebookDescription || null,\n        emoji: selectedEmoji,\n        user_id: user?.id\n      })\n      .select()\n      .single()\n\n    if (error) {\n      toast.error('Failed to create notebook')\n    } else {\n      toast.success('Notebook created!')\n      setNotebooks([data, ...notebooks])\n      resetDialog()\n      router.push(`/notebooks/${data.id}`)\n    }\n    setCreating(false)\n  }\n\n  const resetDialog = () => {\n    setNewNotebookName('')\n    setNewNotebookDescription('')\n    setSelectedEmoji('📚')\n    setDialogOpen(false)\n  }\n\n  const handleLogout = async () => {\n    await supabase.auth.signOut()\n    router.push('/auth/login')\n  }\n\n  const deleteNotebook = async (id: string) => {\n    const { error } = await supabase\n      .from('notebooks')\n      .delete()\n      .eq('id', id)\n\n    if (error) {\n      toast.error('Failed to delete notebook')\n    } else {\n      setNotebooks(notebooks.filter(n => n.id !== id))\n      toast.success('Notebook deleted')\n    }\n  }\n\n  const toggleFeatured = async (id: string) => {\n    const notebook = notebooks.find(n => n.id === id)\n    if (!notebook) return\n\n    const { error } = await supabase\n      .from('notebooks')\n      .update({ is_featured: !notebook.is_featured })\n      .eq('id', id)\n\n    if (error) {\n      toast.error('Failed to update notebook')\n    } else {\n      setNotebooks(notebooks.map(n =>\n        n.id === id ? { ...n, is_featured: !n.is_featured } : n\n      ))\n    }\n  }\n\n  const formatLastEdited = (date: string) => {\n    const now = new Date()\n    const edited = new Date(date)\n    const diffMs = now.getTime() - edited.getTime()\n    const diffMins = Math.floor(diffMs / 60000)\n    const diffHours = Math.floor(diffMins / 60)\n    const diffDays = Math.floor(diffHours / 24)\n\n    if (diffMins < 1) return 'just now'\n    if (diffMins < 60) return `${diffMins}m ago`\n    if (diffHours < 24) return `${diffHours}h ago`\n    if (diffDays < 7) return `${diffDays}d ago`\n    return edited.toLocaleDateString()\n  }\n\n  const filteredNotebooks = useMemo(() => {\n    let filtered = notebooks\n\n    // Apply search filter\n    if (searchQuery) {\n      const query = searchQuery.toLowerCase()\n      filtered = filtered.filter(\n        n => n.name.toLowerCase().includes(query) ||\n             n.description?.toLowerCase().includes(query)\n      )\n    }\n\n    // Apply tab filter\n    if (activeTab === 'featured') {\n      filtered = filtered.filter(n => n.is_featured)\n    } else if (activeTab === 'archived') {\n      filtered = filtered.filter(n => n.is_archived)\n    } else {\n      // Recent: exclude archived\n      filtered = filtered.filter(n => !n.is_archived)\n    }\n\n    return filtered\n  }, [notebooks, searchQuery, activeTab])\n\n  const featuredNotebooks = useMemo(() =>\n    notebooks.filter(n => n.is_featured && !n.is_archived),\n    [notebooks]\n  )\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-[var(--bg-primary)]\">\n        <motion.div\n          initial={{ opacity: 0, scale: 0.9 }}\n          animate={{ opacity: 1, scale: 1 }}\n          className=\"flex flex-col items-center gap-4\"\n        >\n          <div className=\"w-16 h-16 rounded-2xl gradient-primary flex items-center justify-center animate-pulse\">\n            <Sparkles className=\"h-8 w-8 text-white\" />\n          </div>\n          <Loader2 className=\"h-6 w-6 animate-spin text-[var(--accent-primary)]\" />\n        </motion.div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"min-h-screen bg-[var(--bg-primary)]\">\n      <DashboardHeader\n        user={user}\n        searchQuery={searchQuery}\n        onSearchChange={setSearchQuery}\n        onLogout={handleLogout}\n      />\n\n      <main className=\"max-w-7xl mx-auto px-6 py-8\">\n        {/* Featured Section */}\n        {activeTab === 'recent' && featuredNotebooks.length > 0 && (\n          <motion.div\n            initial={{ opacity: 0, y: 20 }}\n            animate={{ opacity: 1, y: 0 }}\n            className=\"mb-8\"\n          >\n            <FeaturedCarousel\n              notebooks={featuredNotebooks.map(n => ({\n                id: n.id,\n                emoji: n.emoji,\n                name: n.name,\n                sourceCount: n.source_count || 0,\n                description: n.description,\n              }))}\n              onOpen={(id) => router.push(`/notebooks/${id}`)}\n            />\n          </motion.div>\n        )}\n\n        {/* Section Header */}\n        <motion.div\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          transition={{ delay: 0.1 }}\n          className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-4 mb-6\"\n        >\n          <div className=\"flex items-center gap-4\">\n            <DashboardTabs activeTab={activeTab} onTabChange={setActiveTab} />\n          </div>\n\n          <Button\n            onClick={() => setDialogOpen(true)}\n            className=\"h-10 px-4 rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white font-medium btn-hover\"\n          >\n            <Plus className=\"h-4 w-4 mr-2\" />\n            New Notebook\n          </Button>\n        </motion.div>\n\n        {/* Notebooks Grid */}\n        <AnimatePresence mode=\"wait\">\n          {filteredNotebooks.length === 0 ? (\n            <motion.div\n              key=\"empty\"\n              initial={{ opacity: 0, y: 20 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -20 }}\n              className=\"flex flex-col items-center justify-center py-20\"\n            >\n              <div className=\"w-20 h-20 rounded-2xl bg-[var(--bg-tertiary)] flex items-center justify-center mb-6\">\n                <BookOpen className=\"h-10 w-10 text-[var(--text-tertiary)]\" />\n              </div>\n              <h3 className=\"text-xl font-semibold text-[var(--text-primary)] mb-2\">\n                {searchQuery ? 'No notebooks found' : 'No notebooks yet'}\n              </h3>\n              <p className=\"text-[var(--text-secondary)] mb-6 text-center max-w-sm\">\n                {searchQuery\n                  ? 'Try a different search term'\n                  : 'Create your first notebook to start researching with AI-powered insights'\n                }\n              </p>\n              {!searchQuery && (\n                <Button\n                  onClick={() => setDialogOpen(true)}\n                  className=\"h-11 px-6 rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white font-medium btn-hover\"\n                >\n                  <Plus className=\"h-4 w-4 mr-2\" />\n                  Create Notebook\n                </Button>\n              )}\n            </motion.div>\n          ) : (\n            <motion.div\n              key=\"grid\"\n              initial={{ opacity: 0 }}\n              animate={{ opacity: 1 }}\n              exit={{ opacity: 0 }}\n              className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\"\n            >\n              <CreateNotebookCard onClick={() => setDialogOpen(true)} />\n\n              {filteredNotebooks.map((notebook, index) => (\n                <motion.div\n                  key={notebook.id}\n                  initial={{ opacity: 0, y: 20 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  transition={{ delay: index * 0.05 }}\n                >\n                  <NotebookCard\n                    id={notebook.id}\n                    emoji={notebook.emoji}\n                    name={notebook.name}\n                    sourceCount={notebook.source_count || 0}\n                    description={notebook.description}\n                    lastEdited={formatLastEdited(notebook.updated_at || notebook.created_at)}\n                    isFeatured={notebook.is_featured}\n                    onOpen={(id) => router.push(`/notebooks/${id}`)}\n                    onDelete={deleteNotebook}\n                    onToggleFeatured={toggleFeatured}\n                  />\n                </motion.div>\n              ))}\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </main>\n\n      {/* Create Notebook Dialog */}\n      <Dialog open={dialogOpen} onOpenChange={(open) => !open && resetDialog()}>\n        <DialogContent className=\"sm:max-w-md bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n          <DialogHeader>\n            <DialogTitle className=\"text-[var(--text-primary)]\">Create New Notebook</DialogTitle>\n            <DialogDescription className=\"text-[var(--text-secondary)]\">\n              Start a new research project with AI-powered insights.\n            </DialogDescription>\n          </DialogHeader>\n\n          <div className=\"space-y-4 py-4\">\n            {/* Emoji Picker */}\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Icon</label>\n              <div className=\"flex flex-wrap gap-2\">\n                {EMOJI_OPTIONS.map((emoji) => (\n                  <button\n                    key={emoji}\n                    type=\"button\"\n                    onClick={() => setSelectedEmoji(emoji)}\n                    className={`\n                      w-10 h-10 rounded-xl text-xl flex items-center justify-center transition-all\n                      ${selectedEmoji === emoji\n                        ? 'bg-[var(--accent-primary)]/20 ring-2 ring-[var(--accent-primary)]'\n                        : 'bg-[var(--bg-tertiary)] hover:bg-[var(--bg-surface)]'\n                      }\n                    `}\n                  >\n                    {emoji}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Name Input */}\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Name</label>\n              <Input\n                placeholder=\"My Research Project\"\n                value={newNotebookName}\n                onChange={(e) => setNewNotebookName(e.target.value)}\n                onKeyDown={(e) => e.key === 'Enter' && createNotebook()}\n                className=\"h-11 bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-xl\"\n              />\n            </div>\n\n            {/* Description Input */}\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium text-[var(--text-primary)]\">\n                Description <span className=\"text-[var(--text-tertiary)]\">(optional)</span>\n              </label>\n              <Textarea\n                placeholder=\"What is this notebook about?\"\n                value={newNotebookDescription}\n                onChange={(e) => setNewNotebookDescription(e.target.value)}\n                className=\"resize-none bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-xl\"\n                rows={3}\n              />\n            </div>\n          </div>\n\n          <DialogFooter className=\"gap-2\">\n            <Button\n              variant=\"outline\"\n              onClick={resetDialog}\n              className=\"rounded-xl border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n            >\n              Cancel\n            </Button>\n            <Button\n              onClick={createNotebook}\n              disabled={creating || !newNotebookName.trim()}\n              className=\"rounded-xl bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white btn-hover\"\n            >\n              {creating && <Loader2 className=\"h-4 w-4 mr-2 animate-spin\" />}\n              Create Notebook\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  )\n}\n","numLines":403,"startLine":1,"totalLines":403}}}
{"parentUuid":"b66a84f2-4b9c-481b-b3a0-b143fa5a93e6","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SZqbfVx4nUGWZ3CbnVrnVu","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useState, useRef, useCallback, useEffect } from 'react'\n     4→import { motion, AnimatePresence } from 'framer-motion'\n     5→import { PanelLeftOpen, PanelRightOpen } from 'lucide-react'\n     6→import { Button } from '@/components/ui/button'\n     7→\n     8→interface ThreePanelLayoutProps {\n     9→  leftPanel: React.ReactNode\n    10→  centerPanel: React.ReactNode\n    11→  rightPanel: React.ReactNode\n    12→  leftPanelTitle?: string\n    13→  rightPanelTitle?: string\n    14→  defaultLeftWidth?: number\n    15→  defaultRightWidth?: number\n    16→  minLeftWidth?: number\n    17→  minRightWidth?: number\n    18→  maxLeftWidth?: number\n    19→  maxRightWidth?: number\n    20→}\n    21→\n    22→export function ThreePanelLayout({\n    23→  leftPanel,\n    24→  centerPanel,\n    25→  rightPanel,\n    26→  leftPanelTitle = 'Sources',\n    27→  rightPanelTitle = 'Studio',\n    28→  defaultLeftWidth = 280,\n    29→  defaultRightWidth = 340,\n    30→  minLeftWidth = 200,\n    31→  minRightWidth = 280,\n    32→  maxLeftWidth = 400,\n    33→  maxRightWidth = 480,\n    34→}: ThreePanelLayoutProps) {\n    35→  const [leftWidth, setLeftWidth] = useState(defaultLeftWidth)\n    36→  const [rightWidth, setRightWidth] = useState(defaultRightWidth)\n    37→  const [leftCollapsed, setLeftCollapsed] = useState(false)\n    38→  const [rightCollapsed, setRightCollapsed] = useState(false)\n    39→  const [isResizingLeft, setIsResizingLeft] = useState(false)\n    40→  const [isResizingRight, setIsResizingRight] = useState(false)\n    41→\n    42→  const containerRef = useRef<HTMLDivElement>(null)\n    43→\n    44→  const handleMouseMove = useCallback(\n    45→    (e: MouseEvent) => {\n    46→      if (!containerRef.current) return\n    47→\n    48→      const containerRect = containerRef.current.getBoundingClientRect()\n    49→\n    50→      if (isResizingLeft) {\n    51→        const newWidth = e.clientX - containerRect.left\n    52→        if (newWidth >= minLeftWidth && newWidth <= maxLeftWidth) {\n    53→          setLeftWidth(newWidth)\n    54→        }\n    55→      }\n    56→\n    57→      if (isResizingRight) {\n    58→        const newWidth = containerRect.right - e.clientX\n    59→        if (newWidth >= minRightWidth && newWidth <= maxRightWidth) {\n    60→          setRightWidth(newWidth)\n    61→        }\n    62→      }\n    63→    },\n    64→    [isResizingLeft, isResizingRight, minLeftWidth, maxLeftWidth, minRightWidth, maxRightWidth]\n    65→  )\n    66→\n    67→  const handleMouseUp = useCallback(() => {\n    68→    setIsResizingLeft(false)\n    69→    setIsResizingRight(false)\n    70→    document.body.style.cursor = ''\n    71→    document.body.style.userSelect = ''\n    72→  }, [])\n    73→\n    74→  useEffect(() => {\n    75→    if (isResizingLeft || isResizingRight) {\n    76→      document.addEventListener('mousemove', handleMouseMove)\n    77→      document.addEventListener('mouseup', handleMouseUp)\n    78→      document.body.style.cursor = 'col-resize'\n    79→      document.body.style.userSelect = 'none'\n    80→    }\n    81→\n    82→    return () => {\n    83→      document.removeEventListener('mousemove', handleMouseMove)\n    84→      document.removeEventListener('mouseup', handleMouseUp)\n    85→    }\n    86→  }, [isResizingLeft, isResizingRight, handleMouseMove, handleMouseUp])\n    87→\n    88→  return (\n    89→    <div ref={containerRef} className=\"flex h-full overflow-hidden\">\n    90→      {/* Left Panel */}\n    91→      <AnimatePresence initial={false}>\n    92→        {leftCollapsed ? (\n    93→          <motion.div\n    94→            initial={{ width: leftWidth }}\n    95→            animate={{ width: 48 }}\n    96→            exit={{ width: leftWidth }}\n    97→            transition={{ duration: 0.3, ease: 'easeOut' }}\n    98→            className=\"h-full bg-[var(--bg-secondary)] border-r border-[rgba(255,255,255,0.1)] flex flex-col items-center py-4\"\n    99→          >\n   100→            <Button\n   101→              variant=\"ghost\"\n   102→              size=\"icon\"\n   103→              onClick={() => setLeftCollapsed(false)}\n   104→              className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n   105→            >\n   106→              <PanelLeftOpen className=\"h-4 w-4\" />\n   107→            </Button>\n   108→          </motion.div>\n   109→        ) : (\n   110→          <motion.div\n   111→            initial={{ width: 48 }}\n   112→            animate={{ width: leftWidth }}\n   113→            exit={{ width: 48 }}\n   114→            transition={{ duration: 0.3, ease: 'easeOut' }}\n   115→            className=\"h-full bg-[var(--bg-secondary)] border-r border-[rgba(255,255,255,0.1)] flex flex-col\"\n   116→            style={{ minWidth: minLeftWidth }}\n   117→          >\n   118→            {/* Panel Header */}\n   119→            <div className=\"h-14 px-4 flex items-center justify-between border-b border-[rgba(255,255,255,0.1)] shrink-0\">\n   120→              <h2 className=\"font-semibold text-[var(--text-primary)]\">{leftPanelTitle}</h2>\n   121→              <Button\n   122→                variant=\"ghost\"\n   123→                size=\"icon\"\n   124→                onClick={() => setLeftCollapsed(true)}\n   125→                className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n   126→              >\n   127→                <PanelLeftOpen className=\"h-4 w-4 rotate-180\" />\n   128→              </Button>\n   129→            </div>\n   130→\n   131→            {/* Panel Content */}\n   132→            <div className=\"flex-1 overflow-hidden\">\n   133→              {leftPanel}\n   134→            </div>\n   135→          </motion.div>\n   136→        )}\n   137→      </AnimatePresence>\n   138→\n   139→      {/* Left Resize Handle */}\n   140→      {!leftCollapsed && (\n   141→        <div\n   142→          className=\"w-1 bg-transparent hover:bg-[var(--accent-primary)]/50 cursor-col-resize transition-colors shrink-0\"\n   143→          onMouseDown={() => setIsResizingLeft(true)}\n   144→        />\n   145→      )}\n   146→\n   147→      {/* Center Panel */}\n   148→      <div className=\"flex-1 min-w-0 h-full flex flex-col bg-[var(--bg-primary)] overflow-hidden\">\n   149→        {centerPanel}\n   150→      </div>\n   151→\n   152→      {/* Right Resize Handle */}\n   153→      {!rightCollapsed && (\n   154→        <div\n   155→          className=\"w-1 bg-transparent hover:bg-[var(--accent-primary)]/50 cursor-col-resize transition-colors shrink-0\"\n   156→          onMouseDown={() => setIsResizingRight(true)}\n   157→        />\n   158→      )}\n   159→\n   160→      {/* Right Panel */}\n   161→      <AnimatePresence initial={false}>\n   162→        {rightCollapsed ? (\n   163→          <motion.div\n   164→            initial={{ width: rightWidth }}\n   165→            animate={{ width: 48 }}\n   166→            exit={{ width: rightWidth }}\n   167→            transition={{ duration: 0.3, ease: 'easeOut' }}\n   168→            className=\"h-full bg-[var(--bg-secondary)] border-l border-[rgba(255,255,255,0.1)] flex flex-col items-center py-4\"\n   169→          >\n   170→            <Button\n   171→              variant=\"ghost\"\n   172→              size=\"icon\"\n   173→              onClick={() => setRightCollapsed(false)}\n   174→              className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n   175→            >\n   176→              <PanelRightOpen className=\"h-4 w-4\" />\n   177→            </Button>\n   178→          </motion.div>\n   179→        ) : (\n   180→          <motion.div\n   181→            initial={{ width: 48 }}\n   182→            animate={{ width: rightWidth }}\n   183→            exit={{ width: 48 }}\n   184→            transition={{ duration: 0.3, ease: 'easeOut' }}\n   185→            className=\"h-full bg-[var(--bg-secondary)] border-l border-[rgba(255,255,255,0.1)] flex flex-col\"\n   186→            style={{ minWidth: minRightWidth }}\n   187→          >\n   188→            {/* Panel Header */}\n   189→            <div className=\"h-14 px-4 flex items-center justify-between border-b border-[rgba(255,255,255,0.1)] shrink-0\">\n   190→              <h2 className=\"font-semibold text-[var(--text-primary)]\">{rightPanelTitle}</h2>\n   191→              <Button\n   192→                variant=\"ghost\"\n   193→                size=\"icon\"\n   194→                onClick={() => setRightCollapsed(true)}\n   195→                className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n   196→              >\n   197→                <PanelRightOpen className=\"h-4 w-4 rotate-180\" />\n   198→              </Button>\n   199→            </div>\n   200→\n   201→            {/* Panel Content */}\n   202→            <div className=\"flex-1 overflow-hidden\">\n   203→              {rightPanel}\n   204→            </div>\n   205→          </motion.div>\n   206→        )}\n   207→      </AnimatePresence>\n   208→    </div>\n   209→  )\n   210→}\n   211→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0edea0c0-029d-479b-9566-133d99f637aa","timestamp":"2025-12-29T11:50:55.632Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/components/panels/three-panel-layout.tsx","content":"'use client'\n\nimport { useState, useRef, useCallback, useEffect } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { PanelLeftOpen, PanelRightOpen } from 'lucide-react'\nimport { Button } from '@/components/ui/button'\n\ninterface ThreePanelLayoutProps {\n  leftPanel: React.ReactNode\n  centerPanel: React.ReactNode\n  rightPanel: React.ReactNode\n  leftPanelTitle?: string\n  rightPanelTitle?: string\n  defaultLeftWidth?: number\n  defaultRightWidth?: number\n  minLeftWidth?: number\n  minRightWidth?: number\n  maxLeftWidth?: number\n  maxRightWidth?: number\n}\n\nexport function ThreePanelLayout({\n  leftPanel,\n  centerPanel,\n  rightPanel,\n  leftPanelTitle = 'Sources',\n  rightPanelTitle = 'Studio',\n  defaultLeftWidth = 280,\n  defaultRightWidth = 340,\n  minLeftWidth = 200,\n  minRightWidth = 280,\n  maxLeftWidth = 400,\n  maxRightWidth = 480,\n}: ThreePanelLayoutProps) {\n  const [leftWidth, setLeftWidth] = useState(defaultLeftWidth)\n  const [rightWidth, setRightWidth] = useState(defaultRightWidth)\n  const [leftCollapsed, setLeftCollapsed] = useState(false)\n  const [rightCollapsed, setRightCollapsed] = useState(false)\n  const [isResizingLeft, setIsResizingLeft] = useState(false)\n  const [isResizingRight, setIsResizingRight] = useState(false)\n\n  const containerRef = useRef<HTMLDivElement>(null)\n\n  const handleMouseMove = useCallback(\n    (e: MouseEvent) => {\n      if (!containerRef.current) return\n\n      const containerRect = containerRef.current.getBoundingClientRect()\n\n      if (isResizingLeft) {\n        const newWidth = e.clientX - containerRect.left\n        if (newWidth >= minLeftWidth && newWidth <= maxLeftWidth) {\n          setLeftWidth(newWidth)\n        }\n      }\n\n      if (isResizingRight) {\n        const newWidth = containerRect.right - e.clientX\n        if (newWidth >= minRightWidth && newWidth <= maxRightWidth) {\n          setRightWidth(newWidth)\n        }\n      }\n    },\n    [isResizingLeft, isResizingRight, minLeftWidth, maxLeftWidth, minRightWidth, maxRightWidth]\n  )\n\n  const handleMouseUp = useCallback(() => {\n    setIsResizingLeft(false)\n    setIsResizingRight(false)\n    document.body.style.cursor = ''\n    document.body.style.userSelect = ''\n  }, [])\n\n  useEffect(() => {\n    if (isResizingLeft || isResizingRight) {\n      document.addEventListener('mousemove', handleMouseMove)\n      document.addEventListener('mouseup', handleMouseUp)\n      document.body.style.cursor = 'col-resize'\n      document.body.style.userSelect = 'none'\n    }\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n  }, [isResizingLeft, isResizingRight, handleMouseMove, handleMouseUp])\n\n  return (\n    <div ref={containerRef} className=\"flex h-full overflow-hidden\">\n      {/* Left Panel */}\n      <AnimatePresence initial={false}>\n        {leftCollapsed ? (\n          <motion.div\n            initial={{ width: leftWidth }}\n            animate={{ width: 48 }}\n            exit={{ width: leftWidth }}\n            transition={{ duration: 0.3, ease: 'easeOut' }}\n            className=\"h-full bg-[var(--bg-secondary)] border-r border-[rgba(255,255,255,0.1)] flex flex-col items-center py-4\"\n          >\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => setLeftCollapsed(false)}\n              className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n            >\n              <PanelLeftOpen className=\"h-4 w-4\" />\n            </Button>\n          </motion.div>\n        ) : (\n          <motion.div\n            initial={{ width: 48 }}\n            animate={{ width: leftWidth }}\n            exit={{ width: 48 }}\n            transition={{ duration: 0.3, ease: 'easeOut' }}\n            className=\"h-full bg-[var(--bg-secondary)] border-r border-[rgba(255,255,255,0.1)] flex flex-col\"\n            style={{ minWidth: minLeftWidth }}\n          >\n            {/* Panel Header */}\n            <div className=\"h-14 px-4 flex items-center justify-between border-b border-[rgba(255,255,255,0.1)] shrink-0\">\n              <h2 className=\"font-semibold text-[var(--text-primary)]\">{leftPanelTitle}</h2>\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                onClick={() => setLeftCollapsed(true)}\n                className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n              >\n                <PanelLeftOpen className=\"h-4 w-4 rotate-180\" />\n              </Button>\n            </div>\n\n            {/* Panel Content */}\n            <div className=\"flex-1 overflow-hidden\">\n              {leftPanel}\n            </div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Left Resize Handle */}\n      {!leftCollapsed && (\n        <div\n          className=\"w-1 bg-transparent hover:bg-[var(--accent-primary)]/50 cursor-col-resize transition-colors shrink-0\"\n          onMouseDown={() => setIsResizingLeft(true)}\n        />\n      )}\n\n      {/* Center Panel */}\n      <div className=\"flex-1 min-w-0 h-full flex flex-col bg-[var(--bg-primary)] overflow-hidden\">\n        {centerPanel}\n      </div>\n\n      {/* Right Resize Handle */}\n      {!rightCollapsed && (\n        <div\n          className=\"w-1 bg-transparent hover:bg-[var(--accent-primary)]/50 cursor-col-resize transition-colors shrink-0\"\n          onMouseDown={() => setIsResizingRight(true)}\n        />\n      )}\n\n      {/* Right Panel */}\n      <AnimatePresence initial={false}>\n        {rightCollapsed ? (\n          <motion.div\n            initial={{ width: rightWidth }}\n            animate={{ width: 48 }}\n            exit={{ width: rightWidth }}\n            transition={{ duration: 0.3, ease: 'easeOut' }}\n            className=\"h-full bg-[var(--bg-secondary)] border-l border-[rgba(255,255,255,0.1)] flex flex-col items-center py-4\"\n          >\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => setRightCollapsed(false)}\n              className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n            >\n              <PanelRightOpen className=\"h-4 w-4\" />\n            </Button>\n          </motion.div>\n        ) : (\n          <motion.div\n            initial={{ width: 48 }}\n            animate={{ width: rightWidth }}\n            exit={{ width: 48 }}\n            transition={{ duration: 0.3, ease: 'easeOut' }}\n            className=\"h-full bg-[var(--bg-secondary)] border-l border-[rgba(255,255,255,0.1)] flex flex-col\"\n            style={{ minWidth: minRightWidth }}\n          >\n            {/* Panel Header */}\n            <div className=\"h-14 px-4 flex items-center justify-between border-b border-[rgba(255,255,255,0.1)] shrink-0\">\n              <h2 className=\"font-semibold text-[var(--text-primary)]\">{rightPanelTitle}</h2>\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                onClick={() => setRightCollapsed(true)}\n                className=\"h-8 w-8 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n              >\n                <PanelRightOpen className=\"h-4 w-4 rotate-180\" />\n              </Button>\n            </div>\n\n            {/* Panel Content */}\n            <div className=\"flex-1 overflow-hidden\">\n              {rightPanel}\n            </div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  )\n}\n","numLines":211,"startLine":1,"totalLines":211}}}
{"parentUuid":"0edea0c0-029d-479b-9566-133d99f637aa","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PNYKDSZP6ZmDGWeKeZbzSh","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! Let me check one more thing - let me look at the notebook view to see how all these components tie together:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":9027,"cache_read_input_tokens":66456,"cache_creation":{"ephemeral_5m_input_tokens":9027,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavqkRxEYcvWeTVZBSEf","type":"assistant","uuid":"d84016dd-b59a-43a3-93f4-6dd88e18da66","timestamp":"2025-12-29T11:50:58.437Z"}
{"parentUuid":"d84016dd-b59a-43a3-93f4-6dd88e18da66","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01PNYKDSZP6ZmDGWeKeZbzSh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012vsqaXksL6fATXqfVzWcQN","name":"Read","input":{"file_path":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/notebooks/[id]/page.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":9027,"cache_read_input_tokens":66456,"cache_creation":{"ephemeral_5m_input_tokens":9027,"ephemeral_1h_input_tokens":0},"output_tokens":116,"service_tier":"standard"}},"requestId":"req_011CWavqkRxEYcvWeTVZBSEf","type":"assistant","uuid":"40ce07c3-b98c-4937-9397-d78006e4d7fb","timestamp":"2025-12-29T11:50:59.069Z"}
{"parentUuid":"40ce07c3-b98c-4937-9397-d78006e4d7fb","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012vsqaXksL6fATXqfVzWcQN","type":"tool_result","content":"     1→'use client'\n     2→\n     3→import { useEffect, useState, useRef } from 'react'\n     4→import { useParams, useRouter } from 'next/navigation'\n     5→import { motion, AnimatePresence } from 'framer-motion'\n     6→import { createClient, Notebook, Source, ChatMessage } from '@/lib/supabase'\n     7→import { chatApi } from '@/lib/api'\n     8→import { Button } from '@/components/ui/button'\n     9→import { Input } from '@/components/ui/input'\n    10→import { Textarea } from '@/components/ui/textarea'\n    11→import { Badge } from '@/components/ui/badge'\n    12→import {\n    13→  Dialog,\n    14→  DialogContent,\n    15→  DialogDescription,\n    16→  DialogFooter,\n    17→  DialogHeader,\n    18→  DialogTitle,\n    19→} from '@/components/ui/dialog'\n    20→import {\n    21→  Sheet,\n    22→  SheetContent,\n    23→  SheetDescription,\n    24→  SheetHeader,\n    25→  SheetTitle,\n    26→} from '@/components/ui/sheet'\n    27→import {\n    28→  ArrowLeft, Loader2, Sparkles, X, RotateCcw,\n    29→  BookOpen, ListChecks, FileText, HelpCircle, Mic, Video, Search, Share2,\n    30→  Maximize2, Minimize2, Table, FileSpreadsheet, Presentation, Image as ImageIcon\n    31→} from 'lucide-react'\n    32→// Toast notifications removed per user request\n    33→// import { toast } from 'sonner'\n    34→import { User } from '@supabase/supabase-js'\n    35→\n    36→import { ThreePanelLayout } from '@/components/panels/three-panel-layout'\n    37→import { SourcesPanel } from '@/components/sources/sources-panel'\n    38→import { ChatPanel } from '@/components/chat/chat-panel'\n    39→import { StudioPanel } from '@/components/studio/studio-panel'\n    40→import type { GenerationConfig } from '@/components/studio/generation-config-dialog'\n    41→\n    42→// Study viewers\n    43→import { FlashcardViewer } from '@/components/study/flashcard-viewer'\n    44→import { QuizViewer } from '@/components/study/quiz-viewer'\n    45→import { StudyGuideViewer } from '@/components/study/study-guide-viewer'\n    46→import { FAQViewer } from '@/components/study/faq-viewer'\n    47→import { MindMapViewer } from '@/components/study/mind-map-viewer'\n    48→\n    49→// Studio viewers\n    50→import { AudioPlayer } from '@/components/studio/audio-player'\n    51→import { VideoPlayer } from '@/components/studio/video-player'\n    52→import { ResearchReport } from '@/components/studio/research-report'\n    53→\n    54→interface LocalNote {\n    55→  id: string\n    56→  notebook_id: string\n    57→  type: 'written' | 'saved_response'\n    58→  title: string | null\n    59→  content: string | null\n    60→  tags: string[]\n    61→  is_pinned: boolean\n    62→  created_at: string\n    63→  updated_at: string\n    64→}\n    65→\n    66→export default function NotebookPage() {\n    67→  const params = useParams()\n    68→  const router = useRouter()\n    69→  const notebookId = params.id as string\n    70→  const supabase = createClient()\n    71→\n    72→  // Core state\n    73→  const [user, setUser] = useState<User | null>(null)\n    74→  const [notebook, setNotebook] = useState<Notebook | null>(null)\n    75→  const [sources, setSources] = useState<Source[]>([])\n    76→  const [messages, setMessages] = useState<ChatMessage[]>([])\n    77→  const [notes, setNotes] = useState<LocalNote[]>([])\n    78→  const [loading, setLoading] = useState(true)\n    79→\n    80→  // Chat state\n    81→  const [sending, setSending] = useState(false)\n    82→  const [message, setMessage] = useState('')\n    83→  const [selectedSources, setSelectedSources] = useState<Set<string>>(new Set())\n    84→  const [sessionId, setSessionId] = useState<string | null>(null)\n    85→  const [chatSessions, setChatSessions] = useState<Array<{\n    86→    id: string\n    87→    title: string\n    88→    created_at: string\n    89→    updated_at: string\n    90→    message_count: number\n    91→  }>>([])\n    92→  const [loadingSessions, setLoadingSessions] = useState(false)\n    93→\n    94→  // Source state\n    95→  const [viewingSource, setViewingSource] = useState<Source | null>(null)\n    96→  const [uploading, setUploading] = useState(false)\n    97→\n    98→  // Notes state\n    99→  const [addNoteOpen, setAddNoteOpen] = useState(false)\n   100→  const [noteTitle, setNoteTitle] = useState('')\n   101→  const [noteContent, setNoteContent] = useState('')\n   102→  const [savingNote, setSavingNote] = useState(false)\n   103→\n   104→  // Audio state\n   105→  const [audioFormat, setAudioFormat] = useState('deep_dive')\n   106→  const [audioInstructions, setAudioInstructions] = useState('')\n   107→  const [generatingAudio, setGeneratingAudio] = useState(false)\n   108→\n   109→  // Video state\n   110→  const [videoStyle, setVideoStyle] = useState('explainer')\n   111→  const [generatingVideo, setGeneratingVideo] = useState(false)\n   112→\n   113→  // Research state\n   114→  const [researchQuery, setResearchQuery] = useState('')\n   115→  const [researchMode, setResearchMode] = useState('fast')\n   116→  const [researching, setResearching] = useState(false)\n   117→\n   118→  // Study loading states\n   119→  const [generatingFlashcards, setGeneratingFlashcards] = useState(false)\n   120→  const [generatingQuiz, setGeneratingQuiz] = useState(false)\n   121→  const [generatingStudyGuide, setGeneratingStudyGuide] = useState(false)\n   122→  const [generatingFaq, setGeneratingFaq] = useState(false)\n   123→  const [generatingMindMap, setGeneratingMindMap] = useState(false)\n   124→\n   125→  // Creative outputs loading states\n   126→  const [generatingDataTable, setGeneratingDataTable] = useState(false)\n   127→  const [generatingReport, setGeneratingReport] = useState(false)\n   128→  const [generatingSlideDeck, setGeneratingSlideDeck] = useState(false)\n   129→  const [generatingInfographic, setGeneratingInfographic] = useState(false)\n   130→\n   131→  // Study results\n   132→  const [flashcards, setFlashcards] = useState<Array<{ id: string; front: string; back: string }>>([])\n   133→  const [quizQuestions, setQuizQuestions] = useState<Array<{ id: string; question: string; options: string[]; correct_index: number; explanation: string }>>([])\n   134→  const [studyGuide, setStudyGuide] = useState<{ title: string; sections: Array<{ heading: string; content: string }> } | null>(null)\n   135→  const [faqItems, setFaqItems] = useState<Array<{ question: string; answer: string }>>([])\n   136→  const [mindMap, setMindMap] = useState<{ title: string; nodes: Array<{ id: string; label: string; description?: string; children?: Array<{ id: string; label: string; description?: string; children?: Array<{ id: string; label: string; description?: string }> }> }> } | null>(null)\n   137→\n   138→  // Creative outputs data\n   139→  const [dataTableData, setDataTableData] = useState<{\n   140→    title: string\n   141→    description: string\n   142→    columns: Array<{ header: string; key: string; type: string }>\n   143→    rows: Array<Record<string, string | number | boolean>>\n   144→  } | null>(null)\n   145→  const [reportData, setReportData] = useState<{\n   146→    title: string\n   147→    executive_summary: string\n   148→    sections: Array<{ heading: string; content: string }>\n   149→    key_takeaways: string[]\n   150→  } | null>(null)\n   151→  const [slideDeckData, setSlideDeckData] = useState<{\n   152→    title: string\n   153→    subtitle?: string\n   154→    slides: Array<{ slide_number: number; title: string; content_type: string; main_content: string; bullet_points?: string[]; speaker_notes?: string }>\n   155→    theme_suggestion: string\n   156→  } | null>(null)\n   157→  const [infographicData, setInfographicData] = useState<{\n   158→    title: string\n   159→    subtitle?: string\n   160→    color_scheme: string[]\n   161→    sections: Array<{ section_type: string; title?: string; content: Record<string, unknown> }>\n   162→    style_suggestion: string\n   163→  } | null>(null)\n   164→\n   165→  // Study materials metadata (for UI display)\n   166→  const [studyMaterialsMeta, setStudyMaterialsMeta] = useState<Array<{\n   167→    id: string\n   168→    type: string\n   169→    sourceIds: string[]\n   170→    sourceNames: string[]\n   171→    createdAt: string\n   172→    itemCount?: number\n   173→  }>>([])\n   174→\n   175→  // Creative outputs metadata (for UI display)\n   176→  const [creativeOutputsMeta, setCreativeOutputsMeta] = useState<Array<{\n   177→    id: string\n   178→    type: string\n   179→    title: string\n   180→    status: string\n   181→    createdAt: string\n   182→    content?: Record<string, unknown>\n   183→  }>>([])\n   184→\n   185→  const [currentFlashcard, setCurrentFlashcard] = useState(0)\n   186→  const [showFlashcardBack, setShowFlashcardBack] = useState(false)\n   187→  const [currentQuizQuestion, setCurrentQuizQuestion] = useState(0)\n   188→  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null)\n   189→  const [showQuizAnswer, setShowQuizAnswer] = useState(false)\n   190→\n   191→  // Study materials sheet\n   192→  const [studySheetOpen, setStudySheetOpen] = useState(false)\n   193→  const [sheetWidth, setSheetWidth] = useState(576) // Default width in pixels\n   194→  const [isResizing, setIsResizing] = useState(false)\n   195→  const [activeStudyType, setActiveStudyType] = useState<'flashcards' | 'quiz' | 'guide' | 'faq' | 'mindmap' | 'audio' | 'video' | 'research' | 'datatable' | 'report' | 'slides' | 'infographic' | null>(null)\n   196→\n   197→  // Generated content state\n   198→  const [generatedAudio, setGeneratedAudio] = useState<{\n   199→    id: string\n   200→    format: string\n   201→    status: string\n   202→    script?: string\n   203→    audio_url?: string\n   204→    duration_seconds?: number\n   205→    created_at: string\n   206→  } | null>(null)\n   207→\n   208→  const [generatedVideo, setGeneratedVideo] = useState<{\n   209→    id: string\n   210→    style: string\n   211→    status: string\n   212→    script?: string\n   213→    video_url?: string\n   214→    thumbnail_url?: string\n   215→    duration_seconds?: number\n   216→    created_at: string\n   217→  } | null>(null)\n   218→\n   219→  const [generatedResearch, setGeneratedResearch] = useState<{\n   220→    id: string\n   221→    query: string\n   222→    mode: string\n   223→    status: string\n   224→    progress_message?: string\n   225→    sources_found_count?: number\n   226→    sources_analyzed_count?: number\n   227→    report_content?: string\n   228→    report_citations?: { title: string; url: string }[]\n   229→    created_at: string\n   230→    completed_at?: string\n   231→  } | null>(null)\n   232→\n   233→  // File input ref\n   234→  const fileInputRef = useRef<HTMLInputElement>(null)\n   235→\n   236→  // Initialize\n   237→  useEffect(() => {\n   238→    const init = async () => {\n   239→      const { data: { user } } = await supabase.auth.getUser()\n   240→      if (!user) {\n   241→        router.push('/auth/login')\n   242→        return\n   243→      }\n   244→      setUser(user)\n   245→      await Promise.all([fetchNotebook(), fetchSources(), fetchNotes()])\n   246→      setLoading(false)\n   247→      // Fetch study materials, generated content, creative outputs, and chat sessions after main load (non-blocking)\n   248→      fetchStudyMaterials()\n   249→      fetchGeneratedContent()\n   250→      fetchCreativeOutputs()\n   251→      fetchChatSessions()\n   252→    }\n   253→    init()\n   254→  }, [notebookId])\n   255→\n   256→  // Fetch chat sessions\n   257→  const fetchChatSessions = async () => {\n   258→    setLoadingSessions(true)\n   259→    try {\n   260→      const { data: { session } } = await supabase.auth.getSession()\n   261→      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions`, {\n   262→        headers: {\n   263→          'Authorization': `Bearer ${session?.access_token}`,\n   264→        },\n   265→      })\n   266→      const result = await response.json()\n   267→      if (result.data) {\n   268→        setChatSessions(result.data)\n   269→      }\n   270→    } catch (error) {\n   271→      console.error('Failed to fetch chat sessions:', error)\n   272→    }\n   273→    setLoadingSessions(false)\n   274→  }\n   275→\n   276→  // Load a chat session\n   277→  const loadChatSession = async (loadSessionId: string) => {\n   278→    try {\n   279→      const { data: { session } } = await supabase.auth.getSession()\n   280→      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions/${loadSessionId}`, {\n   281→        headers: {\n   282→          'Authorization': `Bearer ${session?.access_token}`,\n   283→        },\n   284→      })\n   285→      const result = await response.json()\n   286→      if (result.data) {\n   287→        setSessionId(loadSessionId)\n   288→        setMessages(result.data.messages || [])\n   289→      }\n   290→    } catch (error) {\n   291→      console.error('Failed to load chat session:', error)\n   292→      \n   293→    }\n   294→  }\n   295→\n   296→  // Start a new chat\n   297→  const startNewChat = () => {\n   298→    setSessionId(null)\n   299→    setMessages([])\n   300→    setMessage('')\n   301→  }\n   302→\n   303→  // Delete a chat session\n   304→  const deleteChatSession = async (deleteSessionId: string) => {\n   305→    try {\n   306→      const { data: { session } } = await supabase.auth.getSession()\n   307→      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions?session_id=${deleteSessionId}`, {\n   308→        method: 'DELETE',\n   309→        headers: {\n   310→          'Authorization': `Bearer ${session?.access_token}`,\n   311→        },\n   312→      })\n   313→      if (response.ok) {\n   314→        setChatSessions(prev => prev.filter(s => s.id !== deleteSessionId))\n   315→        \n   316→        // If we deleted the current session, start a new chat\n   317→        if (deleteSessionId === sessionId) {\n   318→          startNewChat()\n   319→        }\n   320→      }\n   321→    } catch (error) {\n   322→      console.error('Failed to delete chat session:', error)\n   323→      \n   324→    }\n   325→  }\n   326→\n   327→  // Load selected sources from localStorage after sources are loaded\n   328→  useEffect(() => {\n   329→    if (sources.length > 0 && !loading) {\n   330→      const savedSelection = localStorage.getItem(`notebook-${notebookId}-selected-sources`)\n   331→      if (savedSelection) {\n   332→        try {\n   333→          const savedIds = JSON.parse(savedSelection) as string[]\n   334→          // Only select sources that still exist\n   335→          const validIds = savedIds.filter(id => sources.some(s => s.id === id))\n   336→          if (validIds.length > 0) {\n   337→            setSelectedSources(new Set(validIds))\n   338→          }\n   339→        } catch {\n   340→          // Invalid JSON, ignore\n   341→        }\n   342→      }\n   343→    }\n   344→  }, [sources, loading, notebookId])\n   345→\n   346→  // Save selected sources to localStorage whenever they change\n   347→  useEffect(() => {\n   348→    if (!loading && sources.length > 0) {\n   349→      const selectedArray = Array.from(selectedSources)\n   350→      localStorage.setItem(`notebook-${notebookId}-selected-sources`, JSON.stringify(selectedArray))\n   351→    }\n   352→  }, [selectedSources, notebookId, loading, sources.length])\n   353→\n   354→  // Fetch existing audio/video/research content\n   355→  const fetchGeneratedContent = async () => {\n   356→    try {\n   357→      const { data: { session } } = await supabase.auth.getSession()\n   358→\n   359→      // Fetch audio\n   360→      const audioResponse = await fetch(`/api/notebooks/${notebookId}/audio`, {\n   361→        headers: {\n   362→          'Authorization': `Bearer ${session?.access_token}`,\n   363→        },\n   364→      })\n   365→      const audioResult = await audioResponse.json()\n   366→      if (audioResult.data && audioResult.data.length > 0) {\n   367→        // Get the most recent audio\n   368→        setGeneratedAudio(audioResult.data[0])\n   369→      }\n   370→\n   371→      // Fetch video\n   372→      const videoResponse = await fetch(`/api/notebooks/${notebookId}/video`, {\n   373→        headers: {\n   374→          'Authorization': `Bearer ${session?.access_token}`,\n   375→        },\n   376→      })\n   377→      const videoResult = await videoResponse.json()\n   378→      if (videoResult.data && videoResult.data.length > 0) {\n   379→        setGeneratedVideo(videoResult.data[0])\n   380→      }\n   381→\n   382→      // Fetch research\n   383→      const researchResponse = await fetch(`/api/notebooks/${notebookId}/research`, {\n   384→        headers: {\n   385→          'Authorization': `Bearer ${session?.access_token}`,\n   386→        },\n   387→      })\n   388→      const researchResult = await researchResponse.json()\n   389→      if (researchResult.data && researchResult.data.length > 0) {\n   390→        setGeneratedResearch(researchResult.data[0])\n   391→      }\n   392→    } catch (error) {\n   393→      console.error('Failed to fetch generated content:', error)\n   394→    }\n   395→  }\n   396→\n   397→  // Fetch existing creative outputs (data tables, reports, slides, infographics)\n   398→  const fetchCreativeOutputs = async () => {\n   399→    try {\n   400→      const { data: { session } } = await supabase.auth.getSession()\n   401→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n   402→        headers: {\n   403→          'Authorization': `Bearer ${session?.access_token}`,\n   404→        },\n   405→      })\n   406→      const result = await response.json()\n   407→\n   408→      if (result.data && Array.isArray(result.data)) {\n   409→        // Group by type and get the latest of each\n   410→        const outputsByType: Record<string, typeof result.data[0]> = {}\n   411→        for (const output of result.data) {\n   412→          if (output.status === 'completed' && !outputsByType[output.type]) {\n   413→            outputsByType[output.type] = output\n   414→          }\n   415→        }\n   416→\n   417→        // Build metadata array\n   418→        const metaArray = Object.values(outputsByType).map((output) => ({\n   419→          id: output.id,\n   420→          type: output.type,\n   421→          title: output.title || output.type.replace('_', ' '),\n   422→          status: output.status,\n   423→          createdAt: output.created_at,\n   424→          content: output.content,\n   425→        }))\n   426→        setCreativeOutputsMeta(metaArray)\n   427→\n   428→        // Populate state with the latest content of each type\n   429→        for (const output of Object.values(outputsByType)) {\n   430→          if (output.type === 'data_table' && output.content) {\n   431→            setDataTableData(output.content as typeof dataTableData)\n   432→          } else if (output.type === 'report' && output.content) {\n   433→            setReportData(output.content as typeof reportData)\n   434→          } else if (output.type === 'slide_deck' && output.content) {\n   435→            setSlideDeckData(output.content as typeof slideDeckData)\n   436→          } else if (output.type === 'infographic' && output.content) {\n   437→            setInfographicData(output.content as typeof infographicData)\n   438→          }\n   439→        }\n   440→      }\n   441→    } catch (error) {\n   442→      console.error('Failed to fetch creative outputs:', error)\n   443→    }\n   444→  }\n   445→\n   446→  // Fetch existing study materials from Supabase\n   447→  const fetchStudyMaterials = async (sourcesData?: Source[]) => {\n   448→    try {\n   449→      const { data: { session } } = await supabase.auth.getSession()\n   450→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n   451→        headers: {\n   452→          'Authorization': `Bearer ${session?.access_token}`,\n   453→        },\n   454→      })\n   455→      const result = await response.json()\n   456→\n   457→      if (result.data && Array.isArray(result.data)) {\n   458→        // Group materials by type and get the latest of each\n   459→        const materialsByType: Record<string, typeof result.data[0]> = {}\n   460→        for (const material of result.data) {\n   461→          if (!materialsByType[material.type]) {\n   462→            materialsByType[material.type] = material\n   463→          }\n   464→        }\n   465→\n   466→        // Build metadata array for UI\n   467→        const currentSources = sourcesData || sources\n   468→        const metaArray = Object.values(materialsByType).map((material) => {\n   469→          const sourceIds = material.source_ids || []\n   470→          const sourceNames = sourceIds.map((id: string) => {\n   471→            const source = currentSources.find(s => s.id === id)\n   472→            return source?.name || 'Unknown source'\n   473→          })\n   474→\n   475→          // Calculate item count based on type\n   476→          let itemCount = 0\n   477→          if (material.type === 'flashcards') itemCount = material.data?.flashcards?.length || 0\n   478→          else if (material.type === 'quiz') itemCount = material.data?.questions?.length || 0\n   479→          else if (material.type === 'faq') itemCount = material.data?.faq?.length || 0\n   480→\n   481→          return {\n   482→            id: material.id,\n   483→            type: material.type,\n   484→            sourceIds,\n   485→            sourceNames,\n   486→            createdAt: material.created_at,\n   487→            itemCount,\n   488→          }\n   489→        })\n   490→        setStudyMaterialsMeta(metaArray)\n   491→\n   492→        // Populate state with cached data\n   493→        if (materialsByType.flashcards?.data?.flashcards) {\n   494→          setFlashcards(materialsByType.flashcards.data.flashcards)\n   495→        }\n   496→        if (materialsByType.quiz?.data?.questions) {\n   497→          setQuizQuestions(materialsByType.quiz.data.questions)\n   498→        }\n   499→        if (materialsByType.study_guide?.data) {\n   500→          setStudyGuide(materialsByType.study_guide.data)\n   501→        }\n   502→        if (materialsByType.faq?.data?.faq) {\n   503→          setFaqItems(materialsByType.faq.data.faq)\n   504→        }\n   505→        if (materialsByType.mind_map?.data) {\n   506→          setMindMap(materialsByType.mind_map.data)\n   507→        }\n   508→      }\n   509→    } catch (error) {\n   510→      console.error('Failed to fetch study materials:', error)\n   511→    }\n   512→  }\n   513→\n   514→  const fetchNotebook = async () => {\n   515→    const { data, error } = await supabase\n   516→      .from('notebooks')\n   517→      .select('*')\n   518→      .eq('id', notebookId)\n   519→      .single()\n   520→\n   521→    if (error || !data) {\n   522→      \n   523→      router.push('/')\n   524→      return\n   525→    }\n   526→    setNotebook(data)\n   527→  }\n   528→\n   529→  const fetchSources = async () => {\n   530→    const { data } = await supabase\n   531→      .from('sources')\n   532→      .select('*')\n   533→      .eq('notebook_id', notebookId)\n   534→      .order('created_at', { ascending: false })\n   535→\n   536→    setSources(data || [])\n   537→  }\n   538→\n   539→  const fetchNotes = async () => {\n   540→    const { data } = await supabase\n   541→      .from('notes')\n   542→      .select('*')\n   543→      .eq('notebook_id', notebookId)\n   544→      .order('is_pinned', { ascending: false })\n   545→      .order('created_at', { ascending: false })\n   546→\n   547→    setNotes(data || [])\n   548→  }\n   549→\n   550→  // Source handlers\n   551→  const handleAddSource = async (type: string, data: { input: string; name?: string; file?: File }) => {\n   552→    setUploading(true)\n   553→\n   554→    if (type === 'file') {\n   555→      // Handle file upload - file is passed from the sources panel\n   556→      const file = data.file\n   557→      if (file) {\n   558→        const fileExt = file.name.split('.').pop()?.toLowerCase()\n   559→        const filePath = `${user?.id}/${notebookId}/${Date.now()}.${fileExt}`\n   560→\n   561→        const { error: uploadError } = await supabase.storage\n   562→          .from('sources')\n   563→          .upload(filePath, file)\n   564→\n   565→        if (uploadError) {\n   566→          console.error('Upload error:', uploadError)\n   567→          \n   568→          setUploading(false)\n   569→          return\n   570→        }\n   571→\n   572→        const { data: sourceData, error } = await supabase\n   573→          .from('sources')\n   574→          .insert({\n   575→            notebook_id: notebookId,\n   576→            type: fileExt === 'pdf' ? 'pdf' : fileExt === 'docx' ? 'docx' : 'txt',\n   577→            name: file.name,\n   578→            status: 'ready',\n   579→            file_path: filePath,\n   580→            original_filename: file.name,\n   581→            mime_type: file.type,\n   582→            file_size_bytes: file.size,\n   583→          })\n   584→          .select()\n   585→          .single()\n   586→\n   587→        if (error) {\n   588→          console.error('Source creation error:', error)\n   589→          \n   590→        } else {\n   591→          \n   592→          setSources([sourceData, ...sources])\n   593→        }\n   594→      } else {\n   595→        \n   596→      }\n   597→    } else {\n   598→      let sourceData: Partial<Source> = {\n   599→        notebook_id: notebookId,\n   600→        status: 'ready',\n   601→      }\n   602→\n   603→      if (type === 'youtube') {\n   604→        sourceData = {\n   605→          ...sourceData,\n   606→          type: 'youtube',\n   607→          name: data.name || `YouTube: ${data.input}`,\n   608→          metadata: { url: data.input },\n   609→        }\n   610→      } else if (type === 'url') {\n   611→        sourceData = {\n   612→          ...sourceData,\n   613→          type: 'url',\n   614→          name: data.name || data.input,\n   615→          metadata: { url: data.input },\n   616→        }\n   617→      } else if (type === 'text') {\n   618→        sourceData = {\n   619→          ...sourceData,\n   620→          type: 'text',\n   621→          name: data.name || 'Pasted Text',\n   622→          metadata: { content: data.input },\n   623→        }\n   624→      }\n   625→\n   626→      const { data: newSource, error } = await supabase\n   627→        .from('sources')\n   628→        .insert(sourceData)\n   629→        .select()\n   630→        .single()\n   631→\n   632→      if (error) {\n   633→        \n   634→      } else {\n   635→        \n   636→        setSources([newSource, ...sources])\n   637→      }\n   638→    }\n   639→\n   640→    setUploading(false)\n   641→  }\n   642→\n   643→  const handleDeleteSource = async (sourceId: string) => {\n   644→    const { error } = await supabase\n   645→      .from('sources')\n   646→      .delete()\n   647→      .eq('id', sourceId)\n   648→\n   649→    if (error) {\n   650→      \n   651→    } else {\n   652→      setSources(sources.filter(s => s.id !== sourceId))\n   653→      selectedSources.delete(sourceId)\n   654→      setSelectedSources(new Set(selectedSources))\n   655→      \n   656→    }\n   657→  }\n   658→\n   659→  const toggleSource = (sourceId: string) => {\n   660→    const newSelected = new Set(selectedSources)\n   661→    if (newSelected.has(sourceId)) {\n   662→      newSelected.delete(sourceId)\n   663→    } else {\n   664→      newSelected.add(sourceId)\n   665→    }\n   666→    setSelectedSources(newSelected)\n   667→  }\n   668→\n   669→  const selectAllSources = () => {\n   670→    if (selectedSources.size === sources.length) {\n   671→      setSelectedSources(new Set())\n   672→    } else {\n   673→      setSelectedSources(new Set(sources.map(s => s.id)))\n   674→    }\n   675→  }\n   676→\n   677→  // Chat handlers\n   678→  const sendMessage = async (overrideMessage?: string) => {\n   679→    const messageToSend = overrideMessage || message\n   680→    if (!messageToSend.trim() || sending) return\n   681→\n   682→    setSending(true)\n   683→    const userMessage: ChatMessage = {\n   684→      id: crypto.randomUUID(),\n   685→      session_id: sessionId || '',\n   686→      role: 'user',\n   687→      content: messageToSend,\n   688→      citations: [],\n   689→      source_ids_used: Array.from(selectedSources),\n   690→      model_used: null,\n   691→      input_tokens: null,\n   692→      output_tokens: null,\n   693→      cost_usd: null,\n   694→      created_at: new Date().toISOString(),\n   695→    }\n   696→    setMessages(prev => [...prev, userMessage])\n   697→    setMessage('')\n   698→\n   699→    try {\n   700→      const response = await chatApi.sendMessage(notebookId, {\n   701→        message: userMessage.content,\n   702→        source_ids: Array.from(selectedSources),\n   703→        session_id: sessionId || undefined,\n   704→      })\n   705→\n   706→      const isNewSession = !sessionId\n   707→      if (response.data.session_id) {\n   708→        setSessionId(response.data.session_id)\n   709→      }\n   710→\n   711→      const aiMessage: ChatMessage = {\n   712→        id: response.data.message_id,\n   713→        session_id: response.data.session_id,\n   714→        role: 'assistant',\n   715→        content: response.data.content,\n   716→        citations: response.data.citations,\n   717→        source_ids_used: Array.from(selectedSources),\n   718→        model_used: response.usage?.model_used || 'gemini-2.0-flash',\n   719→        input_tokens: response.usage?.input_tokens || 0,\n   720→        output_tokens: response.usage?.output_tokens || 0,\n   721→        cost_usd: response.usage?.cost_usd || 0,\n   722→        created_at: new Date().toISOString(),\n   723→      }\n   724→      setMessages(prev => [...prev, aiMessage])\n   725→\n   726→      // Refresh chat sessions if this was a new session\n   727→      if (isNewSession) {\n   728→        fetchChatSessions()\n   729→      }\n   730→    } catch {\n   731→      \n   732→      setMessages(prev => prev.filter(m => m.id !== userMessage.id))\n   733→    }\n   734→    setSending(false)\n   735→  }\n   736→\n   737→  const saveResponseAsNote = async (msg: ChatMessage) => {\n   738→    const { data, error } = await supabase\n   739→      .from('notes')\n   740→      .insert({\n   741→        notebook_id: notebookId,\n   742→        type: 'saved_response',\n   743→        title: `Saved Response - ${new Date().toLocaleDateString()}`,\n   744→        content: msg.content,\n   745→        tags: [],\n   746→      })\n   747→      .select()\n   748→      .single()\n   749→\n   750→    if (error) {\n   751→      \n   752→    } else {\n   753→      \n   754→      setNotes([data, ...notes])\n   755→    }\n   756→  }\n   757→\n   758→  // Notes handlers\n   759→  const createNote = async () => {\n   760→    if (!noteTitle.trim() && !noteContent.trim()) return\n   761→\n   762→    setSavingNote(true)\n   763→    const { data, error } = await supabase\n   764→      .from('notes')\n   765→      .insert({\n   766→        notebook_id: notebookId,\n   767→        type: 'written',\n   768→        title: noteTitle || 'Untitled Note',\n   769→        content: noteContent,\n   770→        tags: [],\n   771→      })\n   772→      .select()\n   773→      .single()\n   774→\n   775→    if (error) {\n   776→      \n   777→    } else {\n   778→      \n   779→      setNotes([data, ...notes])\n   780→      setNoteTitle('')\n   781→      setNoteContent('')\n   782→      setAddNoteOpen(false)\n   783→    }\n   784→    setSavingNote(false)\n   785→  }\n   786→\n   787→  // Audio generation\n   788→  const generateAudio = async () => {\n   789→    if (selectedSources.size === 0) {\n   790→      \n   791→      return\n   792→    }\n   793→\n   794→    setGeneratingAudio(true)\n   795→    setActiveStudyType('audio')\n   796→    setStudySheetOpen(true)\n   797→\n   798→    try {\n   799→      const { data: { session } } = await supabase.auth.getSession()\n   800→      const response = await fetch(`/api/notebooks/${notebookId}/audio`, {\n   801→        method: 'POST',\n   802→        headers: {\n   803→          'Content-Type': 'application/json',\n   804→          'Authorization': `Bearer ${session?.access_token}`,\n   805→        },\n   806→        body: JSON.stringify({\n   807→          format: audioFormat,\n   808→          source_ids: Array.from(selectedSources),\n   809→          custom_instructions: audioInstructions || undefined,\n   810→        }),\n   811→      })\n   812→      const result = await response.json()\n   813→      if (result.error) {\n   814→        \n   815→      } else if (result.data) {\n   816→        setGeneratedAudio(result.data)\n   817→        \n   818→      }\n   819→    } catch {\n   820→      \n   821→    }\n   822→    setGeneratingAudio(false)\n   823→  }\n   824→\n   825→  // Video generation\n   826→  const generateVideo = async () => {\n   827→    if (selectedSources.size === 0) {\n   828→      \n   829→      return\n   830→    }\n   831→\n   832→    setGeneratingVideo(true)\n   833→    setActiveStudyType('video')\n   834→    setStudySheetOpen(true)\n   835→\n   836→    try {\n   837→      const { data: { session } } = await supabase.auth.getSession()\n   838→      const response = await fetch(`/api/notebooks/${notebookId}/video`, {\n   839→        method: 'POST',\n   840→        headers: {\n   841→          'Content-Type': 'application/json',\n   842→          'Authorization': `Bearer ${session?.access_token}`,\n   843→        },\n   844→        body: JSON.stringify({\n   845→          style: videoStyle,\n   846→          source_ids: Array.from(selectedSources),\n   847→        }),\n   848→      })\n   849→      const result = await response.json()\n   850→      if (result.error) {\n   851→        \n   852→      } else if (result.data) {\n   853→        setGeneratedVideo(result.data)\n   854→        \n   855→      }\n   856→    } catch {\n   857→      \n   858→    }\n   859→    setGeneratingVideo(false)\n   860→  }\n   861→\n   862→  // Research generation\n   863→  const runResearch = async () => {\n   864→    if (!researchQuery.trim()) {\n   865→      \n   866→      return\n   867→    }\n   868→\n   869→    setResearching(true)\n   870→    setActiveStudyType('research')\n   871→    setStudySheetOpen(true)\n   872→\n   873→    try {\n   874→      const { data: { session } } = await supabase.auth.getSession()\n   875→      const response = await fetch(`/api/notebooks/${notebookId}/research`, {\n   876→        method: 'POST',\n   877→        headers: {\n   878→          'Content-Type': 'application/json',\n   879→          'Authorization': `Bearer ${session?.access_token}`,\n   880→        },\n   881→        body: JSON.stringify({\n   882→          query: researchQuery,\n   883→          mode: researchMode,\n   884→        }),\n   885→      })\n   886→      const result = await response.json()\n   887→      if (result.error) {\n   888→        \n   889→      } else if (result.data) {\n   890→        setGeneratedResearch(result.data)\n   891→        \n   892→        setResearchQuery('')\n   893→      }\n   894→    } catch {\n   895→      \n   896→    }\n   897→    setResearching(false)\n   898→  }\n   899→\n   900→  // Study material generation handlers\n   901→  const handleGenerateFlashcards = async () => {\n   902→    setGeneratingFlashcards(true)\n   903→    try {\n   904→      const { data: { session } } = await supabase.auth.getSession()\n   905→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n   906→        method: 'POST',\n   907→        headers: {\n   908→          'Content-Type': 'application/json',\n   909→          'Authorization': `Bearer ${session?.access_token}`,\n   910→        },\n   911→        body: JSON.stringify({\n   912→          type: 'flashcards',\n   913→          source_ids: Array.from(selectedSources),\n   914→          count: 5,\n   915→        }),\n   916→      })\n   917→      const result = await response.json()\n   918→      if (result.error) {\n   919→        \n   920→      } else if (result.data?.flashcards) {\n   921→        setFlashcards(result.data.flashcards)\n   922→        setCurrentFlashcard(0)\n   923→        setShowFlashcardBack(false)\n   924→        setActiveStudyType('flashcards')\n   925→        setStudySheetOpen(true)\n   926→        fetchStudyMaterials()\n   927→        \n   928→      }\n   929→    } catch {\n   930→      \n   931→    } finally {\n   932→      setGeneratingFlashcards(false)\n   933→    }\n   934→  }\n   935→\n   936→  const handleGenerateQuiz = async () => {\n   937→    setGeneratingQuiz(true)\n   938→    try {\n   939→      const { data: { session } } = await supabase.auth.getSession()\n   940→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n   941→        method: 'POST',\n   942→        headers: {\n   943→          'Content-Type': 'application/json',\n   944→          'Authorization': `Bearer ${session?.access_token}`,\n   945→        },\n   946→        body: JSON.stringify({\n   947→          type: 'quiz',\n   948→          source_ids: Array.from(selectedSources),\n   949→          count: 5,\n   950→        }),\n   951→      })\n   952→      const result = await response.json()\n   953→      if (result.error) {\n   954→        \n   955→      } else if (result.data?.questions) {\n   956→        setQuizQuestions(result.data.questions)\n   957→        setCurrentQuizQuestion(0)\n   958→        setSelectedAnswer(null)\n   959→        setShowQuizAnswer(false)\n   960→        setActiveStudyType('quiz')\n   961→        setStudySheetOpen(true)\n   962→        fetchStudyMaterials()\n   963→        \n   964→      }\n   965→    } catch {\n   966→      \n   967→    } finally {\n   968→      setGeneratingQuiz(false)\n   969→    }\n   970→  }\n   971→\n   972→  const handleGenerateStudyGuide = async () => {\n   973→    setGeneratingStudyGuide(true)\n   974→    try {\n   975→      const { data: { session } } = await supabase.auth.getSession()\n   976→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n   977→        method: 'POST',\n   978→        headers: {\n   979→          'Content-Type': 'application/json',\n   980→          'Authorization': `Bearer ${session?.access_token}`,\n   981→        },\n   982→        body: JSON.stringify({\n   983→          type: 'study-guide',\n   984→          source_ids: Array.from(selectedSources),\n   985→        }),\n   986→      })\n   987→      const result = await response.json()\n   988→      if (result.error) {\n   989→        \n   990→      } else if (result.data?.sections) {\n   991→        setStudyGuide(result.data)\n   992→        setActiveStudyType('guide')\n   993→        setStudySheetOpen(true)\n   994→        fetchStudyMaterials()\n   995→        \n   996→      }\n   997→    } catch {\n   998→      \n   999→    } finally {\n  1000→      setGeneratingStudyGuide(false)\n  1001→    }\n  1002→  }\n  1003→\n  1004→  const handleGenerateFaq = async () => {\n  1005→    setGeneratingFaq(true)\n  1006→    try {\n  1007→      const { data: { session } } = await supabase.auth.getSession()\n  1008→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n  1009→        method: 'POST',\n  1010→        headers: {\n  1011→          'Content-Type': 'application/json',\n  1012→          'Authorization': `Bearer ${session?.access_token}`,\n  1013→        },\n  1014→        body: JSON.stringify({\n  1015→          type: 'faq',\n  1016→          source_ids: Array.from(selectedSources),\n  1017→        }),\n  1018→      })\n  1019→      const result = await response.json()\n  1020→      if (result.error) {\n  1021→        \n  1022→      } else if (result.data?.faq) {\n  1023→        setFaqItems(result.data.faq)\n  1024→        setActiveStudyType('faq')\n  1025→        setStudySheetOpen(true)\n  1026→        fetchStudyMaterials()\n  1027→        \n  1028→      }\n  1029→    } catch {\n  1030→      \n  1031→    } finally {\n  1032→      setGeneratingFaq(false)\n  1033→    }\n  1034→  }\n  1035→\n  1036→  const handleGenerateMindMap = async () => {\n  1037→    setGeneratingMindMap(true)\n  1038→    try {\n  1039→      const { data: { session } } = await supabase.auth.getSession()\n  1040→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n  1041→        method: 'POST',\n  1042→        headers: {\n  1043→          'Content-Type': 'application/json',\n  1044→          'Authorization': `Bearer ${session?.access_token}`,\n  1045→        },\n  1046→        body: JSON.stringify({\n  1047→          type: 'mind-map',\n  1048→          source_ids: Array.from(selectedSources),\n  1049→        }),\n  1050→      })\n  1051→      const result = await response.json()\n  1052→      if (result.error) {\n  1053→\n  1054→      } else if (result.data?.nodes) {\n  1055→        setMindMap(result.data)\n  1056→        setActiveStudyType('mindmap')\n  1057→        setStudySheetOpen(true)\n  1058→        // Refresh metadata to show updated material\n  1059→        fetchStudyMaterials()\n  1060→\n  1061→      }\n  1062→    } catch {\n  1063→\n  1064→    } finally {\n  1065→      setGeneratingMindMap(false)\n  1066→    }\n  1067→  }\n  1068→\n  1069→  // Unified study material handler with config\n  1070→  const handleGenerateStudyMaterial = async (config: GenerationConfig) => {\n  1071→    const sourceIds = config.sourceIds && config.sourceIds.length > 0\n  1072→      ? config.sourceIds\n  1073→      : Array.from(selectedSources)\n  1074→\n  1075→    if (sourceIds.length === 0) return\n  1076→\n  1077→    // Set loading state based on type\n  1078→    const setLoading = {\n  1079→      'flashcards': setGeneratingFlashcards,\n  1080→      'quiz': setGeneratingQuiz,\n  1081→      'study-guide': setGeneratingStudyGuide,\n  1082→      'faq': setGeneratingFaq,\n  1083→      'mind-map': setGeneratingMindMap,\n  1084→    }[config.type]\n  1085→    setLoading?.(true)\n  1086→\n  1087→    try {\n  1088→      const { data: { session } } = await supabase.auth.getSession()\n  1089→\n  1090→      // Build request body with all config options\n  1091→      const requestBody: Record<string, unknown> = {\n  1092→        type: config.type,\n  1093→        source_ids: sourceIds,\n  1094→      }\n  1095→\n  1096→      // Add optional config fields\n  1097→      if (config.count) requestBody.count = config.count\n  1098→      if (config.difficulty) requestBody.difficulty = config.difficulty\n  1099→      if (config.focusArea) requestBody.focus_area = config.focusArea\n  1100→      if (config.customInstructions) requestBody.custom_instructions = config.customInstructions\n  1101→      if (config.questionTypes) requestBody.question_types = config.questionTypes\n  1102→\n  1103→      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n  1104→        method: 'POST',\n  1105→        headers: {\n  1106→          'Content-Type': 'application/json',\n  1107→          'Authorization': `Bearer ${session?.access_token}`,\n  1108→        },\n  1109→        body: JSON.stringify(requestBody),\n  1110→      })\n  1111→      const result = await response.json()\n  1112→\n  1113→      if (result.error) {\n  1114→        console.error('Generation error:', result.error)\n  1115→      } else if (result.data) {\n  1116→        // Handle each type's response\n  1117→        switch (config.type) {\n  1118→          case 'flashcards':\n  1119→            if (result.data.flashcards) {\n  1120→              setFlashcards(result.data.flashcards)\n  1121→              setCurrentFlashcard(0)\n  1122→              setShowFlashcardBack(false)\n  1123→              setActiveStudyType('flashcards')\n  1124→              setStudySheetOpen(true)\n  1125→            }\n  1126→            break\n  1127→          case 'quiz':\n  1128→            if (result.data.questions) {\n  1129→              setQuizQuestions(result.data.questions)\n  1130→              setCurrentQuizQuestion(0)\n  1131→              setSelectedAnswer(null)\n  1132→              setShowQuizAnswer(false)\n  1133→              setActiveStudyType('quiz')\n  1134→              setStudySheetOpen(true)\n  1135→            }\n  1136→            break\n  1137→          case 'study-guide':\n  1138→            if (result.data.sections) {\n  1139→              setStudyGuide(result.data)\n  1140→              setActiveStudyType('guide')\n  1141→              setStudySheetOpen(true)\n  1142→            }\n  1143→            break\n  1144→          case 'faq':\n  1145→            if (result.data.faq) {\n  1146→              setFaqItems(result.data.faq)\n  1147→              setActiveStudyType('faq')\n  1148→              setStudySheetOpen(true)\n  1149→            }\n  1150→            break\n  1151→          case 'mind-map':\n  1152→            if (result.data.nodes) {\n  1153→              setMindMap(result.data)\n  1154→              setActiveStudyType('mindmap')\n  1155→              setStudySheetOpen(true)\n  1156→            }\n  1157→            break\n  1158→        }\n  1159→        fetchStudyMaterials()\n  1160→      }\n  1161→    } catch (error) {\n  1162→      console.error('Study material generation failed:', error)\n  1163→    } finally {\n  1164→      setLoading?.(false)\n  1165→    }\n  1166→  }\n  1167→\n  1168→  // Unified creative output handler with config\n  1169→  const handleGenerateCreativeOutput = async (config: GenerationConfig) => {\n  1170→    const sourceIds = config.sourceIds && config.sourceIds.length > 0\n  1171→      ? config.sourceIds\n  1172→      : Array.from(selectedSources)\n  1173→\n  1174→    if (sourceIds.length === 0) return\n  1175→\n  1176→    // Set loading state based on type\n  1177→    const setLoading = {\n  1178→      'data_table': setGeneratingDataTable,\n  1179→      'report': setGeneratingReport,\n  1180→      'slide_deck': setGeneratingSlideDeck,\n  1181→      'infographic': setGeneratingInfographic,\n  1182→    }[config.type]\n  1183→    setLoading?.(true)\n  1184→\n  1185→    try {\n  1186→      const { data: { session } } = await supabase.auth.getSession()\n  1187→\n  1188→      // Build request body with all config options\n  1189→      const requestBody: Record<string, unknown> = {\n  1190→        type: config.type,\n  1191→        source_ids: sourceIds,\n  1192→      }\n  1193→\n  1194→      // Add optional config fields\n  1195→      if (config.customInstructions) requestBody.custom_instructions = config.customInstructions\n  1196→      if (config.focusArea) requestBody.focus_area = config.focusArea\n  1197→      if (config.reportType) requestBody.report_type = config.reportType\n  1198→      if (config.tone) requestBody.tone = config.tone\n  1199→      if (config.slideCount) requestBody.slide_count = config.slideCount\n  1200→      if (config.style) requestBody.style = config.style\n  1201→\n  1202→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n  1203→        method: 'POST',\n  1204→        headers: {\n  1205→          'Content-Type': 'application/json',\n  1206→          'Authorization': `Bearer ${session?.access_token}`,\n  1207→        },\n  1208→        body: JSON.stringify(requestBody),\n  1209→      })\n  1210→      const result = await response.json()\n  1211→\n  1212→      if (result.error) {\n  1213→        console.error('Generation error:', result.error)\n  1214→      } else if (result.data) {\n  1215→        // Handle each type's response\n  1216→        switch (config.type) {\n  1217→          case 'data_table':\n  1218→            setDataTableData(result.data)\n  1219→            setActiveStudyType('datatable')\n  1220→            setStudySheetOpen(true)\n  1221→            break\n  1222→          case 'report':\n  1223→            setReportData(result.data)\n  1224→            setActiveStudyType('report')\n  1225→            setStudySheetOpen(true)\n  1226→            break\n  1227→          case 'slide_deck':\n  1228→            setSlideDeckData(result.data)\n  1229→            setActiveStudyType('slides')\n  1230→            setStudySheetOpen(true)\n  1231→            break\n  1232→          case 'infographic':\n  1233→            setInfographicData(result.data)\n  1234→            setActiveStudyType('infographic')\n  1235→            setStudySheetOpen(true)\n  1236→            break\n  1237→        }\n  1238→        fetchCreativeOutputs()\n  1239→      }\n  1240→    } catch (error) {\n  1241→      console.error('Creative output generation failed:', error)\n  1242→    } finally {\n  1243→      setLoading?.(false)\n  1244→    }\n  1245→  }\n  1246→\n  1247→  // Creative output generation handlers (legacy - kept for compatibility)\n  1248→  const handleGenerateDataTable = async () => {\n  1249→    if (selectedSources.size === 0) {\n  1250→      \n  1251→      return\n  1252→    }\n  1253→    setGeneratingDataTable(true)\n  1254→    try {\n  1255→      const { data: { session } } = await supabase.auth.getSession()\n  1256→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n  1257→        method: 'POST',\n  1258→        headers: {\n  1259→          'Content-Type': 'application/json',\n  1260→          'Authorization': `Bearer ${session?.access_token}`,\n  1261→        },\n  1262→        body: JSON.stringify({\n  1263→          type: 'data_table',\n  1264→          source_ids: Array.from(selectedSources),\n  1265→        }),\n  1266→      })\n  1267→      const result = await response.json()\n  1268→      if (result.error) {\n  1269→        \n  1270→      } else if (result.data) {\n  1271→        setDataTableData(result.data)\n  1272→        setActiveStudyType('datatable' as typeof activeStudyType)\n  1273→        setStudySheetOpen(true)\n  1274→        fetchCreativeOutputs()\n  1275→      }\n  1276→    } catch {\n  1277→      // Error handled silently\n  1278→    } finally {\n  1279→      setGeneratingDataTable(false)\n  1280→    }\n  1281→  }\n  1282→\n  1283→  const handleGenerateReport = async (reportType: string) => {\n  1284→    if (selectedSources.size === 0) {\n  1285→      \n  1286→      return\n  1287→    }\n  1288→    setGeneratingReport(true)\n  1289→    try {\n  1290→      const { data: { session } } = await supabase.auth.getSession()\n  1291→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n  1292→        method: 'POST',\n  1293→        headers: {\n  1294→          'Content-Type': 'application/json',\n  1295→          'Authorization': `Bearer ${session?.access_token}`,\n  1296→        },\n  1297→        body: JSON.stringify({\n  1298→          type: 'report',\n  1299→          source_ids: Array.from(selectedSources),\n  1300→          report_type: reportType,\n  1301→        }),\n  1302→      })\n  1303→      const result = await response.json()\n  1304→      if (result.error) {\n  1305→        \n  1306→      } else if (result.data) {\n  1307→        setReportData(result.data)\n  1308→        setActiveStudyType('report' as typeof activeStudyType)\n  1309→        setStudySheetOpen(true)\n  1310→        fetchCreativeOutputs()\n  1311→      }\n  1312→    } catch {\n  1313→      // Error handled silently\n  1314→    } finally {\n  1315→      setGeneratingReport(false)\n  1316→    }\n  1317→  }\n  1318→\n  1319→  const handleGenerateSlideDeck = async () => {\n  1320→    if (selectedSources.size === 0) {\n  1321→      \n  1322→      return\n  1323→    }\n  1324→    setGeneratingSlideDeck(true)\n  1325→    try {\n  1326→      const { data: { session } } = await supabase.auth.getSession()\n  1327→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n  1328→        method: 'POST',\n  1329→        headers: {\n  1330→          'Content-Type': 'application/json',\n  1331→          'Authorization': `Bearer ${session?.access_token}`,\n  1332→        },\n  1333→        body: JSON.stringify({\n  1334→          type: 'slide_deck',\n  1335→          source_ids: Array.from(selectedSources),\n  1336→        }),\n  1337→      })\n  1338→      const result = await response.json()\n  1339→      if (result.error) {\n  1340→        \n  1341→      } else if (result.data) {\n  1342→        setSlideDeckData(result.data)\n  1343→        setActiveStudyType('slides' as typeof activeStudyType)\n  1344→        setStudySheetOpen(true)\n  1345→        fetchCreativeOutputs()\n  1346→      }\n  1347→    } catch {\n  1348→      // Error handled silently\n  1349→    } finally {\n  1350→      setGeneratingSlideDeck(false)\n  1351→    }\n  1352→  }\n  1353→\n  1354→  const handleGenerateInfographic = async () => {\n  1355→    if (selectedSources.size === 0) {\n  1356→      \n  1357→      return\n  1358→    }\n  1359→    setGeneratingInfographic(true)\n  1360→    try {\n  1361→      const { data: { session } } = await supabase.auth.getSession()\n  1362→      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n  1363→        method: 'POST',\n  1364→        headers: {\n  1365→          'Content-Type': 'application/json',\n  1366→          'Authorization': `Bearer ${session?.access_token}`,\n  1367→        },\n  1368→        body: JSON.stringify({\n  1369→          type: 'infographic',\n  1370→          source_ids: Array.from(selectedSources),\n  1371→        }),\n  1372→      })\n  1373→      const result = await response.json()\n  1374→      if (result.error) {\n  1375→        \n  1376→      } else if (result.data) {\n  1377→        setInfographicData(result.data)\n  1378→        setActiveStudyType('infographic' as typeof activeStudyType)\n  1379→        setStudySheetOpen(true)\n  1380→        fetchCreativeOutputs()\n  1381→      }\n  1382→    } catch {\n  1383→      // Error handled silently\n  1384→    } finally {\n  1385→      setGeneratingInfographic(false)\n  1386→    }\n  1387→  }\n  1388→\n  1389→  // Sheet resize handlers\n  1390→  const handleResizeStart = (e: React.MouseEvent) => {\n  1391→    e.preventDefault()\n  1392→    setIsResizing(true)\n  1393→\n  1394→    const startX = e.clientX\n  1395→    const startWidth = sheetWidth\n  1396→\n  1397→    const handleMouseMove = (e: MouseEvent) => {\n  1398→      const diff = startX - e.clientX\n  1399→      const newWidth = Math.min(Math.max(startWidth + diff, 400), window.innerWidth - 50)\n  1400→      setSheetWidth(newWidth)\n  1401→    }\n  1402→\n  1403→    const handleMouseUp = () => {\n  1404→      setIsResizing(false)\n  1405→      document.removeEventListener('mousemove', handleMouseMove)\n  1406→      document.removeEventListener('mouseup', handleMouseUp)\n  1407→    }\n  1408→\n  1409→    document.addEventListener('mousemove', handleMouseMove)\n  1410→    document.addEventListener('mouseup', handleMouseUp)\n  1411→  }\n  1412→\n  1413→  if (loading) {\n  1414→    return (\n  1415→      <div className=\"min-h-screen flex items-center justify-center bg-[var(--bg-primary)]\">\n  1416→        <motion.div\n  1417→          initial={{ opacity: 0, scale: 0.9 }}\n  1418→          animate={{ opacity: 1, scale: 1 }}\n  1419→          className=\"flex flex-col items-center gap-4\"\n  1420→        >\n  1421→          <div className=\"w-16 h-16 rounded-2xl gradient-primary flex items-center justify-center animate-pulse\">\n  1422→            <Sparkles className=\"h-8 w-8 text-white\" />\n  1423→          </div>\n  1424→          <Loader2 className=\"h-6 w-6 animate-spin text-[var(--accent-primary)]\" />\n  1425→          <p className=\"text-sm text-[var(--text-tertiary)]\">Loading notebook...</p>\n  1426→        </motion.div>\n  1427→      </div>\n  1428→    )\n  1429→  }\n  1430→\n  1431→  return (\n  1432→    <div className=\"h-screen flex flex-col bg-[var(--bg-primary)]\">\n  1433→      {/* Header */}\n  1434→      <motion.header\n  1435→        initial={{ opacity: 0, y: -10 }}\n  1436→        animate={{ opacity: 1, y: 0 }}\n  1437→        className=\"h-14 bg-[var(--bg-secondary)] border-b border-[rgba(255,255,255,0.1)] px-4 flex items-center gap-4 shrink-0 sticky top-0 z-50\"\n  1438→      >\n  1439→        <Button\n  1440→          variant=\"ghost\"\n  1441→          size=\"icon\"\n  1442→          onClick={() => router.push('/')}\n  1443→          className=\"h-9 w-9 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n  1444→        >\n  1445→          <ArrowLeft className=\"h-4 w-4\" />\n  1446→        </Button>\n  1447→\n  1448→        <div className=\"flex items-center gap-3\">\n  1449→          <div className=\"w-10 h-10 rounded-xl bg-[var(--bg-tertiary)] flex items-center justify-center text-xl\">\n  1450→            {notebook?.emoji}\n  1451→          </div>\n  1452→          <div>\n  1453→            <h1 className=\"font-semibold text-[var(--text-primary)]\">{notebook?.name}</h1>\n  1454→            {notebook?.description && (\n  1455→              <p className=\"text-xs text-[var(--text-tertiary)] line-clamp-1 max-w-[300px]\">\n  1456→                {notebook.description}\n  1457→              </p>\n  1458→            )}\n  1459→          </div>\n  1460→        </div>\n  1461→\n  1462→        <div className=\"flex items-center gap-2 ml-auto\">\n  1463→          <Badge className=\"bg-[var(--bg-tertiary)] text-[var(--text-secondary)] border-0 text-xs\">\n  1464→            {sources.length} source{sources.length !== 1 ? 's' : ''}\n  1465→          </Badge>\n  1466→          {selectedSources.size > 0 && (\n  1467→            <Badge className=\"bg-[var(--accent-primary)]/20 text-[var(--accent-primary)] border-0 text-xs\">\n  1468→              {selectedSources.size} selected\n  1469→            </Badge>\n  1470→          )}\n  1471→        </div>\n  1472→      </motion.header>\n  1473→\n  1474→      {/* Three Panel Layout */}\n  1475→      <div className=\"flex-1 overflow-hidden\">\n  1476→        <ThreePanelLayout\n  1477→          leftPanelTitle=\"Sources\"\n  1478→          rightPanelTitle=\"Studio\"\n  1479→          leftPanel={\n  1480→            <SourcesPanel\n  1481→              sources={sources}\n  1482→              selectedSources={selectedSources}\n  1483→              onToggleSource={toggleSource}\n  1484→              onSelectAll={selectAllSources}\n  1485→              onAddSource={handleAddSource}\n  1486→              onDeleteSource={handleDeleteSource}\n  1487→              onViewSource={setViewingSource}\n  1488→              uploading={uploading}\n  1489→            />\n  1490→          }\n  1491→          centerPanel={\n  1492→            <ChatPanel\n  1493→              messages={messages}\n  1494→              message={message}\n  1495→              onMessageChange={setMessage}\n  1496→              onSendMessage={sendMessage}\n  1497→              sending={sending}\n  1498→              selectedSourcesCount={selectedSources.size}\n  1499→              totalSourcesCount={sources.length}\n  1500→              onSaveResponse={saveResponseAsNote}\n  1501→              sessions={chatSessions}\n  1502→              currentSessionId={sessionId}\n  1503→              onLoadSession={loadChatSession}\n  1504→              onNewChat={startNewChat}\n  1505→              onDeleteSession={deleteChatSession}\n  1506→              loadingSessions={loadingSessions}\n  1507→            />\n  1508→          }\n  1509→          rightPanel={\n  1510→            <StudioPanel\n  1511→              selectedSourcesCount={selectedSources.size}\n  1512→              selectedSourceIds={Array.from(selectedSources)}\n  1513→              sources={sources.map(s => ({ id: s.id, name: s.name }))}\n  1514→              audioFormat={audioFormat}\n  1515→              onAudioFormatChange={setAudioFormat}\n  1516→              audioInstructions={audioInstructions}\n  1517→              onAudioInstructionsChange={setAudioInstructions}\n  1518→              onGenerateAudio={generateAudio}\n  1519→              generatingAudio={generatingAudio}\n  1520→              videoStyle={videoStyle}\n  1521→              onVideoStyleChange={setVideoStyle}\n  1522→              onGenerateVideo={generateVideo}\n  1523→              generatingVideo={generatingVideo}\n  1524→              researchQuery={researchQuery}\n  1525→              onResearchQueryChange={setResearchQuery}\n  1526→              researchMode={researchMode}\n  1527→              onResearchModeChange={setResearchMode}\n  1528→              onRunResearch={runResearch}\n  1529→              researching={researching}\n  1530→              onGenerateStudyMaterial={handleGenerateStudyMaterial}\n  1531→              generatingFlashcards={generatingFlashcards}\n  1532→              generatingQuiz={generatingQuiz}\n  1533→              generatingStudyGuide={generatingStudyGuide}\n  1534→              generatingFaq={generatingFaq}\n  1535→              generatingMindMap={generatingMindMap}\n  1536→              onGenerateCreativeOutput={handleGenerateCreativeOutput}\n  1537→              generatingDataTable={generatingDataTable}\n  1538→              generatingReport={generatingReport}\n  1539→              generatingSlideDeck={generatingSlideDeck}\n  1540→              generatingInfographic={generatingInfographic}\n  1541→              creativeOutputs={creativeOutputsMeta}\n  1542→              onOpenCreativeOutput={(type) => {\n  1543→                const typeMap: Record<string, typeof activeStudyType> = {\n  1544→                  data_table: 'datatable',\n  1545→                  report: 'report',\n  1546→                  slide_deck: 'slides',\n  1547→                  infographic: 'infographic',\n  1548→                }\n  1549→                setActiveStudyType(typeMap[type] || null)\n  1550→                setStudySheetOpen(true)\n  1551→              }}\n  1552→              studyMaterials={studyMaterialsMeta}\n  1553→              onOpenStudyMaterial={(type) => {\n  1554→                const typeMap: Record<string, typeof activeStudyType> = {\n  1555→                  flashcards: 'flashcards',\n  1556→                  quiz: 'quiz',\n  1557→                  study_guide: 'guide',\n  1558→                  faq: 'faq',\n  1559→                  mind_map: 'mindmap',\n  1560→                }\n  1561→                setActiveStudyType(typeMap[type] || null)\n  1562→                setStudySheetOpen(true)\n  1563→              }}\n  1564→              notesCount={notes.length}\n  1565→              onAddNote={() => setAddNoteOpen(true)}\n  1566→              hasGeneratedAudio={!!generatedAudio}\n  1567→              hasGeneratedVideo={!!generatedVideo}\n  1568→              hasGeneratedResearch={!!generatedResearch}\n  1569→              onOpenAudio={() => { setActiveStudyType('audio'); setStudySheetOpen(true) }}\n  1570→              onOpenVideo={() => { setActiveStudyType('video'); setStudySheetOpen(true) }}\n  1571→              onOpenResearch={() => { setActiveStudyType('research'); setStudySheetOpen(true) }}\n  1572→            />\n  1573→          }\n  1574→        />\n  1575→      </div>\n  1576→\n  1577→      {/* Source Preview Dialog */}\n  1578→      <Dialog open={!!viewingSource} onOpenChange={(open) => !open && setViewingSource(null)}>\n  1579→        <DialogContent className=\"sm:max-w-lg bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n  1580→          <DialogHeader>\n  1581→            <DialogTitle className=\"flex items-center gap-3 text-[var(--text-primary)]\">\n  1582→              <div className=\"w-10 h-10 rounded-lg bg-[var(--bg-tertiary)] flex items-center justify-center\">\n  1583→                <FileText className=\"h-5 w-5\" />\n  1584→              </div>\n  1585→              {viewingSource?.name}\n  1586→            </DialogTitle>\n  1587→            <DialogDescription className=\"text-[var(--text-secondary)]\">\n  1588→              {viewingSource?.type} source\n  1589→            </DialogDescription>\n  1590→          </DialogHeader>\n  1591→\n  1592→          {viewingSource?.metadata && (() => {\n  1593→            const meta = viewingSource.metadata as Record<string, unknown>\n  1594→            if (viewingSource.type === 'text' && meta.content) {\n  1595→              return (\n  1596→                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] text-sm max-h-64 overflow-y-auto\">\n  1597→                  <p className=\"whitespace-pre-wrap text-[var(--text-secondary)]\">\n  1598→                    {String(meta.content)}\n  1599→                  </p>\n  1600→                </div>\n  1601→              )\n  1602→            }\n  1603→            if ((viewingSource.type === 'youtube' || viewingSource.type === 'url') && meta.url) {\n  1604→              return (\n  1605→                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] text-sm max-h-64 overflow-y-auto\">\n  1606→                  <a\n  1607→                    href={String(meta.url)}\n  1608→                    target=\"_blank\"\n  1609→                    rel=\"noopener noreferrer\"\n  1610→                    className=\"text-[var(--accent-primary)] hover:underline break-all\"\n  1611→                  >\n  1612→                    {String(meta.url)}\n  1613→                  </a>\n  1614→                </div>\n  1615→              )\n  1616→            }\n  1617→            return null\n  1618→          })()}\n  1619→        </DialogContent>\n  1620→      </Dialog>\n  1621→\n  1622→      {/* Add Note Dialog */}\n  1623→      <Dialog open={addNoteOpen} onOpenChange={setAddNoteOpen}>\n  1624→        <DialogContent className=\"sm:max-w-md bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n  1625→          <DialogHeader>\n  1626→            <DialogTitle className=\"text-[var(--text-primary)]\">Create Note</DialogTitle>\n  1627→            <DialogDescription className=\"text-[var(--text-secondary)]\">\n  1628→              Write a new note to save your thoughts.\n  1629→            </DialogDescription>\n  1630→          </DialogHeader>\n  1631→          <div className=\"space-y-4 mt-2\">\n  1632→            <div className=\"space-y-2\">\n  1633→              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Title</label>\n  1634→              <Input\n  1635→                placeholder=\"Note title...\"\n  1636→                value={noteTitle}\n  1637→                onChange={(e) => setNoteTitle(e.target.value)}\n  1638→                className=\"h-10 bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-lg\"\n  1639→              />\n  1640→            </div>\n  1641→            <div className=\"space-y-2\">\n  1642→              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Content</label>\n  1643→              <Textarea\n  1644→                placeholder=\"Write your note...\"\n  1645→                value={noteContent}\n  1646→                onChange={(e) => setNoteContent(e.target.value)}\n  1647→                rows={6}\n  1648→                className=\"bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-lg resize-none\"\n  1649→              />\n  1650→            </div>\n  1651→          </div>\n  1652→          <DialogFooter className=\"mt-4\">\n  1653→            <Button\n  1654→              onClick={createNote}\n  1655→              disabled={savingNote}\n  1656→              className=\"rounded-lg bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white\"\n  1657→            >\n  1658→              {savingNote && <Loader2 className=\"h-4 w-4 mr-2 animate-spin\" />}\n  1659→              Create Note\n  1660→            </Button>\n  1661→          </DialogFooter>\n  1662→        </DialogContent>\n  1663→      </Dialog>\n  1664→\n  1665→      {/* Study Materials Sheet */}\n  1666→      <Sheet open={studySheetOpen} onOpenChange={(open) => {\n  1667→        setStudySheetOpen(open)\n  1668→        if (!open) setSheetWidth(576)\n  1669→      }}>\n  1670→        <SheetContent\n  1671→          className=\"overflow-y-auto bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)] p-0\"\n  1672→          style={{ width: sheetWidth, maxWidth: '100vw' }}\n  1673→        >\n  1674→          {/* Resize Handle */}\n  1675→          <div\n  1676→            className={`absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize hover:bg-[var(--accent-primary)]/50 transition-colors z-50 ${isResizing ? 'bg-[var(--accent-primary)]/50' : ''}`}\n  1677→            onMouseDown={handleResizeStart}\n  1678→          />\n  1679→          <div className=\"p-6\">\n  1680→          <SheetHeader>\n  1681→            <div className=\"flex items-center gap-2 pr-8\">\n  1682→              <SheetTitle className=\"flex items-center gap-2 text-[var(--text-primary)] flex-1\">\n  1683→                {activeStudyType === 'flashcards' && <><BookOpen className=\"h-5 w-5 text-blue-500\" /> Flashcards</>}\n  1684→                {activeStudyType === 'quiz' && <><ListChecks className=\"h-5 w-5 text-purple-500\" /> Quiz</>}\n  1685→                {activeStudyType === 'guide' && <><FileText className=\"h-5 w-5 text-orange-500\" /> Study Guide</>}\n  1686→                {activeStudyType === 'faq' && <><HelpCircle className=\"h-5 w-5 text-teal-500\" /> FAQ</>}\n  1687→                {activeStudyType === 'mindmap' && <><Share2 className=\"h-5 w-5 text-cyan-500\" /> Mind Map</>}\n  1688→                {activeStudyType === 'datatable' && <><Table className=\"h-5 w-5 text-emerald-500\" /> Data Table</>}\n  1689→                {activeStudyType === 'report' && <><FileSpreadsheet className=\"h-5 w-5 text-blue-500\" /> Report</>}\n  1690→                {activeStudyType === 'slides' && <><Presentation className=\"h-5 w-5 text-violet-500\" /> Slide Deck</>}\n  1691→                {activeStudyType === 'infographic' && <><ImageIcon className=\"h-5 w-5 text-rose-500\" /> Infographic</>}\n  1692→                {activeStudyType === 'audio' && <><Mic className=\"h-5 w-5 text-orange-500\" /> Audio Overview</>}\n  1693→                {activeStudyType === 'video' && <><Video className=\"h-5 w-5 text-purple-500\" /> Video Overview</>}\n  1694→                {activeStudyType === 'research' && <><Search className=\"h-5 w-5 text-blue-500\" /> Research Report</>}\n  1695→              </SheetTitle>\n  1696→              <Button\n  1697→                variant=\"ghost\"\n  1698→                size=\"icon\"\n  1699→                className=\"h-8 w-8 shrink-0\"\n  1700→                onClick={() => {\n  1701→                  if (sheetWidth < 800) {\n  1702→                    setSheetWidth(900) // Wide\n  1703→                  } else if (sheetWidth < window.innerWidth - 100) {\n  1704→                    setSheetWidth(window.innerWidth - 50) // Full\n  1705→                  } else {\n  1706→                    setSheetWidth(576) // Normal\n  1707→                  }\n  1708→                }}\n  1709→                title={sheetWidth >= window.innerWidth - 100 ? 'Minimize' : 'Expand'}\n  1710→              >\n  1711→                {sheetWidth >= window.innerWidth - 100 ? (\n  1712→                  <Minimize2 className=\"h-4 w-4\" />\n  1713→                ) : (\n  1714→                  <Maximize2 className=\"h-4 w-4\" />\n  1715→                )}\n  1716→              </Button>\n  1717→            </div>\n  1718→            <SheetDescription className=\"text-[var(--text-secondary)]\">\n  1719→              {activeStudyType === 'flashcards' && `${flashcards.length} cards generated from your sources`}\n  1720→              {activeStudyType === 'quiz' && `${quizQuestions.length} questions to test your knowledge`}\n  1721→              {activeStudyType === 'guide' && 'Comprehensive study guide from your sources'}\n  1722→              {activeStudyType === 'faq' && `${faqItems.length} frequently asked questions`}\n  1723→              {activeStudyType === 'mindmap' && 'Interactive visualization of key concepts'}\n  1724→              {activeStudyType === 'datatable' && 'Structured data extracted from your sources'}\n  1725→              {activeStudyType === 'report' && 'Professional document from your sources'}\n  1726→              {activeStudyType === 'slides' && 'Presentation slides from your sources'}\n  1727→              {activeStudyType === 'infographic' && 'Visual infographic from your sources'}\n  1728→              {activeStudyType === 'audio' && 'Podcast-style audio discussion'}\n  1729→              {activeStudyType === 'video' && 'Visual explainer video'}\n  1730→              {activeStudyType === 'research' && 'Deep web research findings'}\n  1731→            </SheetDescription>\n  1732→          </SheetHeader>\n  1733→\n  1734→          <div className=\"mt-6 relative\">\n  1735→            {/* Flashcards View */}\n  1736→            {activeStudyType === 'flashcards' && (\n  1737→              <FlashcardViewer\n  1738→                flashcards={flashcards}\n  1739→                onClose={() => setStudySheetOpen(false)}\n  1740→              />\n  1741→            )}\n  1742→\n  1743→            {/* Quiz View */}\n  1744→            {activeStudyType === 'quiz' && (\n  1745→              <QuizViewer\n  1746→                questions={quizQuestions}\n  1747→                onClose={() => setStudySheetOpen(false)}\n  1748→              />\n  1749→            )}\n  1750→\n  1751→            {/* Study Guide View */}\n  1752→            {activeStudyType === 'guide' && studyGuide && (\n  1753→              <StudyGuideViewer\n  1754→                guide={studyGuide}\n  1755→                onClose={() => setStudySheetOpen(false)}\n  1756→              />\n  1757→            )}\n  1758→\n  1759→            {/* FAQ View */}\n  1760→            {activeStudyType === 'faq' && (\n  1761→              <FAQViewer\n  1762→                items={faqItems}\n  1763→                onClose={() => setStudySheetOpen(false)}\n  1764→              />\n  1765→            )}\n  1766→\n  1767→            {/* Mind Map View */}\n  1768→            {activeStudyType === 'mindmap' && mindMap && (\n  1769→              <MindMapViewer\n  1770→                title={mindMap.title}\n  1771→                nodes={mindMap.nodes}\n  1772→                onClose={() => setStudySheetOpen(false)}\n  1773→              />\n  1774→            )}\n  1775→\n  1776→            {/* Audio View */}\n  1777→            {activeStudyType === 'audio' && (\n  1778→              <AudioPlayer\n  1779→                audio={generatedAudio}\n  1780→                isGenerating={generatingAudio}\n  1781→                onClose={() => setStudySheetOpen(false)}\n  1782→              />\n  1783→            )}\n  1784→\n  1785→            {/* Video View */}\n  1786→            {activeStudyType === 'video' && (\n  1787→              <VideoPlayer\n  1788→                video={generatedVideo}\n  1789→                isGenerating={generatingVideo}\n  1790→                onClose={() => setStudySheetOpen(false)}\n  1791→              />\n  1792→            )}\n  1793→\n  1794→            {/* Research View */}\n  1795→            {activeStudyType === 'research' && (\n  1796→              <ResearchReport\n  1797→                research={generatedResearch}\n  1798→                isResearching={researching}\n  1799→                onClose={() => setStudySheetOpen(false)}\n  1800→              />\n  1801→            )}\n  1802→\n  1803→            {/* Data Table View */}\n  1804→            {activeStudyType === 'datatable' && dataTableData && (\n  1805→              <div className=\"space-y-4\">\n  1806→                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)]\">\n  1807→                  <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{dataTableData.title}</h3>\n  1808→                  <p className=\"text-sm text-[var(--text-secondary)] mb-4\">{dataTableData.description}</p>\n  1809→                  <div className=\"overflow-x-auto\">\n  1810→                    <table className=\"w-full text-sm\">\n  1811→                      <thead>\n  1812→                        <tr className=\"border-b border-[rgba(255,255,255,0.1)]\">\n  1813→                          {dataTableData.columns.map((col) => (\n  1814→                            <th key={col.key} className=\"text-left p-3 font-medium text-[var(--text-primary)]\">\n  1815→                              {col.header}\n  1816→                            </th>\n  1817→                          ))}\n  1818→                        </tr>\n  1819→                      </thead>\n  1820→                      <tbody>\n  1821→                        {dataTableData.rows.map((row, idx) => (\n  1822→                          <tr key={idx} className=\"border-b border-[rgba(255,255,255,0.05)] hover:bg-[var(--bg-secondary)]\">\n  1823→                            {dataTableData.columns.map((col) => (\n  1824→                              <td key={col.key} className=\"p-3 text-[var(--text-secondary)]\">\n  1825→                                {String(row[col.key] ?? '')}\n  1826→                              </td>\n  1827→                            ))}\n  1828→                          </tr>\n  1829→                        ))}\n  1830→                      </tbody>\n  1831→                    </table>\n  1832→                  </div>\n  1833→                </div>\n  1834→              </div>\n  1835→            )}\n  1836→\n  1837→            {/* Report View */}\n  1838→            {activeStudyType === 'report' && reportData && (\n  1839→              <div className=\"space-y-6\">\n  1840→                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)]\">\n  1841→                  <h2 className=\"text-xl font-bold text-[var(--text-primary)] mb-4\">{reportData.title}</h2>\n  1842→                  <div className=\"p-4 rounded-lg bg-[var(--accent-primary)]/10 border border-[var(--accent-primary)]/20 mb-6\">\n  1843→                    <h3 className=\"text-sm font-semibold text-[var(--accent-primary)] mb-2\">Executive Summary</h3>\n  1844→                    <p className=\"text-sm text-[var(--text-secondary)]\">{reportData.executive_summary}</p>\n  1845→                  </div>\n  1846→                  {reportData.sections.map((section, idx) => (\n  1847→                    <div key={idx} className=\"mb-6\">\n  1848→                      <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{section.heading}</h3>\n  1849→                      <p className=\"text-sm text-[var(--text-secondary)] whitespace-pre-wrap\">{section.content}</p>\n  1850→                    </div>\n  1851→                  ))}\n  1852→                  <div className=\"mt-6 p-4 rounded-lg bg-[var(--bg-secondary)]\">\n  1853→                    <h3 className=\"text-sm font-semibold text-[var(--text-primary)] mb-2\">Key Takeaways</h3>\n  1854→                    <ul className=\"list-disc list-inside space-y-1\">\n  1855→                      {reportData.key_takeaways.map((takeaway, idx) => (\n  1856→                        <li key={idx} className=\"text-sm text-[var(--text-secondary)]\">{takeaway}</li>\n  1857→                      ))}\n  1858→                    </ul>\n  1859→                  </div>\n  1860→                </div>\n  1861→              </div>\n  1862→            )}\n  1863→\n  1864→            {/* Slide Deck View */}\n  1865→            {activeStudyType === 'slides' && slideDeckData && (\n  1866→              <div className=\"space-y-4\">\n  1867→                <div className=\"text-center mb-6\">\n  1868→                  <h2 className=\"text-xl font-bold text-[var(--text-primary)]\">{slideDeckData.title}</h2>\n  1869→                  {slideDeckData.subtitle && (\n  1870→                    <p className=\"text-sm text-[var(--text-secondary)] mt-1\">{slideDeckData.subtitle}</p>\n  1871→                  )}\n  1872→                  <Badge className=\"mt-2 bg-[var(--bg-tertiary)] text-[var(--text-secondary)]\">\n  1873→                    {slideDeckData.slides.length} slides\n  1874→                  </Badge>\n  1875→                </div>\n  1876→                <div className=\"space-y-4\">\n  1877→                  {slideDeckData.slides.map((slide) => (\n  1878→                    <div key={slide.slide_number} className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] border border-[rgba(255,255,255,0.1)]\">\n  1879→                      <div className=\"flex items-center gap-2 mb-3\">\n  1880→                        <Badge className=\"bg-[var(--accent-primary)]/20 text-[var(--accent-primary)]\">\n  1881→                          {slide.slide_number}\n  1882→                        </Badge>\n  1883→                        <span className=\"text-xs text-[var(--text-tertiary)] uppercase\">{slide.content_type}</span>\n  1884→                      </div>\n  1885→                      <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{slide.title}</h3>\n  1886→                      <p className=\"text-sm text-[var(--text-secondary)] mb-3\">{slide.main_content}</p>\n  1887→                      {slide.bullet_points && slide.bullet_points.length > 0 && (\n  1888→                        <ul className=\"list-disc list-inside space-y-1 mb-3\">\n  1889→                          {slide.bullet_points.map((point, idx) => (\n  1890→                            <li key={idx} className=\"text-sm text-[var(--text-secondary)]\">{point}</li>\n  1891→                          ))}\n  1892→                        </ul>\n  1893→                      )}\n  1894→                      {slide.speaker_notes && (\n  1895→                        <div className=\"mt-3 p-3 rounded-lg bg-[var(--bg-secondary)] text-xs text-[var(--text-tertiary)]\">\n  1896→                          <span className=\"font-medium\">Speaker notes:</span> {slide.speaker_notes}\n  1897→                        </div>\n  1898→                      )}\n  1899→                    </div>\n  1900→                  ))}\n  1901→                </div>\n  1902→              </div>\n  1903→            )}\n  1904→\n  1905→            {/* Infographic View */}\n  1906→            {activeStudyType === 'infographic' && infographicData && (\n  1907→              <div className=\"space-y-6\">\n  1908→                {/* Header Section */}\n  1909→                <div\n  1910→                  className=\"p-8 rounded-2xl text-center\"\n  1911→                  style={{\n  1912→                    background: `linear-gradient(135deg, ${infographicData.color_scheme[0]}20 0%, ${infographicData.color_scheme[1]}20 100%)`,\n  1913→                    borderLeft: `4px solid ${infographicData.color_scheme[0]}`\n  1914→                  }}\n  1915→                >\n  1916→                  <h2 className=\"text-2xl font-bold text-[var(--text-primary)]\">{infographicData.title}</h2>\n  1917→                  {infographicData.subtitle && (\n  1918→                    <p className=\"text-base text-[var(--text-secondary)] mt-2\">{infographicData.subtitle}</p>\n  1919→                  )}\n  1920→                </div>\n  1921→\n  1922→                {/* Render each section based on type */}\n  1923→                {infographicData.sections.map((section, idx) => {\n  1924→                  const sectionColor = infographicData.color_scheme[idx % infographicData.color_scheme.length]\n  1925→                  const content = section.content as Record<string, unknown>\n  1926→\n  1927→                  // Stats Section\n  1928→                  if (section.section_type === 'stats' && content.items) {\n  1929→                    const items = content.items as Array<{ value: string; label: string; icon?: string }>\n  1930→                    return (\n  1931→                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  1932→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n  1933→                        <div className=\"grid grid-cols-3 gap-4\">\n  1934→                          {items.map((item, i) => (\n  1935→                            <div key={i} className=\"text-center p-4 rounded-lg\" style={{ backgroundColor: `${sectionColor}15` }}>\n  1936→                              <div className=\"text-2xl font-bold\" style={{ color: sectionColor }}>{item.value}</div>\n  1937→                              <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{item.label}</div>\n  1938→                            </div>\n  1939→                          ))}\n  1940→                        </div>\n  1941→                      </div>\n  1942→                    )\n  1943→                  }\n  1944→\n  1945→                  // Timeline Section\n  1946→                  if (section.section_type === 'timeline' && content.events) {\n  1947→                    const events = content.events as Array<{ date: string; title: string; description?: string }>\n  1948→                    return (\n  1949→                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  1950→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n  1951→                        <div className=\"space-y-4\">\n  1952→                          {events.map((event, i) => (\n  1953→                            <div key={i} className=\"flex gap-4\">\n  1954→                              <div className=\"flex flex-col items-center\">\n  1955→                                <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: sectionColor }} />\n  1956→                                {i < events.length - 1 && <div className=\"w-0.5 flex-1 mt-1\" style={{ backgroundColor: `${sectionColor}40` }} />}\n  1957→                              </div>\n  1958→                              <div className=\"flex-1 pb-4\">\n  1959→                                <div className=\"font-semibold\" style={{ color: sectionColor }}>{event.date}</div>\n  1960→                                <div className=\"font-medium text-[var(--text-primary)]\">{event.title}</div>\n  1961→                                {event.description && <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{event.description}</div>}\n  1962→                              </div>\n  1963→                            </div>\n  1964→                          ))}\n  1965→                        </div>\n  1966→                      </div>\n  1967→                    )\n  1968→                  }\n  1969→\n  1970→                  // Process/Steps Section\n  1971→                  if (section.section_type === 'process' && content.steps) {\n  1972→                    const steps = content.steps as Array<{ step: number; title: string; description?: string }>\n  1973→                    return (\n  1974→                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  1975→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n  1976→                        <div className=\"space-y-3\">\n  1977→                          {steps.map((step, i) => (\n  1978→                            <div key={i} className=\"flex gap-4 items-start\">\n  1979→                              <div\n  1980→                                className=\"w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm shrink-0\"\n  1981→                                style={{ backgroundColor: sectionColor }}\n  1982→                              >\n  1983→                                {step.step}\n  1984→                              </div>\n  1985→                              <div>\n  1986→                                <div className=\"font-medium text-[var(--text-primary)]\">{step.title}</div>\n  1987→                                {step.description && <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{step.description}</div>}\n  1988→                              </div>\n  1989→                            </div>\n  1990→                          ))}\n  1991→                        </div>\n  1992→                      </div>\n  1993→                    )\n  1994→                  }\n  1995→\n  1996→                  // Comparison Section\n  1997→                  if (section.section_type === 'comparison' && content.left && content.right) {\n  1998→                    const left = content.left as { label: string; points: string[] }\n  1999→                    const right = content.right as { label: string; points: string[] }\n  2000→                    return (\n  2001→                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  2002→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n  2003→                        <div className=\"grid grid-cols-2 gap-4\">\n  2004→                          <div className=\"p-4 rounded-lg\" style={{ backgroundColor: `${infographicData.color_scheme[0]}15` }}>\n  2005→                            <div className=\"font-semibold mb-3\" style={{ color: infographicData.color_scheme[0] }}>{left.label}</div>\n  2006→                            <ul className=\"space-y-2\">\n  2007→                              {left.points.map((point, i) => (\n  2008→                                <li key={i} className=\"text-sm text-[var(--text-secondary)] flex items-start gap-2\">\n  2009→                                  <span style={{ color: infographicData.color_scheme[0] }}>•</span>\n  2010→                                  {point}\n  2011→                                </li>\n  2012→                              ))}\n  2013→                            </ul>\n  2014→                          </div>\n  2015→                          <div className=\"p-4 rounded-lg\" style={{ backgroundColor: `${infographicData.color_scheme[1]}15` }}>\n  2016→                            <div className=\"font-semibold mb-3\" style={{ color: infographicData.color_scheme[1] }}>{right.label}</div>\n  2017→                            <ul className=\"space-y-2\">\n  2018→                              {right.points.map((point, i) => (\n  2019→                                <li key={i} className=\"text-sm text-[var(--text-secondary)] flex items-start gap-2\">\n  2020→                                  <span style={{ color: infographicData.color_scheme[1] }}>•</span>\n  2021→                                  {point}\n  2022→                                </li>\n  2023→                              ))}\n  2024→                            </ul>\n  2025→                          </div>\n  2026→                        </div>\n  2027→                      </div>\n  2028→                    )\n  2029→                  }\n  2030→\n  2031→                  // List Section\n  2032→                  if (section.section_type === 'list' && content.items) {\n  2033→                    const items = content.items as string[]\n  2034→                    return (\n  2035→                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  2036→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n  2037→                        <ul className=\"space-y-3\">\n  2038→                          {items.map((item, i) => (\n  2039→                            <li key={i} className=\"flex items-start gap-3\">\n  2040→                              <div\n  2041→                                className=\"w-2 h-2 rounded-full mt-2 shrink-0\"\n  2042→                                style={{ backgroundColor: sectionColor }}\n  2043→                              />\n  2044→                              <span className=\"text-[var(--text-secondary)]\">{item}</span>\n  2045→                            </li>\n  2046→                          ))}\n  2047→                        </ul>\n  2048→                      </div>\n  2049→                    )\n  2050→                  }\n  2051→\n  2052→                  // Quote Section\n  2053→                  if (section.section_type === 'quote') {\n  2054→                    const quote = content.quote as string\n  2055→                    const author = content.author as string | undefined\n  2056→                    return (\n  2057→                      <div\n  2058→                        key={idx}\n  2059→                        className=\"p-6 rounded-xl\"\n  2060→                        style={{\n  2061→                          backgroundColor: `${sectionColor}10`,\n  2062→                          borderLeft: `4px solid ${sectionColor}`\n  2063→                        }}\n  2064→                      >\n  2065→                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-3\">{section.title}</h3>}\n  2066→                        <blockquote className=\"text-lg italic text-[var(--text-primary)]\">\"{quote}\"</blockquote>\n  2067→                        {author && <div className=\"mt-2 text-sm text-[var(--text-secondary)]\">— {author}</div>}\n  2068→                      </div>\n  2069→                    )\n  2070→                  }\n  2071→\n  2072→                  // Default/Header/Footer - simple display\n  2073→                  return (\n  2074→                    <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n  2075→                      {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{section.title}</h3>}\n  2076→                      {typeof content.subtitle === 'string' && <p className=\"text-[var(--text-secondary)]\">{content.subtitle}</p>}\n  2077→                      {typeof content.text === 'string' && <p className=\"text-sm text-[var(--text-tertiary)]\">{content.text}</p>}\n  2078→                    </div>\n  2079→                  )\n  2080→                })}\n  2081→\n  2082→                {/* Style suggestion footer */}\n  2083→                <p className=\"text-xs text-[var(--text-tertiary)] text-center italic pt-4 border-t border-[rgba(255,255,255,0.1)]\">\n  2084→                  Design suggestion: {infographicData.style_suggestion}\n  2085→                </p>\n  2086→              </div>\n  2087→            )}\n  2088→          </div>\n  2089→          </div>\n  2090→        </SheetContent>\n  2091→      </Sheet>\n  2092→\n  2093→      {/* Hidden file input */}\n  2094→      <input\n  2095→        ref={fileInputRef}\n  2096→        type=\"file\"\n  2097→        accept=\".pdf,.docx,.txt,.md\"\n  2098→        className=\"hidden\"\n  2099→      />\n  2100→    </div>\n  2101→  )\n  2102→}\n  2103→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"15822b12-9314-470a-9705-42f11b2b3319","timestamp":"2025-12-29T11:50:59.438Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered/frontend/src/app/notebooks/[id]/page.tsx","content":"'use client'\n\nimport { useEffect, useState, useRef } from 'react'\nimport { useParams, useRouter } from 'next/navigation'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { createClient, Notebook, Source, ChatMessage } from '@/lib/supabase'\nimport { chatApi } from '@/lib/api'\nimport { Button } from '@/components/ui/button'\nimport { Input } from '@/components/ui/input'\nimport { Textarea } from '@/components/ui/textarea'\nimport { Badge } from '@/components/ui/badge'\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog'\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from '@/components/ui/sheet'\nimport {\n  ArrowLeft, Loader2, Sparkles, X, RotateCcw,\n  BookOpen, ListChecks, FileText, HelpCircle, Mic, Video, Search, Share2,\n  Maximize2, Minimize2, Table, FileSpreadsheet, Presentation, Image as ImageIcon\n} from 'lucide-react'\n// Toast notifications removed per user request\n// import { toast } from 'sonner'\nimport { User } from '@supabase/supabase-js'\n\nimport { ThreePanelLayout } from '@/components/panels/three-panel-layout'\nimport { SourcesPanel } from '@/components/sources/sources-panel'\nimport { ChatPanel } from '@/components/chat/chat-panel'\nimport { StudioPanel } from '@/components/studio/studio-panel'\nimport type { GenerationConfig } from '@/components/studio/generation-config-dialog'\n\n// Study viewers\nimport { FlashcardViewer } from '@/components/study/flashcard-viewer'\nimport { QuizViewer } from '@/components/study/quiz-viewer'\nimport { StudyGuideViewer } from '@/components/study/study-guide-viewer'\nimport { FAQViewer } from '@/components/study/faq-viewer'\nimport { MindMapViewer } from '@/components/study/mind-map-viewer'\n\n// Studio viewers\nimport { AudioPlayer } from '@/components/studio/audio-player'\nimport { VideoPlayer } from '@/components/studio/video-player'\nimport { ResearchReport } from '@/components/studio/research-report'\n\ninterface LocalNote {\n  id: string\n  notebook_id: string\n  type: 'written' | 'saved_response'\n  title: string | null\n  content: string | null\n  tags: string[]\n  is_pinned: boolean\n  created_at: string\n  updated_at: string\n}\n\nexport default function NotebookPage() {\n  const params = useParams()\n  const router = useRouter()\n  const notebookId = params.id as string\n  const supabase = createClient()\n\n  // Core state\n  const [user, setUser] = useState<User | null>(null)\n  const [notebook, setNotebook] = useState<Notebook | null>(null)\n  const [sources, setSources] = useState<Source[]>([])\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const [notes, setNotes] = useState<LocalNote[]>([])\n  const [loading, setLoading] = useState(true)\n\n  // Chat state\n  const [sending, setSending] = useState(false)\n  const [message, setMessage] = useState('')\n  const [selectedSources, setSelectedSources] = useState<Set<string>>(new Set())\n  const [sessionId, setSessionId] = useState<string | null>(null)\n  const [chatSessions, setChatSessions] = useState<Array<{\n    id: string\n    title: string\n    created_at: string\n    updated_at: string\n    message_count: number\n  }>>([])\n  const [loadingSessions, setLoadingSessions] = useState(false)\n\n  // Source state\n  const [viewingSource, setViewingSource] = useState<Source | null>(null)\n  const [uploading, setUploading] = useState(false)\n\n  // Notes state\n  const [addNoteOpen, setAddNoteOpen] = useState(false)\n  const [noteTitle, setNoteTitle] = useState('')\n  const [noteContent, setNoteContent] = useState('')\n  const [savingNote, setSavingNote] = useState(false)\n\n  // Audio state\n  const [audioFormat, setAudioFormat] = useState('deep_dive')\n  const [audioInstructions, setAudioInstructions] = useState('')\n  const [generatingAudio, setGeneratingAudio] = useState(false)\n\n  // Video state\n  const [videoStyle, setVideoStyle] = useState('explainer')\n  const [generatingVideo, setGeneratingVideo] = useState(false)\n\n  // Research state\n  const [researchQuery, setResearchQuery] = useState('')\n  const [researchMode, setResearchMode] = useState('fast')\n  const [researching, setResearching] = useState(false)\n\n  // Study loading states\n  const [generatingFlashcards, setGeneratingFlashcards] = useState(false)\n  const [generatingQuiz, setGeneratingQuiz] = useState(false)\n  const [generatingStudyGuide, setGeneratingStudyGuide] = useState(false)\n  const [generatingFaq, setGeneratingFaq] = useState(false)\n  const [generatingMindMap, setGeneratingMindMap] = useState(false)\n\n  // Creative outputs loading states\n  const [generatingDataTable, setGeneratingDataTable] = useState(false)\n  const [generatingReport, setGeneratingReport] = useState(false)\n  const [generatingSlideDeck, setGeneratingSlideDeck] = useState(false)\n  const [generatingInfographic, setGeneratingInfographic] = useState(false)\n\n  // Study results\n  const [flashcards, setFlashcards] = useState<Array<{ id: string; front: string; back: string }>>([])\n  const [quizQuestions, setQuizQuestions] = useState<Array<{ id: string; question: string; options: string[]; correct_index: number; explanation: string }>>([])\n  const [studyGuide, setStudyGuide] = useState<{ title: string; sections: Array<{ heading: string; content: string }> } | null>(null)\n  const [faqItems, setFaqItems] = useState<Array<{ question: string; answer: string }>>([])\n  const [mindMap, setMindMap] = useState<{ title: string; nodes: Array<{ id: string; label: string; description?: string; children?: Array<{ id: string; label: string; description?: string; children?: Array<{ id: string; label: string; description?: string }> }> }> } | null>(null)\n\n  // Creative outputs data\n  const [dataTableData, setDataTableData] = useState<{\n    title: string\n    description: string\n    columns: Array<{ header: string; key: string; type: string }>\n    rows: Array<Record<string, string | number | boolean>>\n  } | null>(null)\n  const [reportData, setReportData] = useState<{\n    title: string\n    executive_summary: string\n    sections: Array<{ heading: string; content: string }>\n    key_takeaways: string[]\n  } | null>(null)\n  const [slideDeckData, setSlideDeckData] = useState<{\n    title: string\n    subtitle?: string\n    slides: Array<{ slide_number: number; title: string; content_type: string; main_content: string; bullet_points?: string[]; speaker_notes?: string }>\n    theme_suggestion: string\n  } | null>(null)\n  const [infographicData, setInfographicData] = useState<{\n    title: string\n    subtitle?: string\n    color_scheme: string[]\n    sections: Array<{ section_type: string; title?: string; content: Record<string, unknown> }>\n    style_suggestion: string\n  } | null>(null)\n\n  // Study materials metadata (for UI display)\n  const [studyMaterialsMeta, setStudyMaterialsMeta] = useState<Array<{\n    id: string\n    type: string\n    sourceIds: string[]\n    sourceNames: string[]\n    createdAt: string\n    itemCount?: number\n  }>>([])\n\n  // Creative outputs metadata (for UI display)\n  const [creativeOutputsMeta, setCreativeOutputsMeta] = useState<Array<{\n    id: string\n    type: string\n    title: string\n    status: string\n    createdAt: string\n    content?: Record<string, unknown>\n  }>>([])\n\n  const [currentFlashcard, setCurrentFlashcard] = useState(0)\n  const [showFlashcardBack, setShowFlashcardBack] = useState(false)\n  const [currentQuizQuestion, setCurrentQuizQuestion] = useState(0)\n  const [selectedAnswer, setSelectedAnswer] = useState<number | null>(null)\n  const [showQuizAnswer, setShowQuizAnswer] = useState(false)\n\n  // Study materials sheet\n  const [studySheetOpen, setStudySheetOpen] = useState(false)\n  const [sheetWidth, setSheetWidth] = useState(576) // Default width in pixels\n  const [isResizing, setIsResizing] = useState(false)\n  const [activeStudyType, setActiveStudyType] = useState<'flashcards' | 'quiz' | 'guide' | 'faq' | 'mindmap' | 'audio' | 'video' | 'research' | 'datatable' | 'report' | 'slides' | 'infographic' | null>(null)\n\n  // Generated content state\n  const [generatedAudio, setGeneratedAudio] = useState<{\n    id: string\n    format: string\n    status: string\n    script?: string\n    audio_url?: string\n    duration_seconds?: number\n    created_at: string\n  } | null>(null)\n\n  const [generatedVideo, setGeneratedVideo] = useState<{\n    id: string\n    style: string\n    status: string\n    script?: string\n    video_url?: string\n    thumbnail_url?: string\n    duration_seconds?: number\n    created_at: string\n  } | null>(null)\n\n  const [generatedResearch, setGeneratedResearch] = useState<{\n    id: string\n    query: string\n    mode: string\n    status: string\n    progress_message?: string\n    sources_found_count?: number\n    sources_analyzed_count?: number\n    report_content?: string\n    report_citations?: { title: string; url: string }[]\n    created_at: string\n    completed_at?: string\n  } | null>(null)\n\n  // File input ref\n  const fileInputRef = useRef<HTMLInputElement>(null)\n\n  // Initialize\n  useEffect(() => {\n    const init = async () => {\n      const { data: { user } } = await supabase.auth.getUser()\n      if (!user) {\n        router.push('/auth/login')\n        return\n      }\n      setUser(user)\n      await Promise.all([fetchNotebook(), fetchSources(), fetchNotes()])\n      setLoading(false)\n      // Fetch study materials, generated content, creative outputs, and chat sessions after main load (non-blocking)\n      fetchStudyMaterials()\n      fetchGeneratedContent()\n      fetchCreativeOutputs()\n      fetchChatSessions()\n    }\n    init()\n  }, [notebookId])\n\n  // Fetch chat sessions\n  const fetchChatSessions = async () => {\n    setLoadingSessions(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const result = await response.json()\n      if (result.data) {\n        setChatSessions(result.data)\n      }\n    } catch (error) {\n      console.error('Failed to fetch chat sessions:', error)\n    }\n    setLoadingSessions(false)\n  }\n\n  // Load a chat session\n  const loadChatSession = async (loadSessionId: string) => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions/${loadSessionId}`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const result = await response.json()\n      if (result.data) {\n        setSessionId(loadSessionId)\n        setMessages(result.data.messages || [])\n      }\n    } catch (error) {\n      console.error('Failed to load chat session:', error)\n      \n    }\n  }\n\n  // Start a new chat\n  const startNewChat = () => {\n    setSessionId(null)\n    setMessages([])\n    setMessage('')\n  }\n\n  // Delete a chat session\n  const deleteChatSession = async (deleteSessionId: string) => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/chat/sessions?session_id=${deleteSessionId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      if (response.ok) {\n        setChatSessions(prev => prev.filter(s => s.id !== deleteSessionId))\n        \n        // If we deleted the current session, start a new chat\n        if (deleteSessionId === sessionId) {\n          startNewChat()\n        }\n      }\n    } catch (error) {\n      console.error('Failed to delete chat session:', error)\n      \n    }\n  }\n\n  // Load selected sources from localStorage after sources are loaded\n  useEffect(() => {\n    if (sources.length > 0 && !loading) {\n      const savedSelection = localStorage.getItem(`notebook-${notebookId}-selected-sources`)\n      if (savedSelection) {\n        try {\n          const savedIds = JSON.parse(savedSelection) as string[]\n          // Only select sources that still exist\n          const validIds = savedIds.filter(id => sources.some(s => s.id === id))\n          if (validIds.length > 0) {\n            setSelectedSources(new Set(validIds))\n          }\n        } catch {\n          // Invalid JSON, ignore\n        }\n      }\n    }\n  }, [sources, loading, notebookId])\n\n  // Save selected sources to localStorage whenever they change\n  useEffect(() => {\n    if (!loading && sources.length > 0) {\n      const selectedArray = Array.from(selectedSources)\n      localStorage.setItem(`notebook-${notebookId}-selected-sources`, JSON.stringify(selectedArray))\n    }\n  }, [selectedSources, notebookId, loading, sources.length])\n\n  // Fetch existing audio/video/research content\n  const fetchGeneratedContent = async () => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n\n      // Fetch audio\n      const audioResponse = await fetch(`/api/notebooks/${notebookId}/audio`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const audioResult = await audioResponse.json()\n      if (audioResult.data && audioResult.data.length > 0) {\n        // Get the most recent audio\n        setGeneratedAudio(audioResult.data[0])\n      }\n\n      // Fetch video\n      const videoResponse = await fetch(`/api/notebooks/${notebookId}/video`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const videoResult = await videoResponse.json()\n      if (videoResult.data && videoResult.data.length > 0) {\n        setGeneratedVideo(videoResult.data[0])\n      }\n\n      // Fetch research\n      const researchResponse = await fetch(`/api/notebooks/${notebookId}/research`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const researchResult = await researchResponse.json()\n      if (researchResult.data && researchResult.data.length > 0) {\n        setGeneratedResearch(researchResult.data[0])\n      }\n    } catch (error) {\n      console.error('Failed to fetch generated content:', error)\n    }\n  }\n\n  // Fetch existing creative outputs (data tables, reports, slides, infographics)\n  const fetchCreativeOutputs = async () => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const result = await response.json()\n\n      if (result.data && Array.isArray(result.data)) {\n        // Group by type and get the latest of each\n        const outputsByType: Record<string, typeof result.data[0]> = {}\n        for (const output of result.data) {\n          if (output.status === 'completed' && !outputsByType[output.type]) {\n            outputsByType[output.type] = output\n          }\n        }\n\n        // Build metadata array\n        const metaArray = Object.values(outputsByType).map((output) => ({\n          id: output.id,\n          type: output.type,\n          title: output.title || output.type.replace('_', ' '),\n          status: output.status,\n          createdAt: output.created_at,\n          content: output.content,\n        }))\n        setCreativeOutputsMeta(metaArray)\n\n        // Populate state with the latest content of each type\n        for (const output of Object.values(outputsByType)) {\n          if (output.type === 'data_table' && output.content) {\n            setDataTableData(output.content as typeof dataTableData)\n          } else if (output.type === 'report' && output.content) {\n            setReportData(output.content as typeof reportData)\n          } else if (output.type === 'slide_deck' && output.content) {\n            setSlideDeckData(output.content as typeof slideDeckData)\n          } else if (output.type === 'infographic' && output.content) {\n            setInfographicData(output.content as typeof infographicData)\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Failed to fetch creative outputs:', error)\n    }\n  }\n\n  // Fetch existing study materials from Supabase\n  const fetchStudyMaterials = async (sourcesData?: Source[]) => {\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        headers: {\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n      })\n      const result = await response.json()\n\n      if (result.data && Array.isArray(result.data)) {\n        // Group materials by type and get the latest of each\n        const materialsByType: Record<string, typeof result.data[0]> = {}\n        for (const material of result.data) {\n          if (!materialsByType[material.type]) {\n            materialsByType[material.type] = material\n          }\n        }\n\n        // Build metadata array for UI\n        const currentSources = sourcesData || sources\n        const metaArray = Object.values(materialsByType).map((material) => {\n          const sourceIds = material.source_ids || []\n          const sourceNames = sourceIds.map((id: string) => {\n            const source = currentSources.find(s => s.id === id)\n            return source?.name || 'Unknown source'\n          })\n\n          // Calculate item count based on type\n          let itemCount = 0\n          if (material.type === 'flashcards') itemCount = material.data?.flashcards?.length || 0\n          else if (material.type === 'quiz') itemCount = material.data?.questions?.length || 0\n          else if (material.type === 'faq') itemCount = material.data?.faq?.length || 0\n\n          return {\n            id: material.id,\n            type: material.type,\n            sourceIds,\n            sourceNames,\n            createdAt: material.created_at,\n            itemCount,\n          }\n        })\n        setStudyMaterialsMeta(metaArray)\n\n        // Populate state with cached data\n        if (materialsByType.flashcards?.data?.flashcards) {\n          setFlashcards(materialsByType.flashcards.data.flashcards)\n        }\n        if (materialsByType.quiz?.data?.questions) {\n          setQuizQuestions(materialsByType.quiz.data.questions)\n        }\n        if (materialsByType.study_guide?.data) {\n          setStudyGuide(materialsByType.study_guide.data)\n        }\n        if (materialsByType.faq?.data?.faq) {\n          setFaqItems(materialsByType.faq.data.faq)\n        }\n        if (materialsByType.mind_map?.data) {\n          setMindMap(materialsByType.mind_map.data)\n        }\n      }\n    } catch (error) {\n      console.error('Failed to fetch study materials:', error)\n    }\n  }\n\n  const fetchNotebook = async () => {\n    const { data, error } = await supabase\n      .from('notebooks')\n      .select('*')\n      .eq('id', notebookId)\n      .single()\n\n    if (error || !data) {\n      \n      router.push('/')\n      return\n    }\n    setNotebook(data)\n  }\n\n  const fetchSources = async () => {\n    const { data } = await supabase\n      .from('sources')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: false })\n\n    setSources(data || [])\n  }\n\n  const fetchNotes = async () => {\n    const { data } = await supabase\n      .from('notes')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('is_pinned', { ascending: false })\n      .order('created_at', { ascending: false })\n\n    setNotes(data || [])\n  }\n\n  // Source handlers\n  const handleAddSource = async (type: string, data: { input: string; name?: string; file?: File }) => {\n    setUploading(true)\n\n    if (type === 'file') {\n      // Handle file upload - file is passed from the sources panel\n      const file = data.file\n      if (file) {\n        const fileExt = file.name.split('.').pop()?.toLowerCase()\n        const filePath = `${user?.id}/${notebookId}/${Date.now()}.${fileExt}`\n\n        const { error: uploadError } = await supabase.storage\n          .from('sources')\n          .upload(filePath, file)\n\n        if (uploadError) {\n          console.error('Upload error:', uploadError)\n          \n          setUploading(false)\n          return\n        }\n\n        const { data: sourceData, error } = await supabase\n          .from('sources')\n          .insert({\n            notebook_id: notebookId,\n            type: fileExt === 'pdf' ? 'pdf' : fileExt === 'docx' ? 'docx' : 'txt',\n            name: file.name,\n            status: 'ready',\n            file_path: filePath,\n            original_filename: file.name,\n            mime_type: file.type,\n            file_size_bytes: file.size,\n          })\n          .select()\n          .single()\n\n        if (error) {\n          console.error('Source creation error:', error)\n          \n        } else {\n          \n          setSources([sourceData, ...sources])\n        }\n      } else {\n        \n      }\n    } else {\n      let sourceData: Partial<Source> = {\n        notebook_id: notebookId,\n        status: 'ready',\n      }\n\n      if (type === 'youtube') {\n        sourceData = {\n          ...sourceData,\n          type: 'youtube',\n          name: data.name || `YouTube: ${data.input}`,\n          metadata: { url: data.input },\n        }\n      } else if (type === 'url') {\n        sourceData = {\n          ...sourceData,\n          type: 'url',\n          name: data.name || data.input,\n          metadata: { url: data.input },\n        }\n      } else if (type === 'text') {\n        sourceData = {\n          ...sourceData,\n          type: 'text',\n          name: data.name || 'Pasted Text',\n          metadata: { content: data.input },\n        }\n      }\n\n      const { data: newSource, error } = await supabase\n        .from('sources')\n        .insert(sourceData)\n        .select()\n        .single()\n\n      if (error) {\n        \n      } else {\n        \n        setSources([newSource, ...sources])\n      }\n    }\n\n    setUploading(false)\n  }\n\n  const handleDeleteSource = async (sourceId: string) => {\n    const { error } = await supabase\n      .from('sources')\n      .delete()\n      .eq('id', sourceId)\n\n    if (error) {\n      \n    } else {\n      setSources(sources.filter(s => s.id !== sourceId))\n      selectedSources.delete(sourceId)\n      setSelectedSources(new Set(selectedSources))\n      \n    }\n  }\n\n  const toggleSource = (sourceId: string) => {\n    const newSelected = new Set(selectedSources)\n    if (newSelected.has(sourceId)) {\n      newSelected.delete(sourceId)\n    } else {\n      newSelected.add(sourceId)\n    }\n    setSelectedSources(newSelected)\n  }\n\n  const selectAllSources = () => {\n    if (selectedSources.size === sources.length) {\n      setSelectedSources(new Set())\n    } else {\n      setSelectedSources(new Set(sources.map(s => s.id)))\n    }\n  }\n\n  // Chat handlers\n  const sendMessage = async (overrideMessage?: string) => {\n    const messageToSend = overrideMessage || message\n    if (!messageToSend.trim() || sending) return\n\n    setSending(true)\n    const userMessage: ChatMessage = {\n      id: crypto.randomUUID(),\n      session_id: sessionId || '',\n      role: 'user',\n      content: messageToSend,\n      citations: [],\n      source_ids_used: Array.from(selectedSources),\n      model_used: null,\n      input_tokens: null,\n      output_tokens: null,\n      cost_usd: null,\n      created_at: new Date().toISOString(),\n    }\n    setMessages(prev => [...prev, userMessage])\n    setMessage('')\n\n    try {\n      const response = await chatApi.sendMessage(notebookId, {\n        message: userMessage.content,\n        source_ids: Array.from(selectedSources),\n        session_id: sessionId || undefined,\n      })\n\n      const isNewSession = !sessionId\n      if (response.data.session_id) {\n        setSessionId(response.data.session_id)\n      }\n\n      const aiMessage: ChatMessage = {\n        id: response.data.message_id,\n        session_id: response.data.session_id,\n        role: 'assistant',\n        content: response.data.content,\n        citations: response.data.citations,\n        source_ids_used: Array.from(selectedSources),\n        model_used: response.usage?.model_used || 'gemini-2.0-flash',\n        input_tokens: response.usage?.input_tokens || 0,\n        output_tokens: response.usage?.output_tokens || 0,\n        cost_usd: response.usage?.cost_usd || 0,\n        created_at: new Date().toISOString(),\n      }\n      setMessages(prev => [...prev, aiMessage])\n\n      // Refresh chat sessions if this was a new session\n      if (isNewSession) {\n        fetchChatSessions()\n      }\n    } catch {\n      \n      setMessages(prev => prev.filter(m => m.id !== userMessage.id))\n    }\n    setSending(false)\n  }\n\n  const saveResponseAsNote = async (msg: ChatMessage) => {\n    const { data, error } = await supabase\n      .from('notes')\n      .insert({\n        notebook_id: notebookId,\n        type: 'saved_response',\n        title: `Saved Response - ${new Date().toLocaleDateString()}`,\n        content: msg.content,\n        tags: [],\n      })\n      .select()\n      .single()\n\n    if (error) {\n      \n    } else {\n      \n      setNotes([data, ...notes])\n    }\n  }\n\n  // Notes handlers\n  const createNote = async () => {\n    if (!noteTitle.trim() && !noteContent.trim()) return\n\n    setSavingNote(true)\n    const { data, error } = await supabase\n      .from('notes')\n      .insert({\n        notebook_id: notebookId,\n        type: 'written',\n        title: noteTitle || 'Untitled Note',\n        content: noteContent,\n        tags: [],\n      })\n      .select()\n      .single()\n\n    if (error) {\n      \n    } else {\n      \n      setNotes([data, ...notes])\n      setNoteTitle('')\n      setNoteContent('')\n      setAddNoteOpen(false)\n    }\n    setSavingNote(false)\n  }\n\n  // Audio generation\n  const generateAudio = async () => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n\n    setGeneratingAudio(true)\n    setActiveStudyType('audio')\n    setStudySheetOpen(true)\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/audio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          format: audioFormat,\n          source_ids: Array.from(selectedSources),\n          custom_instructions: audioInstructions || undefined,\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setGeneratedAudio(result.data)\n        \n      }\n    } catch {\n      \n    }\n    setGeneratingAudio(false)\n  }\n\n  // Video generation\n  const generateVideo = async () => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n\n    setGeneratingVideo(true)\n    setActiveStudyType('video')\n    setStudySheetOpen(true)\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/video`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          style: videoStyle,\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setGeneratedVideo(result.data)\n        \n      }\n    } catch {\n      \n    }\n    setGeneratingVideo(false)\n  }\n\n  // Research generation\n  const runResearch = async () => {\n    if (!researchQuery.trim()) {\n      \n      return\n    }\n\n    setResearching(true)\n    setActiveStudyType('research')\n    setStudySheetOpen(true)\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/research`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          query: researchQuery,\n          mode: researchMode,\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setGeneratedResearch(result.data)\n        \n        setResearchQuery('')\n      }\n    } catch {\n      \n    }\n    setResearching(false)\n  }\n\n  // Study material generation handlers\n  const handleGenerateFlashcards = async () => {\n    setGeneratingFlashcards(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'flashcards',\n          source_ids: Array.from(selectedSources),\n          count: 5,\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data?.flashcards) {\n        setFlashcards(result.data.flashcards)\n        setCurrentFlashcard(0)\n        setShowFlashcardBack(false)\n        setActiveStudyType('flashcards')\n        setStudySheetOpen(true)\n        fetchStudyMaterials()\n        \n      }\n    } catch {\n      \n    } finally {\n      setGeneratingFlashcards(false)\n    }\n  }\n\n  const handleGenerateQuiz = async () => {\n    setGeneratingQuiz(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'quiz',\n          source_ids: Array.from(selectedSources),\n          count: 5,\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data?.questions) {\n        setQuizQuestions(result.data.questions)\n        setCurrentQuizQuestion(0)\n        setSelectedAnswer(null)\n        setShowQuizAnswer(false)\n        setActiveStudyType('quiz')\n        setStudySheetOpen(true)\n        fetchStudyMaterials()\n        \n      }\n    } catch {\n      \n    } finally {\n      setGeneratingQuiz(false)\n    }\n  }\n\n  const handleGenerateStudyGuide = async () => {\n    setGeneratingStudyGuide(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'study-guide',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data?.sections) {\n        setStudyGuide(result.data)\n        setActiveStudyType('guide')\n        setStudySheetOpen(true)\n        fetchStudyMaterials()\n        \n      }\n    } catch {\n      \n    } finally {\n      setGeneratingStudyGuide(false)\n    }\n  }\n\n  const handleGenerateFaq = async () => {\n    setGeneratingFaq(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'faq',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data?.faq) {\n        setFaqItems(result.data.faq)\n        setActiveStudyType('faq')\n        setStudySheetOpen(true)\n        fetchStudyMaterials()\n        \n      }\n    } catch {\n      \n    } finally {\n      setGeneratingFaq(false)\n    }\n  }\n\n  const handleGenerateMindMap = async () => {\n    setGeneratingMindMap(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'mind-map',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n\n      } else if (result.data?.nodes) {\n        setMindMap(result.data)\n        setActiveStudyType('mindmap')\n        setStudySheetOpen(true)\n        // Refresh metadata to show updated material\n        fetchStudyMaterials()\n\n      }\n    } catch {\n\n    } finally {\n      setGeneratingMindMap(false)\n    }\n  }\n\n  // Unified study material handler with config\n  const handleGenerateStudyMaterial = async (config: GenerationConfig) => {\n    const sourceIds = config.sourceIds && config.sourceIds.length > 0\n      ? config.sourceIds\n      : Array.from(selectedSources)\n\n    if (sourceIds.length === 0) return\n\n    // Set loading state based on type\n    const setLoading = {\n      'flashcards': setGeneratingFlashcards,\n      'quiz': setGeneratingQuiz,\n      'study-guide': setGeneratingStudyGuide,\n      'faq': setGeneratingFaq,\n      'mind-map': setGeneratingMindMap,\n    }[config.type]\n    setLoading?.(true)\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n\n      // Build request body with all config options\n      const requestBody: Record<string, unknown> = {\n        type: config.type,\n        source_ids: sourceIds,\n      }\n\n      // Add optional config fields\n      if (config.count) requestBody.count = config.count\n      if (config.difficulty) requestBody.difficulty = config.difficulty\n      if (config.focusArea) requestBody.focus_area = config.focusArea\n      if (config.customInstructions) requestBody.custom_instructions = config.customInstructions\n      if (config.questionTypes) requestBody.question_types = config.questionTypes\n\n      const response = await fetch(`/api/notebooks/${notebookId}/study`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify(requestBody),\n      })\n      const result = await response.json()\n\n      if (result.error) {\n        console.error('Generation error:', result.error)\n      } else if (result.data) {\n        // Handle each type's response\n        switch (config.type) {\n          case 'flashcards':\n            if (result.data.flashcards) {\n              setFlashcards(result.data.flashcards)\n              setCurrentFlashcard(0)\n              setShowFlashcardBack(false)\n              setActiveStudyType('flashcards')\n              setStudySheetOpen(true)\n            }\n            break\n          case 'quiz':\n            if (result.data.questions) {\n              setQuizQuestions(result.data.questions)\n              setCurrentQuizQuestion(0)\n              setSelectedAnswer(null)\n              setShowQuizAnswer(false)\n              setActiveStudyType('quiz')\n              setStudySheetOpen(true)\n            }\n            break\n          case 'study-guide':\n            if (result.data.sections) {\n              setStudyGuide(result.data)\n              setActiveStudyType('guide')\n              setStudySheetOpen(true)\n            }\n            break\n          case 'faq':\n            if (result.data.faq) {\n              setFaqItems(result.data.faq)\n              setActiveStudyType('faq')\n              setStudySheetOpen(true)\n            }\n            break\n          case 'mind-map':\n            if (result.data.nodes) {\n              setMindMap(result.data)\n              setActiveStudyType('mindmap')\n              setStudySheetOpen(true)\n            }\n            break\n        }\n        fetchStudyMaterials()\n      }\n    } catch (error) {\n      console.error('Study material generation failed:', error)\n    } finally {\n      setLoading?.(false)\n    }\n  }\n\n  // Unified creative output handler with config\n  const handleGenerateCreativeOutput = async (config: GenerationConfig) => {\n    const sourceIds = config.sourceIds && config.sourceIds.length > 0\n      ? config.sourceIds\n      : Array.from(selectedSources)\n\n    if (sourceIds.length === 0) return\n\n    // Set loading state based on type\n    const setLoading = {\n      'data_table': setGeneratingDataTable,\n      'report': setGeneratingReport,\n      'slide_deck': setGeneratingSlideDeck,\n      'infographic': setGeneratingInfographic,\n    }[config.type]\n    setLoading?.(true)\n\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n\n      // Build request body with all config options\n      const requestBody: Record<string, unknown> = {\n        type: config.type,\n        source_ids: sourceIds,\n      }\n\n      // Add optional config fields\n      if (config.customInstructions) requestBody.custom_instructions = config.customInstructions\n      if (config.focusArea) requestBody.focus_area = config.focusArea\n      if (config.reportType) requestBody.report_type = config.reportType\n      if (config.tone) requestBody.tone = config.tone\n      if (config.slideCount) requestBody.slide_count = config.slideCount\n      if (config.style) requestBody.style = config.style\n\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify(requestBody),\n      })\n      const result = await response.json()\n\n      if (result.error) {\n        console.error('Generation error:', result.error)\n      } else if (result.data) {\n        // Handle each type's response\n        switch (config.type) {\n          case 'data_table':\n            setDataTableData(result.data)\n            setActiveStudyType('datatable')\n            setStudySheetOpen(true)\n            break\n          case 'report':\n            setReportData(result.data)\n            setActiveStudyType('report')\n            setStudySheetOpen(true)\n            break\n          case 'slide_deck':\n            setSlideDeckData(result.data)\n            setActiveStudyType('slides')\n            setStudySheetOpen(true)\n            break\n          case 'infographic':\n            setInfographicData(result.data)\n            setActiveStudyType('infographic')\n            setStudySheetOpen(true)\n            break\n        }\n        fetchCreativeOutputs()\n      }\n    } catch (error) {\n      console.error('Creative output generation failed:', error)\n    } finally {\n      setLoading?.(false)\n    }\n  }\n\n  // Creative output generation handlers (legacy - kept for compatibility)\n  const handleGenerateDataTable = async () => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n    setGeneratingDataTable(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'data_table',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setDataTableData(result.data)\n        setActiveStudyType('datatable' as typeof activeStudyType)\n        setStudySheetOpen(true)\n        fetchCreativeOutputs()\n      }\n    } catch {\n      // Error handled silently\n    } finally {\n      setGeneratingDataTable(false)\n    }\n  }\n\n  const handleGenerateReport = async (reportType: string) => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n    setGeneratingReport(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'report',\n          source_ids: Array.from(selectedSources),\n          report_type: reportType,\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setReportData(result.data)\n        setActiveStudyType('report' as typeof activeStudyType)\n        setStudySheetOpen(true)\n        fetchCreativeOutputs()\n      }\n    } catch {\n      // Error handled silently\n    } finally {\n      setGeneratingReport(false)\n    }\n  }\n\n  const handleGenerateSlideDeck = async () => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n    setGeneratingSlideDeck(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'slide_deck',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setSlideDeckData(result.data)\n        setActiveStudyType('slides' as typeof activeStudyType)\n        setStudySheetOpen(true)\n        fetchCreativeOutputs()\n      }\n    } catch {\n      // Error handled silently\n    } finally {\n      setGeneratingSlideDeck(false)\n    }\n  }\n\n  const handleGenerateInfographic = async () => {\n    if (selectedSources.size === 0) {\n      \n      return\n    }\n    setGeneratingInfographic(true)\n    try {\n      const { data: { session } } = await supabase.auth.getSession()\n      const response = await fetch(`/api/notebooks/${notebookId}/studio`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${session?.access_token}`,\n        },\n        body: JSON.stringify({\n          type: 'infographic',\n          source_ids: Array.from(selectedSources),\n        }),\n      })\n      const result = await response.json()\n      if (result.error) {\n        \n      } else if (result.data) {\n        setInfographicData(result.data)\n        setActiveStudyType('infographic' as typeof activeStudyType)\n        setStudySheetOpen(true)\n        fetchCreativeOutputs()\n      }\n    } catch {\n      // Error handled silently\n    } finally {\n      setGeneratingInfographic(false)\n    }\n  }\n\n  // Sheet resize handlers\n  const handleResizeStart = (e: React.MouseEvent) => {\n    e.preventDefault()\n    setIsResizing(true)\n\n    const startX = e.clientX\n    const startWidth = sheetWidth\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const diff = startX - e.clientX\n      const newWidth = Math.min(Math.max(startWidth + diff, 400), window.innerWidth - 50)\n      setSheetWidth(newWidth)\n    }\n\n    const handleMouseUp = () => {\n      setIsResizing(false)\n      document.removeEventListener('mousemove', handleMouseMove)\n      document.removeEventListener('mouseup', handleMouseUp)\n    }\n\n    document.addEventListener('mousemove', handleMouseMove)\n    document.addEventListener('mouseup', handleMouseUp)\n  }\n\n  if (loading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-[var(--bg-primary)]\">\n        <motion.div\n          initial={{ opacity: 0, scale: 0.9 }}\n          animate={{ opacity: 1, scale: 1 }}\n          className=\"flex flex-col items-center gap-4\"\n        >\n          <div className=\"w-16 h-16 rounded-2xl gradient-primary flex items-center justify-center animate-pulse\">\n            <Sparkles className=\"h-8 w-8 text-white\" />\n          </div>\n          <Loader2 className=\"h-6 w-6 animate-spin text-[var(--accent-primary)]\" />\n          <p className=\"text-sm text-[var(--text-tertiary)]\">Loading notebook...</p>\n        </motion.div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"h-screen flex flex-col bg-[var(--bg-primary)]\">\n      {/* Header */}\n      <motion.header\n        initial={{ opacity: 0, y: -10 }}\n        animate={{ opacity: 1, y: 0 }}\n        className=\"h-14 bg-[var(--bg-secondary)] border-b border-[rgba(255,255,255,0.1)] px-4 flex items-center gap-4 shrink-0 sticky top-0 z-50\"\n      >\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => router.push('/')}\n          className=\"h-9 w-9 rounded-lg text-[var(--text-secondary)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]\"\n        >\n          <ArrowLeft className=\"h-4 w-4\" />\n        </Button>\n\n        <div className=\"flex items-center gap-3\">\n          <div className=\"w-10 h-10 rounded-xl bg-[var(--bg-tertiary)] flex items-center justify-center text-xl\">\n            {notebook?.emoji}\n          </div>\n          <div>\n            <h1 className=\"font-semibold text-[var(--text-primary)]\">{notebook?.name}</h1>\n            {notebook?.description && (\n              <p className=\"text-xs text-[var(--text-tertiary)] line-clamp-1 max-w-[300px]\">\n                {notebook.description}\n              </p>\n            )}\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-2 ml-auto\">\n          <Badge className=\"bg-[var(--bg-tertiary)] text-[var(--text-secondary)] border-0 text-xs\">\n            {sources.length} source{sources.length !== 1 ? 's' : ''}\n          </Badge>\n          {selectedSources.size > 0 && (\n            <Badge className=\"bg-[var(--accent-primary)]/20 text-[var(--accent-primary)] border-0 text-xs\">\n              {selectedSources.size} selected\n            </Badge>\n          )}\n        </div>\n      </motion.header>\n\n      {/* Three Panel Layout */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ThreePanelLayout\n          leftPanelTitle=\"Sources\"\n          rightPanelTitle=\"Studio\"\n          leftPanel={\n            <SourcesPanel\n              sources={sources}\n              selectedSources={selectedSources}\n              onToggleSource={toggleSource}\n              onSelectAll={selectAllSources}\n              onAddSource={handleAddSource}\n              onDeleteSource={handleDeleteSource}\n              onViewSource={setViewingSource}\n              uploading={uploading}\n            />\n          }\n          centerPanel={\n            <ChatPanel\n              messages={messages}\n              message={message}\n              onMessageChange={setMessage}\n              onSendMessage={sendMessage}\n              sending={sending}\n              selectedSourcesCount={selectedSources.size}\n              totalSourcesCount={sources.length}\n              onSaveResponse={saveResponseAsNote}\n              sessions={chatSessions}\n              currentSessionId={sessionId}\n              onLoadSession={loadChatSession}\n              onNewChat={startNewChat}\n              onDeleteSession={deleteChatSession}\n              loadingSessions={loadingSessions}\n            />\n          }\n          rightPanel={\n            <StudioPanel\n              selectedSourcesCount={selectedSources.size}\n              selectedSourceIds={Array.from(selectedSources)}\n              sources={sources.map(s => ({ id: s.id, name: s.name }))}\n              audioFormat={audioFormat}\n              onAudioFormatChange={setAudioFormat}\n              audioInstructions={audioInstructions}\n              onAudioInstructionsChange={setAudioInstructions}\n              onGenerateAudio={generateAudio}\n              generatingAudio={generatingAudio}\n              videoStyle={videoStyle}\n              onVideoStyleChange={setVideoStyle}\n              onGenerateVideo={generateVideo}\n              generatingVideo={generatingVideo}\n              researchQuery={researchQuery}\n              onResearchQueryChange={setResearchQuery}\n              researchMode={researchMode}\n              onResearchModeChange={setResearchMode}\n              onRunResearch={runResearch}\n              researching={researching}\n              onGenerateStudyMaterial={handleGenerateStudyMaterial}\n              generatingFlashcards={generatingFlashcards}\n              generatingQuiz={generatingQuiz}\n              generatingStudyGuide={generatingStudyGuide}\n              generatingFaq={generatingFaq}\n              generatingMindMap={generatingMindMap}\n              onGenerateCreativeOutput={handleGenerateCreativeOutput}\n              generatingDataTable={generatingDataTable}\n              generatingReport={generatingReport}\n              generatingSlideDeck={generatingSlideDeck}\n              generatingInfographic={generatingInfographic}\n              creativeOutputs={creativeOutputsMeta}\n              onOpenCreativeOutput={(type) => {\n                const typeMap: Record<string, typeof activeStudyType> = {\n                  data_table: 'datatable',\n                  report: 'report',\n                  slide_deck: 'slides',\n                  infographic: 'infographic',\n                }\n                setActiveStudyType(typeMap[type] || null)\n                setStudySheetOpen(true)\n              }}\n              studyMaterials={studyMaterialsMeta}\n              onOpenStudyMaterial={(type) => {\n                const typeMap: Record<string, typeof activeStudyType> = {\n                  flashcards: 'flashcards',\n                  quiz: 'quiz',\n                  study_guide: 'guide',\n                  faq: 'faq',\n                  mind_map: 'mindmap',\n                }\n                setActiveStudyType(typeMap[type] || null)\n                setStudySheetOpen(true)\n              }}\n              notesCount={notes.length}\n              onAddNote={() => setAddNoteOpen(true)}\n              hasGeneratedAudio={!!generatedAudio}\n              hasGeneratedVideo={!!generatedVideo}\n              hasGeneratedResearch={!!generatedResearch}\n              onOpenAudio={() => { setActiveStudyType('audio'); setStudySheetOpen(true) }}\n              onOpenVideo={() => { setActiveStudyType('video'); setStudySheetOpen(true) }}\n              onOpenResearch={() => { setActiveStudyType('research'); setStudySheetOpen(true) }}\n            />\n          }\n        />\n      </div>\n\n      {/* Source Preview Dialog */}\n      <Dialog open={!!viewingSource} onOpenChange={(open) => !open && setViewingSource(null)}>\n        <DialogContent className=\"sm:max-w-lg bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-3 text-[var(--text-primary)]\">\n              <div className=\"w-10 h-10 rounded-lg bg-[var(--bg-tertiary)] flex items-center justify-center\">\n                <FileText className=\"h-5 w-5\" />\n              </div>\n              {viewingSource?.name}\n            </DialogTitle>\n            <DialogDescription className=\"text-[var(--text-secondary)]\">\n              {viewingSource?.type} source\n            </DialogDescription>\n          </DialogHeader>\n\n          {viewingSource?.metadata && (() => {\n            const meta = viewingSource.metadata as Record<string, unknown>\n            if (viewingSource.type === 'text' && meta.content) {\n              return (\n                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] text-sm max-h-64 overflow-y-auto\">\n                  <p className=\"whitespace-pre-wrap text-[var(--text-secondary)]\">\n                    {String(meta.content)}\n                  </p>\n                </div>\n              )\n            }\n            if ((viewingSource.type === 'youtube' || viewingSource.type === 'url') && meta.url) {\n              return (\n                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] text-sm max-h-64 overflow-y-auto\">\n                  <a\n                    href={String(meta.url)}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    className=\"text-[var(--accent-primary)] hover:underline break-all\"\n                  >\n                    {String(meta.url)}\n                  </a>\n                </div>\n              )\n            }\n            return null\n          })()}\n        </DialogContent>\n      </Dialog>\n\n      {/* Add Note Dialog */}\n      <Dialog open={addNoteOpen} onOpenChange={setAddNoteOpen}>\n        <DialogContent className=\"sm:max-w-md bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)]\">\n          <DialogHeader>\n            <DialogTitle className=\"text-[var(--text-primary)]\">Create Note</DialogTitle>\n            <DialogDescription className=\"text-[var(--text-secondary)]\">\n              Write a new note to save your thoughts.\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4 mt-2\">\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Title</label>\n              <Input\n                placeholder=\"Note title...\"\n                value={noteTitle}\n                onChange={(e) => setNoteTitle(e.target.value)}\n                className=\"h-10 bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-lg\"\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <label className=\"text-sm font-medium text-[var(--text-primary)]\">Content</label>\n              <Textarea\n                placeholder=\"Write your note...\"\n                value={noteContent}\n                onChange={(e) => setNoteContent(e.target.value)}\n                rows={6}\n                className=\"bg-[var(--bg-tertiary)] border-[rgba(255,255,255,0.1)] text-[var(--text-primary)] placeholder:text-[var(--text-tertiary)] focus:border-[var(--accent-primary)] rounded-lg resize-none\"\n              />\n            </div>\n          </div>\n          <DialogFooter className=\"mt-4\">\n            <Button\n              onClick={createNote}\n              disabled={savingNote}\n              className=\"rounded-lg bg-[var(--accent-primary)] hover:bg-[var(--accent-primary)]/90 text-white\"\n            >\n              {savingNote && <Loader2 className=\"h-4 w-4 mr-2 animate-spin\" />}\n              Create Note\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Study Materials Sheet */}\n      <Sheet open={studySheetOpen} onOpenChange={(open) => {\n        setStudySheetOpen(open)\n        if (!open) setSheetWidth(576)\n      }}>\n        <SheetContent\n          className=\"overflow-y-auto bg-[var(--bg-secondary)] border-[rgba(255,255,255,0.1)] p-0\"\n          style={{ width: sheetWidth, maxWidth: '100vw' }}\n        >\n          {/* Resize Handle */}\n          <div\n            className={`absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize hover:bg-[var(--accent-primary)]/50 transition-colors z-50 ${isResizing ? 'bg-[var(--accent-primary)]/50' : ''}`}\n            onMouseDown={handleResizeStart}\n          />\n          <div className=\"p-6\">\n          <SheetHeader>\n            <div className=\"flex items-center gap-2 pr-8\">\n              <SheetTitle className=\"flex items-center gap-2 text-[var(--text-primary)] flex-1\">\n                {activeStudyType === 'flashcards' && <><BookOpen className=\"h-5 w-5 text-blue-500\" /> Flashcards</>}\n                {activeStudyType === 'quiz' && <><ListChecks className=\"h-5 w-5 text-purple-500\" /> Quiz</>}\n                {activeStudyType === 'guide' && <><FileText className=\"h-5 w-5 text-orange-500\" /> Study Guide</>}\n                {activeStudyType === 'faq' && <><HelpCircle className=\"h-5 w-5 text-teal-500\" /> FAQ</>}\n                {activeStudyType === 'mindmap' && <><Share2 className=\"h-5 w-5 text-cyan-500\" /> Mind Map</>}\n                {activeStudyType === 'datatable' && <><Table className=\"h-5 w-5 text-emerald-500\" /> Data Table</>}\n                {activeStudyType === 'report' && <><FileSpreadsheet className=\"h-5 w-5 text-blue-500\" /> Report</>}\n                {activeStudyType === 'slides' && <><Presentation className=\"h-5 w-5 text-violet-500\" /> Slide Deck</>}\n                {activeStudyType === 'infographic' && <><ImageIcon className=\"h-5 w-5 text-rose-500\" /> Infographic</>}\n                {activeStudyType === 'audio' && <><Mic className=\"h-5 w-5 text-orange-500\" /> Audio Overview</>}\n                {activeStudyType === 'video' && <><Video className=\"h-5 w-5 text-purple-500\" /> Video Overview</>}\n                {activeStudyType === 'research' && <><Search className=\"h-5 w-5 text-blue-500\" /> Research Report</>}\n              </SheetTitle>\n              <Button\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"h-8 w-8 shrink-0\"\n                onClick={() => {\n                  if (sheetWidth < 800) {\n                    setSheetWidth(900) // Wide\n                  } else if (sheetWidth < window.innerWidth - 100) {\n                    setSheetWidth(window.innerWidth - 50) // Full\n                  } else {\n                    setSheetWidth(576) // Normal\n                  }\n                }}\n                title={sheetWidth >= window.innerWidth - 100 ? 'Minimize' : 'Expand'}\n              >\n                {sheetWidth >= window.innerWidth - 100 ? (\n                  <Minimize2 className=\"h-4 w-4\" />\n                ) : (\n                  <Maximize2 className=\"h-4 w-4\" />\n                )}\n              </Button>\n            </div>\n            <SheetDescription className=\"text-[var(--text-secondary)]\">\n              {activeStudyType === 'flashcards' && `${flashcards.length} cards generated from your sources`}\n              {activeStudyType === 'quiz' && `${quizQuestions.length} questions to test your knowledge`}\n              {activeStudyType === 'guide' && 'Comprehensive study guide from your sources'}\n              {activeStudyType === 'faq' && `${faqItems.length} frequently asked questions`}\n              {activeStudyType === 'mindmap' && 'Interactive visualization of key concepts'}\n              {activeStudyType === 'datatable' && 'Structured data extracted from your sources'}\n              {activeStudyType === 'report' && 'Professional document from your sources'}\n              {activeStudyType === 'slides' && 'Presentation slides from your sources'}\n              {activeStudyType === 'infographic' && 'Visual infographic from your sources'}\n              {activeStudyType === 'audio' && 'Podcast-style audio discussion'}\n              {activeStudyType === 'video' && 'Visual explainer video'}\n              {activeStudyType === 'research' && 'Deep web research findings'}\n            </SheetDescription>\n          </SheetHeader>\n\n          <div className=\"mt-6 relative\">\n            {/* Flashcards View */}\n            {activeStudyType === 'flashcards' && (\n              <FlashcardViewer\n                flashcards={flashcards}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Quiz View */}\n            {activeStudyType === 'quiz' && (\n              <QuizViewer\n                questions={quizQuestions}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Study Guide View */}\n            {activeStudyType === 'guide' && studyGuide && (\n              <StudyGuideViewer\n                guide={studyGuide}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* FAQ View */}\n            {activeStudyType === 'faq' && (\n              <FAQViewer\n                items={faqItems}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Mind Map View */}\n            {activeStudyType === 'mindmap' && mindMap && (\n              <MindMapViewer\n                title={mindMap.title}\n                nodes={mindMap.nodes}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Audio View */}\n            {activeStudyType === 'audio' && (\n              <AudioPlayer\n                audio={generatedAudio}\n                isGenerating={generatingAudio}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Video View */}\n            {activeStudyType === 'video' && (\n              <VideoPlayer\n                video={generatedVideo}\n                isGenerating={generatingVideo}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Research View */}\n            {activeStudyType === 'research' && (\n              <ResearchReport\n                research={generatedResearch}\n                isResearching={researching}\n                onClose={() => setStudySheetOpen(false)}\n              />\n            )}\n\n            {/* Data Table View */}\n            {activeStudyType === 'datatable' && dataTableData && (\n              <div className=\"space-y-4\">\n                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)]\">\n                  <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{dataTableData.title}</h3>\n                  <p className=\"text-sm text-[var(--text-secondary)] mb-4\">{dataTableData.description}</p>\n                  <div className=\"overflow-x-auto\">\n                    <table className=\"w-full text-sm\">\n                      <thead>\n                        <tr className=\"border-b border-[rgba(255,255,255,0.1)]\">\n                          {dataTableData.columns.map((col) => (\n                            <th key={col.key} className=\"text-left p-3 font-medium text-[var(--text-primary)]\">\n                              {col.header}\n                            </th>\n                          ))}\n                        </tr>\n                      </thead>\n                      <tbody>\n                        {dataTableData.rows.map((row, idx) => (\n                          <tr key={idx} className=\"border-b border-[rgba(255,255,255,0.05)] hover:bg-[var(--bg-secondary)]\">\n                            {dataTableData.columns.map((col) => (\n                              <td key={col.key} className=\"p-3 text-[var(--text-secondary)]\">\n                                {String(row[col.key] ?? '')}\n                              </td>\n                            ))}\n                          </tr>\n                        ))}\n                      </tbody>\n                    </table>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Report View */}\n            {activeStudyType === 'report' && reportData && (\n              <div className=\"space-y-6\">\n                <div className=\"p-4 rounded-xl bg-[var(--bg-tertiary)]\">\n                  <h2 className=\"text-xl font-bold text-[var(--text-primary)] mb-4\">{reportData.title}</h2>\n                  <div className=\"p-4 rounded-lg bg-[var(--accent-primary)]/10 border border-[var(--accent-primary)]/20 mb-6\">\n                    <h3 className=\"text-sm font-semibold text-[var(--accent-primary)] mb-2\">Executive Summary</h3>\n                    <p className=\"text-sm text-[var(--text-secondary)]\">{reportData.executive_summary}</p>\n                  </div>\n                  {reportData.sections.map((section, idx) => (\n                    <div key={idx} className=\"mb-6\">\n                      <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{section.heading}</h3>\n                      <p className=\"text-sm text-[var(--text-secondary)] whitespace-pre-wrap\">{section.content}</p>\n                    </div>\n                  ))}\n                  <div className=\"mt-6 p-4 rounded-lg bg-[var(--bg-secondary)]\">\n                    <h3 className=\"text-sm font-semibold text-[var(--text-primary)] mb-2\">Key Takeaways</h3>\n                    <ul className=\"list-disc list-inside space-y-1\">\n                      {reportData.key_takeaways.map((takeaway, idx) => (\n                        <li key={idx} className=\"text-sm text-[var(--text-secondary)]\">{takeaway}</li>\n                      ))}\n                    </ul>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {/* Slide Deck View */}\n            {activeStudyType === 'slides' && slideDeckData && (\n              <div className=\"space-y-4\">\n                <div className=\"text-center mb-6\">\n                  <h2 className=\"text-xl font-bold text-[var(--text-primary)]\">{slideDeckData.title}</h2>\n                  {slideDeckData.subtitle && (\n                    <p className=\"text-sm text-[var(--text-secondary)] mt-1\">{slideDeckData.subtitle}</p>\n                  )}\n                  <Badge className=\"mt-2 bg-[var(--bg-tertiary)] text-[var(--text-secondary)]\">\n                    {slideDeckData.slides.length} slides\n                  </Badge>\n                </div>\n                <div className=\"space-y-4\">\n                  {slideDeckData.slides.map((slide) => (\n                    <div key={slide.slide_number} className=\"p-4 rounded-xl bg-[var(--bg-tertiary)] border border-[rgba(255,255,255,0.1)]\">\n                      <div className=\"flex items-center gap-2 mb-3\">\n                        <Badge className=\"bg-[var(--accent-primary)]/20 text-[var(--accent-primary)]\">\n                          {slide.slide_number}\n                        </Badge>\n                        <span className=\"text-xs text-[var(--text-tertiary)] uppercase\">{slide.content_type}</span>\n                      </div>\n                      <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{slide.title}</h3>\n                      <p className=\"text-sm text-[var(--text-secondary)] mb-3\">{slide.main_content}</p>\n                      {slide.bullet_points && slide.bullet_points.length > 0 && (\n                        <ul className=\"list-disc list-inside space-y-1 mb-3\">\n                          {slide.bullet_points.map((point, idx) => (\n                            <li key={idx} className=\"text-sm text-[var(--text-secondary)]\">{point}</li>\n                          ))}\n                        </ul>\n                      )}\n                      {slide.speaker_notes && (\n                        <div className=\"mt-3 p-3 rounded-lg bg-[var(--bg-secondary)] text-xs text-[var(--text-tertiary)]\">\n                          <span className=\"font-medium\">Speaker notes:</span> {slide.speaker_notes}\n                        </div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Infographic View */}\n            {activeStudyType === 'infographic' && infographicData && (\n              <div className=\"space-y-6\">\n                {/* Header Section */}\n                <div\n                  className=\"p-8 rounded-2xl text-center\"\n                  style={{\n                    background: `linear-gradient(135deg, ${infographicData.color_scheme[0]}20 0%, ${infographicData.color_scheme[1]}20 100%)`,\n                    borderLeft: `4px solid ${infographicData.color_scheme[0]}`\n                  }}\n                >\n                  <h2 className=\"text-2xl font-bold text-[var(--text-primary)]\">{infographicData.title}</h2>\n                  {infographicData.subtitle && (\n                    <p className=\"text-base text-[var(--text-secondary)] mt-2\">{infographicData.subtitle}</p>\n                  )}\n                </div>\n\n                {/* Render each section based on type */}\n                {infographicData.sections.map((section, idx) => {\n                  const sectionColor = infographicData.color_scheme[idx % infographicData.color_scheme.length]\n                  const content = section.content as Record<string, unknown>\n\n                  // Stats Section\n                  if (section.section_type === 'stats' && content.items) {\n                    const items = content.items as Array<{ value: string; label: string; icon?: string }>\n                    return (\n                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n                        <div className=\"grid grid-cols-3 gap-4\">\n                          {items.map((item, i) => (\n                            <div key={i} className=\"text-center p-4 rounded-lg\" style={{ backgroundColor: `${sectionColor}15` }}>\n                              <div className=\"text-2xl font-bold\" style={{ color: sectionColor }}>{item.value}</div>\n                              <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{item.label}</div>\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    )\n                  }\n\n                  // Timeline Section\n                  if (section.section_type === 'timeline' && content.events) {\n                    const events = content.events as Array<{ date: string; title: string; description?: string }>\n                    return (\n                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n                        <div className=\"space-y-4\">\n                          {events.map((event, i) => (\n                            <div key={i} className=\"flex gap-4\">\n                              <div className=\"flex flex-col items-center\">\n                                <div className=\"w-3 h-3 rounded-full\" style={{ backgroundColor: sectionColor }} />\n                                {i < events.length - 1 && <div className=\"w-0.5 flex-1 mt-1\" style={{ backgroundColor: `${sectionColor}40` }} />}\n                              </div>\n                              <div className=\"flex-1 pb-4\">\n                                <div className=\"font-semibold\" style={{ color: sectionColor }}>{event.date}</div>\n                                <div className=\"font-medium text-[var(--text-primary)]\">{event.title}</div>\n                                {event.description && <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{event.description}</div>}\n                              </div>\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    )\n                  }\n\n                  // Process/Steps Section\n                  if (section.section_type === 'process' && content.steps) {\n                    const steps = content.steps as Array<{ step: number; title: string; description?: string }>\n                    return (\n                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n                        <div className=\"space-y-3\">\n                          {steps.map((step, i) => (\n                            <div key={i} className=\"flex gap-4 items-start\">\n                              <div\n                                className=\"w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-sm shrink-0\"\n                                style={{ backgroundColor: sectionColor }}\n                              >\n                                {step.step}\n                              </div>\n                              <div>\n                                <div className=\"font-medium text-[var(--text-primary)]\">{step.title}</div>\n                                {step.description && <div className=\"text-sm text-[var(--text-secondary)] mt-1\">{step.description}</div>}\n                              </div>\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    )\n                  }\n\n                  // Comparison Section\n                  if (section.section_type === 'comparison' && content.left && content.right) {\n                    const left = content.left as { label: string; points: string[] }\n                    const right = content.right as { label: string; points: string[] }\n                    return (\n                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n                        <div className=\"grid grid-cols-2 gap-4\">\n                          <div className=\"p-4 rounded-lg\" style={{ backgroundColor: `${infographicData.color_scheme[0]}15` }}>\n                            <div className=\"font-semibold mb-3\" style={{ color: infographicData.color_scheme[0] }}>{left.label}</div>\n                            <ul className=\"space-y-2\">\n                              {left.points.map((point, i) => (\n                                <li key={i} className=\"text-sm text-[var(--text-secondary)] flex items-start gap-2\">\n                                  <span style={{ color: infographicData.color_scheme[0] }}>•</span>\n                                  {point}\n                                </li>\n                              ))}\n                            </ul>\n                          </div>\n                          <div className=\"p-4 rounded-lg\" style={{ backgroundColor: `${infographicData.color_scheme[1]}15` }}>\n                            <div className=\"font-semibold mb-3\" style={{ color: infographicData.color_scheme[1] }}>{right.label}</div>\n                            <ul className=\"space-y-2\">\n                              {right.points.map((point, i) => (\n                                <li key={i} className=\"text-sm text-[var(--text-secondary)] flex items-start gap-2\">\n                                  <span style={{ color: infographicData.color_scheme[1] }}>•</span>\n                                  {point}\n                                </li>\n                              ))}\n                            </ul>\n                          </div>\n                        </div>\n                      </div>\n                    )\n                  }\n\n                  // List Section\n                  if (section.section_type === 'list' && content.items) {\n                    const items = content.items as string[]\n                    return (\n                      <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-4\">{section.title}</h3>}\n                        <ul className=\"space-y-3\">\n                          {items.map((item, i) => (\n                            <li key={i} className=\"flex items-start gap-3\">\n                              <div\n                                className=\"w-2 h-2 rounded-full mt-2 shrink-0\"\n                                style={{ backgroundColor: sectionColor }}\n                              />\n                              <span className=\"text-[var(--text-secondary)]\">{item}</span>\n                            </li>\n                          ))}\n                        </ul>\n                      </div>\n                    )\n                  }\n\n                  // Quote Section\n                  if (section.section_type === 'quote') {\n                    const quote = content.quote as string\n                    const author = content.author as string | undefined\n                    return (\n                      <div\n                        key={idx}\n                        className=\"p-6 rounded-xl\"\n                        style={{\n                          backgroundColor: `${sectionColor}10`,\n                          borderLeft: `4px solid ${sectionColor}`\n                        }}\n                      >\n                        {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-3\">{section.title}</h3>}\n                        <blockquote className=\"text-lg italic text-[var(--text-primary)]\">\"{quote}\"</blockquote>\n                        {author && <div className=\"mt-2 text-sm text-[var(--text-secondary)]\">— {author}</div>}\n                      </div>\n                    )\n                  }\n\n                  // Default/Header/Footer - simple display\n                  return (\n                    <div key={idx} className=\"p-6 rounded-xl bg-[var(--bg-tertiary)]\">\n                      {section.title && <h3 className=\"text-lg font-semibold text-[var(--text-primary)] mb-2\">{section.title}</h3>}\n                      {typeof content.subtitle === 'string' && <p className=\"text-[var(--text-secondary)]\">{content.subtitle}</p>}\n                      {typeof content.text === 'string' && <p className=\"text-sm text-[var(--text-tertiary)]\">{content.text}</p>}\n                    </div>\n                  )\n                })}\n\n                {/* Style suggestion footer */}\n                <p className=\"text-xs text-[var(--text-tertiary)] text-center italic pt-4 border-t border-[rgba(255,255,255,0.1)]\">\n                  Design suggestion: {infographicData.style_suggestion}\n                </p>\n              </div>\n            )}\n          </div>\n          </div>\n        </SheetContent>\n      </Sheet>\n\n      {/* Hidden file input */}\n      <input\n        ref={fileInputRef}\n        type=\"file\"\n        accept=\".pdf,.docx,.txt,.md\"\n        className=\"hidden\"\n      />\n    </div>\n  )\n}\n","numLines":2103,"startLine":1,"totalLines":2103}}}
{"parentUuid":"15822b12-9314-470a-9705-42f11b2b3319","isSidechain":true,"userType":"external","cwd":"/Users/marwankashef/Desktop/YouTube/NotebookLM Re-Mastered","sessionId":"ae35cd04-3c87-4bc1-a9af-c582458af46e","version":"2.0.76","gitBranch":"","agentId":"afbb512","slug":"reflective-leaping-lamport","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Wo2rgEiPebXCAN7NFBfr2h","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I have thoroughly explored the frontend codebase. Let me compile a comprehensive report.\n\n## Frontend Architecture & Data Fetching Analysis\n\n### Overview\n\nThe Open NotebookLM frontend is a **Next.js 14+ application** with a sophisticated three-panel layout architecture using **Supabase for authentication and database operations**, **Gemini API for AI features**, and **shadcn/ui components with Tailwind CSS for the UI**.\n\n---\n\n## 1. API Layer Architecture\n\n### Location: `/src/lib/api.ts`\n\nThe API layer is built on a **modular client pattern** with centralized authentication and error handling:\n\n#### Core Features:\n- **Central `fetchWithAuth()` wrapper** that automatically injects JWT bearer tokens from Supabase session\n- **Modular API clients** organized by feature (chat, study, audio, notes)\n- **Standardized response format** with usage metrics:\n  ```typescript\n  interface ApiResponse<T> {\n    data: T\n    usage?: {\n      input_tokens: number\n      output_tokens: number\n      cost_usd: number\n      model_used: string\n    }\n  }\n  ```\n\n#### Available Operations:\n\n**Chat API:**\n- `sendMessage(notebookId, request)` - Send message with source selection and session management\n- `getSessions(notebookId)` - Retrieve chat history\n- `getSession(notebookId, sessionId)` - Load specific session messages\n\n**Study Materials API:**\n- `generateFlashcards()` - Generate 10 flashcards by default\n- `generateQuiz()` - Generate 10 quiz questions\n- `generateStudyGuide()` - Create comprehensive study guide\n- `generateFaq()` - Generate FAQs (10 by default)\n\n**Audio Generation API:**\n- `estimate()` - Get cost estimate for audio generation\n- `generate()` - Generate audio overview with format and custom instructions\n- `list()` / `get()` / `delete()` - Audio management endpoints\n\n**Notes API:**\n- `create()` - Save written notes with tags\n- `list()` / `get()` / `update()` / `delete()` - Full CRUD\n- `saveResponse()` - Quick save of chat responses\n\n---\n\n## 2. Supabase Integration Layer\n\n### Location: `/src/lib/supabase.ts` & `/src/lib/supabase-server.ts`\n\n#### Browser Client (`supabase.ts`):\n```typescript\nconst supabase = createBrowserClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n)\n```\n\n#### Server Client (`supabase-server.ts`):\n- Uses server-side cookies for session management\n- Used in API routes for authenticated operations\n- Service role key fallback for admin operations\n\n#### Database Types Defined:\n- **Notebook** - Project metadata with `file_search_store_id` for Gemini File Search\n- **Source** - Documents with status tracking (pending/processing/ready/failed)\n- **ChatSession & ChatMessage** - Conversation storage with citations\n- **AudioOverview** - Generation jobs with progress tracking\n- **Note** - User notes and saved responses\n- **Citation** - Extracted quotes with confidence scores\n\n---\n\n## 3. Data Fetching Patterns\n\n### Pattern 1: Direct Supabase Queries (Dashboard & Notebook View)\n\nUsed in `/src/app/page.tsx` and `/src/app/notebooks/[id]/page.tsx`:\n\n```typescript\n// Dashboard fetches notebooks\nconst { data, error } = await supabase\n  .from('notebooks')\n  .select('*')\n  .order('created_at', { ascending: false })\n\n// Notebook view fetches multiple resources in parallel\nawait Promise.all([\n  fetchNotebook(),    // Single notebook by ID\n  fetchSources(),     // All sources for notebook\n  fetchNotes(),       // User notes (pinned first)\n  fetchStudyMaterials(),     // Async - non-blocking\n  fetchGeneratedContent(),    // Async - non-blocking\n  fetchCreativeOutputs(),     // Async - non-blocking\n  fetchChatSessions()         // Async - non-blocking\n])\n```\n\n### Pattern 2: Server-Side API Routes (Chat, Generation, Upload)\n\nUsed in `/src/app/api/*` routes:\n\n```typescript\n// Chat route: /api/notebooks/[id]/chat\n- POST: Send message → calls generateAIResponse() → saves to DB\n- Uses Gemini 2.0 Flash with PDF file support\n- Extracts citations from AI response\n- Saves both user and assistant messages\n\n// Sources route: /api/notebooks/[id]/sources\n- GET: List all sources with filters\n- POST: Upload file or add text/URL/YouTube source\n- Directly handles Supabase Storage uploads\n\n// Study Materials route: /api/notebooks/[id]/study\n- GET: Fetch existing materials by type\n- POST: Generate flashcards, quiz, guide, FAQ, mind map\n- Saves to study_materials table\n```\n\n### Pattern 3: Session-Based Auth Injection\n\nAll frontend API calls follow this pattern:\n\n```typescript\nconst { data: { session } } = await supabase.auth.getSession()\nconst response = await fetch('/api/notebooks/[id]/chat', {\n  method: 'POST',\n  headers: {\n    'Authorization': `Bearer ${session?.access_token}`,\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify(payload)\n})\n```\n\n---\n\n## 4. Gemini Integration\n\n### Location: `/src/lib/gemini.ts` (1000+ lines)\n\n**Model Selection Strategy:**\n- `gemini-2.0-flash-exp` - Default for chat, flashcards, study materials\n- `gemini-2.5-pro` - For audio script generation, TTS\n- `veo-2.0-generate-001` - For video generation\n- `deep-research-pro-preview` - For research tasks (if available)\n\n**Key Functions Implemented:**\n\n1. **Study Generation:**\n   - `generateFlashcards()` - Returns array of {front, back}\n   - `generateQuiz()` - Returns array of {question, options[], correct_index, explanation}\n   - `generateStudyGuide()` - Returns {title, sections[]}\n   - `generateFAQ()` - Returns array of {question, answer}\n   - `generateMindMap()` - Returns hierarchical node structure\n\n2. **Audio/Video:**\n   - `generateAudioScript()` - Two-speaker podcast format (Alex & Sam)\n   - `generateTTSAudio()` - Converts script to WAV via Gemini TTS\n   - `pcmToWav()` - Converts PCM to WAV with proper headers\n   - `generateVideo()` - Starts async Veo operation\n\n3. **Creative Outputs:**\n   - `generateDataTable()` - Extracts structured data\n   - `generateReport()` - Briefing doc, study guide, blog post\n   - `generateSlideDeck()` - Presentation structure\n   - `generateInfographic()` - Visual data structure\n\n4. **Research:**\n   - `generateResearchReport()` - Conducts research with citations\n\n---\n\n## 5. Component & State Management Architecture\n\n### Location: `/src/app/notebooks/[id]/page.tsx` (2100+ lines)\n\nThis is the **orchestration hub** that manages:\n\n**Core State:**\n```typescript\nconst [user, notebook, sources, messages, notes, loading]\nconst [selectedSources, sessionId, chatSessions]  // Chat-specific\nconst [flashcards, quizQuestions, studyGuide, faqItems, mindMap]  // Study materials\nconst [generatedAudio, generatedVideo, generatedResearch]  // Studio outputs\nconst [dataTableData, reportData, slideDeckData, infographicData]  // Creative outputs\nconst [activeStudyType, studySheetOpen, sheetWidth]  // Sheet management\n```\n\n**Data Flow:**\n1. **Initialization** → Fetch user, notebook, sources, notes\n2. **Background Loads** → Fetch study materials, generated content, creative outputs (non-blocking)\n3. **User Actions** → Send messages, generate materials, upload sources\n4. **Side Effects** → Save to Supabase, refresh metadata, update selected sources in localStorage\n\n### Three-Panel Layout\n\n**Left Panel (Sources):**\n- `<SourcesPanel>` - List with selection, upload, search\n- Drag-and-drop file upload support\n- Source type filtering (text, PDF, URL, YouTube)\n\n**Center Panel (Chat):**\n- `<ChatPanel>` - Message list with citations\n- Selection indicator showing \"X/Y sources selected\"\n- Chat session history management\n- Save responses as notes\n\n**Right Panel (Studio):**\n- `<StudioPanel>` - Generation controls\n- Audio format selector (deep_dive, brief, critique, debate)\n- Video style selector\n- Study material generation buttons with loading states\n- Creative output controls\n- Notes counter\n\n### Sheet Management\n- Resizable right sheet (576px default, 400-1920px range)\n- Type-specific viewers:\n  - Flashcards, Quiz, Study Guide, FAQ, Mind Map (Study)\n  - Data Table, Report, Slide Deck, Infographic (Creative)\n  - Audio Player, Video Player, Research Report (Studio)\n\n---\n\n## 6. Data Flow Example: Chat with Sources\n\n```\nUser selects sources → State: selectedSources = Set<sourceId>\nUser types message & sends\n\n→ sendMessage() called with:\n  - message: string\n  - source_ids: Array<sourceId>\n  - session_id: string | undefined\n\n→ POST /api/notebooks/[id]/chat:\n  - Verify auth token\n  - Fetch selected sources from DB\n  - Download file content from Supabase Storage (if needed)\n  - Build Gemini prompt with:\n    * [1] Source Name format\n    * Source content or summary\n    * Citation rules\n  - Call Gemini 2.0 Flash\n  - Extract citations from response\n  - Run quote extraction pass (if needed)\n  - Save user & assistant messages\n  - Return to frontend with usage metrics\n\n→ Frontend receives ApiResponse<ChatResponse>:\n  - Updates messages array\n  - If new session: refresh chat sessions\n  - Show citations inline with quotes\n  - Display token count & cost\n\n→ All state: localStorage saves selectedSources\n```\n\n---\n\n## 7. API Response Patterns\n\n### Success Response:\n```json\n{\n  \"data\": {\n    \"message_id\": \"uuid\",\n    \"session_id\": \"uuid\",\n    \"content\": \"AI response text\",\n    \"citations\": [\n      {\n        \"number\": 1,\n        \"source_id\": \"uuid\",\n        \"source_name\": \"Source Title\",\n        \"text\": \"Exact quote from source\",\n        \"confidence\": 0.9\n      }\n    ],\n    \"suggested_questions\": [\"Question 1\", \"Question 2\"]\n  },\n  \"usage\": {\n    \"input_tokens\": 1500,\n    \"output_tokens\": 500,\n    \"cost_usd\": 0.0023,\n    \"model_used\": \"gemini-2.0-flash-exp\"\n  }\n}\n```\n\n### Error Response:\n```json\n{\n  \"error\": \"Failed to process chat message\",\n  \"status\": 500\n}\n```\n\n---\n\n## 8. Key Abstractions & Patterns\n\n### 1. **Auth Guard Pattern**\nEvery API route has:\n```typescript\nconst authHeader = request.headers.get('authorization')\nconst token = authHeader.replace('Bearer ', '')\nconst { data: { user } } = await supabase.auth.getUser(token)\nif (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n```\n\n### 2. **Source Content Assembly**\nMultiple sources combined for Gemini:\n```typescript\nconst content = sources.map(s => {\n  const parts = [`## ${s.name}`]\n  if (s.type === 'text' && s.metadata?.content) parts.push(s.metadata.content)\n  if (s.source_guide?.summary) parts.push(`Summary: ${s.source_guide.summary}`)\n  if (s.source_guide?.key_topics) parts.push(`Key Topics: ${s.source_guide.key_topics.join(', ')}`)\n  return parts.join('\\n\\n')\n}).join('\\n\\n---\\n\\n')\n```\n\n### 3. **Loading State Management**\nSeparate boolean for each operation:\n```typescript\nconst [generatingFlashcards, setGeneratingFlashcards] = useState(false)\nconst [generatingQuiz, setGeneratingQuiz] = useState(false)\n// ... per-type loading states\n// Unified handler with loading state mapping\nconst setLoading = { 'flashcards': setGeneratingFlashcards, ... }[config.type]\n```\n\n### 4. **Session Persistence**\nSelected sources saved to localStorage:\n```typescript\nuseEffect(() => {\n  const savedSelection = localStorage.getItem(`notebook-${notebookId}-selected-sources`)\n  if (savedSelection) {\n    const savedIds = JSON.parse(savedSelection)\n    const validIds = savedIds.filter(id => sources.some(s => s.id === id))\n    setSelectedSources(new Set(validIds))\n  }\n}, [sources, loading, notebookId])\n```\n\n---\n\n## 9. Summary of Operations\n\n| Feature | Endpoint | Method | Auth | Returns |\n|---------|----------|--------|------|---------|\n| Send Chat Message | `/api/notebooks/[id]/chat` | POST | JWT | ChatResponse + Usage |\n| List Chat Sessions | `/api/notebooks/[id]/chat/sessions` | GET | JWT | ChatSession[] |\n| Generate Flashcards | `/api/notebooks/[id]/study` | POST | JWT | { flashcards: [], source_count } |\n| Generate Audio | `/api/notebooks/[id]/audio` | POST | JWT | AudioOverview |\n| List Audio | `/api/notebooks/[id]/audio` | GET | JWT | AudioOverview[] |\n| Upload Source | `/api/notebooks/[id]/sources` | POST | JWT | Source |\n| List Sources | `/api/notebooks/[id]/sources` | GET | JWT | Source[] |\n| Create Note | `/api/notebooks/[id]/notes` | POST | JWT | Note |\n| List Notebooks | `/` (direct DB) | - | Session | Notebook[] |\n\n---\n\n## 10. Key Files Reference\n\n```\n/src/\n├── lib/\n│   ├── api.ts                 # API client with auth wrapper\n│   ├── supabase.ts           # Browser Supabase client + types\n│   ├── supabase-server.ts    # Server Supabase client\n│   └── gemini.ts             # 926 lines of AI generation logic\n│\n├── app/\n│   ├── page.tsx              # Dashboard (1400 lines)\n│   ├── auth/\n│   │   ├── login/page.tsx\n│   │   └── register/page.tsx\n│   ├── notebooks/\n│   │   └── [id]/page.tsx     # Main notebook view (2100 lines)\n│   └── api/\n│       └── notebooks/[id]/\n│           ├── chat/route.ts\n│           ├── sources/route.ts\n│           ├── study/route.ts\n│           ├── audio/route.ts\n│           ├── video/route.ts\n│           ├── research/route.ts\n│           ├── studio/route.ts\n│           └── notes/route.ts\n│\n└── components/\n    ├── panels/three-panel-layout.tsx\n    ├── sources/sources-panel.tsx\n    ├── chat/chat-panel.tsx\n    ├── studio/studio-panel.tsx\n    ├── study/\n    │   ├── flashcard-viewer.tsx\n    │   ├── quiz-viewer.tsx\n    │   ├── study-guide-viewer.tsx\n    │   ├── faq-viewer.tsx\n    │   └── mind-map-viewer.tsx\n    └── ui/\n        └── [shadcn components]\n```\n\nThis architecture demonstrates a **well-organized separation of concerns** with centralized authentication, modular API clients, and sophisticated state management for complex multi-feature operations."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":30016,"cache_read_input_tokens":75483,"cache_creation":{"ephemeral_5m_input_tokens":30016,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWavr2dH8pKxZHaJaT3Xo","type":"assistant","uuid":"577ee8e0-b8b2-4710-8165-7db9342be7f1","timestamp":"2025-12-29T11:51:37.500Z"}
